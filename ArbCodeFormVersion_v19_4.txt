// IdealData C# Arbitraj Robot - SPOT-NEAR + NEAR-FAR + PAIR TRADING
// === VERSİYON: 2026-02-01 v19.4 ===
// 
// ÖZELLİKLER:
// - Spot-Near arbitraj stratejisi + Rollover
// - Near-Far (NF) takvim spread stratejisi
// - Pair Trading (VIOP Near-Near kointegrasyon)
// - Piyasa kontrolü: Saat + XU030 hacim (tatil/yarım gün tespiti)
// - Recovery sistemi (başlangıç, bağlantı kopması, periyodik)
// - SubMarket 19220 filtresi (sadece pay vadeliler)
// - API optimizasyonu: Tek RefreshHesaplar fonksiyonu, sıra VIOP→BIST sabit
// - Gist Dashboard entegrasyonu (uzaktan izleme ve STOP komutu)
// - Log klasörü ayrımı (D:\arbit\logs\)
// - Gist credentials ayrı dosya (güvenlik)
// 
// v19.4 DEĞİŞİKLİKLER (2026-02-01):
// - YENİ: Sermaye artırımı koruma sistemi
//   * srm.json dosyasından sermaye artırımı takvimi okuma
//   * srm_scraper.py ile Piramit Menkul PDF'den veri çekme
//   * Bugün veya 7 gün içinde sermaye artırımı varsa SN/NF/Pair giriş engeli
//   * 09:25'te otomatik güncelleme (temettü ile aynı zamanda)
//   * Robot başlangıcında veri yükleme
// 
// v19.3 DEĞİŞİKLİKLER (2026-01-31):
// - BUG FIX: dailyPairPnl ve totalClosedPair günlük sıfırlama eklendi
// - BUG FIX: Pair Trading döngüsüne marginStatus < 2 kontrolü eklendi
// - TEMİZLİK: Kullanılmayan değişkenler kaldırıldı (spreadRetrySymbols, lastSpreadRetry, SPREAD_RETRY_INTERVAL_MIN, MAX_STALE_DATA_MINUTES)
// - YENİ: Zengin başlangıç formu (ayarlar özeti + pozisyon sayısı + strateji durumu)
//   * Robot başlamadan önce tüm ayarları görebilme
//   * "Ayarlar" butonu ile settings.json düzenleyebilme
//   * Değişiklikler kaydedilince özet otomatik güncellenir
//   * ShowSettingsForm artık mainForm olmadan da çalışır
// - YENİ: IsPairLimitBlocked fonksiyonu - Pair Trading taban/tavan kontrolü
//   * Giriş ve çıkışta taban/tavan kontrolü
//   * Tavanda BUY, tabanda SELL engellenir
//   * Orphan leg riski azaltıldı
// - YENİ: OpenPair/ClosePair TAM DOLUM kontrolü
//   * İlk bacak kısmi dolarsa geri alınır
//   * İkinci bacak kısmi dolarsa her iki bacak geri alınır
//   * ClosePair'de kısmi kapanış desteği (kalan pozisyon güncellenir)
//   * Dengesiz pozisyon riski ortadan kalktı
// - YENİ: NF RECOVERY mekanizması (OTOMATİK DÜZELTME)
//   * Near LONG ve Far SHORT pozisyonları ayrı takip edilir
//   * nfPos ile broker karşılaştırılır
//   * Broker'da yok/bizde var → nfPos'tan silinir
//   * Broker'da var/bizde yok: Her iki bacak → ekle, Orphan → spread uygunsa tamamla değilse kapat
//   * PAIR_BLOCKED sembolleri NF recovery'den hariç tutulur
// - YENİ: PAIR RECOVERY mekanizması (OTOMATİK DÜZELTME)
//   * Broker'da var/bizde yok → pairPos'a eklenir + oran düzeltilir
//   * Broker'da yok/bizde var → pairPos'tan silinir
//   * Orphan (tek taraf) → Eksik bacak beta oranına göre açılır
//   * Oran hatası (sapma > PAIR_RATIO_TOLERANCE) → Alış/satış ile beta oranına getirilir
//   * Miktar uyumsuzluğu → Broker'a göre güncellenir + oran düzeltilir
//   * Bizdeki oran doğruysa bizim miktarlarımıza göre düzeltir
// - YENİ: AÇILIŞ VOLATİLİTESİ KORUMASI (10:05 bekleme)
//   * Tüm stratejiler (SN, NF, Pair) için 10:05'e kadar yeni giriş yapılmaz
//   * ENTRY_WAIT_MINUTES değişkeni (varsayılan 5 dk)
//   * IsAfterOpeningVolatility() fonksiyonu
// - YENİ: TEMETTÜ GÜNÜ KORUMASI (SN, NF, Pair)
//   * Ex-dividend günü ilgili sembole giriş yapılmaz
//   * IsDividendDay(sym) fonksiyonu
//   * SN: Spot düşerken Near henüz düzelmemiş olabilir
//   * NF: BB verisi (5dk grafik) henüz düzeltilmemiş olabilir
//   * Pair: Z-Score anlık spot fiyatla hesaplanıyor, temettü düşmüş fiyat yanlış sinyal verir
// - YENİ: ASYNC GIST UPLOAD
//   * UpdateDashboard artık ayrı thread'de çalışır
//   * MainLoop GitHub API timeout'undan etkilenmez
//   * gistUploadInProgress flag ile çift upload önlenir
//   * Veri hazırlama main thread'de, HTTP isteği arka planda
// - YENİ: GÜVENLİ DOSYA YAZIMI (FileShare.ReadWrite)
//   * Log ve SafeWrite artık diğer process'leri bloklamaz
//   * Antivirus, yedekleme yazılımı, Notepad eş zamanlı erişebilir
//   * SafeWrite'da 3 deneme retry mekanizması
//   * Log yazma hatası robotu durdurmaz (try-catch içinde)
// - YENİ: NF AÇILIŞ/KAPANIŞ ÖN KONTROLÜ
//   * OpenNF: Far SAT öncesi Near Ask derinliği kontrol edilir
//   * CloseNF: Far AL öncesi Near Bid derinliği kontrol edilir
//   * Near likiditesi yoksa işlem başlamaz
//   * Far orphan riski azaltıldı (geri alma/satma maliyeti önlendi)
//   * Vade günü (EXPIRY) kapanışında kontrol atlanır (zorla kapat)
// - İYİLEŞTİRME: PAIR BETA SAPMA TOLERANSI
//   * PAIR_RATIO_TOLERANCE değişkeni eklendi (ayarlanabilir)
//   * %15 → %10'a düşürüldü (daha sıkı kontrol)
//   * Kaldıraçlı pozisyonlarda gereksiz teminat kullanımı önlenir
// - YENİ: PAIR PENDING COMPLETION SİSTEMİ
//   * OpenPair: İkinci bacak dolmadığında hemen kapatmak yerine beklemeye alınır
//   * ClosePair: İkinci bacak (B) dolmadığında beklemeye alınır (A zaten kapatılmış)
//   * PAIR_PENDING_WAIT_SEC (30sn) sonra tekrar denenir
//   * PAIR_PENDING_MAX_RETRY (2) deneme hakkı
//   * Açılışta: Z-Score hala uygunsa yeni fiyattan emir gönderilir
//   * Kapanışta: Derinlik varsa B bacağı tekrar denenir
//   * Max retry aşıldığında: Açılışta geri kapatılır, Kapanışta Recovery'ye bırakılır
//   * pairPendingCompletion dictionary'si ile takip edilir (tier=-1 kapanış modu)
//   * CheckPairPending() fonksiyonu ana döngüde çağrılır
//
// v19.2 DEĞİŞİKLİKLER (2026-01-31):
// - BUG FIX: Pair Trading Rollover düzeltildi
//   * pairContracts dictionary eklendi - kontrat takibi
//   * OpenPair artık contractOffset parametresi alıyor (0=Near, 1=Far)
//   * Rollover'da Far kontrat (offset=1) kullanılıyor
//   * ClosePair artık pairContracts'tan doğru kontratı alıyor
//   * positions.json'a pair kontratları eklendi (ca, cb alanları)
//   * Backward compatible: Eski array formatı da okunabiliyor
//
// v19.1 DEĞİŞİKLİKLER (2026-01-31):
// - YENİ: Kademe bütçe dağılımı değişken olarak (PAIR_ALLOC_1/2/3)
//   * Varsayılan: 30/30/40 (%)
//   * Settings Form'dan ayarlanabilir
//   * %100 validasyonu ile kaydetme
// - Settings Form'a kademe dağılımı satırı eklendi (Dağılım %: K1/K2/K3)
// - Dashboard'a kademe dağılımı gösterimi eklendi
// - tierBudgetPct artık hardcoded değil, değişkenlerden hesaplanıyor
//
// v19 DEĞİŞİKLİKLER (2026-01-30):
// - YENİ: Pair Trading Stratejisi (VIOP Near-Near)
//   * CIMSA-OYAKC (β=2.03) ve TCELL-TTKOM (β=1.80) çiftleri
//   * Z-Score bazlı kademeli giriş (2.0, 2.5, 3.0 eşikleri)
//   * Ayrı bütçe: PAIR_BUDGET = 100,000 TL (SN/NF'den izole)
//   * Kontrollü GIE: Az likit bacak önce, 3 deneme ile ikinci bacak
//   * Günlük grafik verisinden spread ve Z-Score hesaplama
//   * PAIR_BLOCKED: 4 sembol SN/NF'den hariç tutuldu
// - YENİ: pairPos dictionary, OpenPair(), ClosePair(), CheckPairSignals()
// - YENİ: LoadPairData(), UpdatePairZScores() fonksiyonları
// - positions.json ve stats.json'a pair pozisyonları eklendi
// - Settings'e pair parametreleri eklendi
// - SN/NF bütçe hesaplamasında PAIR_BUDGET ayrıldı
//
// v18 DEĞİŞİKLİKLER (2026-01-30):
// - RecoverMissingLeg: orphanLegs kaydında giriş fiyatı snPos'tan alınıyor
// - YENİ: Temettü yönetim sistemi (Temettu.json)
//   * Robot başlangıcında ve 09:25'te otomatik güncelleme
//   * Temettu_Scraper.py ile InfoYatırım PDF'den veri çekme
//   * NF stratejisinde Near-Far arası temettü kontrolü
//   * GetDividendsBetween() - İki vade arası temettü hesaplama
// - YENİ: SN vade son günü (daysN=0) güvenlik önlemleri
//   * Yeni pozisyon açılmıyor
//   * Büyütme/Replacement yapılmıyor
//   * Kapanış/Rollover sadece 12:00 sonrası (yarım gün 12:30 kapanışına 30dk marj)
// - YENİ: NF vade son günü (daysN=0) 12:00 kontrolü eklendi
// - YENİ: NF kontrat kodları saklanıyor (vade geçişinde doğru kontratların kullanılması için)
//   * nfContracts dictionary eklendi
//   * positions.json'da nearC/farC alanları eklendi (backward compatible)
// - BUG FIX: GetContract vade geçişi düzeltildi (vade tarihinden sonra otomatik sonraki aya geçiş)
// - BUG FIX: Settings.json kaydetme - saat/dakika int.Parse ile (00 → 0 JSON hatası düzeltildi)
// - BUG FIX: Cache path kaydetme - TrimEnd ile trailing backslash normalize
// - BUG FIX: Sıfıra bölünme korumaları eklendi:
//   * expectedPnl sıfır kontrolü (erken çıkış log)
//   * posSpotValue sıfır kontrolü (T+2 kapatma)
//   * Temettü parse sonsuz döngü önleme (ilerleme kontrolü)
// - Tüm v18 özellikleri doğrulandı ve test edildi:
//   * Erken çıkış dinamik k formülü (EARLY_EXIT_K)
//   * Orphan 10:05 bekletme sistemi (CheckPendingOrders + RecoverMissingLeg)
//   * MainLoop'ta TİP 1/TİP 2 orphan karar mekanizması
//   * BB93+ pozisyon izolasyonu
//   * NF devre kesici (INDEX_CIRCUIT_PCT, SPOT_CIRCUIT_PCT)
//
// v17.10 DEĞİŞİKLİKLER (2026-01-29):
// - YENİ: Near-Far (NF) Takvim Spread Stratejisi
//   * Near AL + Far SAT (spread BB >= 99 giriş)
//   * BB <= 27 VEYA binde 3 kar çıkış
//   * Maksimum 1 NF pozisyonu (şimdilik)
//   * Çalışma saatleri: 10:00-12:00
//   * Ayrı bütçe: NF_BUDGET = en büyük teminat × 2
//   * Çakışma kontrolü: SN pozisyonu varsa NF açılamaz (aynı sembol)
// - VIOP_RESERVE = en büyük teminat × 4 + 5000 (SN için 2x + NF için 2x)
// - YENİ: nfPos dictionary, OpenNF(), CloseNF(), CheckNFClose()
// - Form'a NF ayarları eklendi (aktif/pasif, max poz, BB eşikleri, kar çıkış)
// - stats.json ve positions.json'a NF pozisyonları eklendi
// - WarmupDepthCache ve LoadTavanTaban'a Far derinlik/tavan/taban eklendi
// - BUG FIX: BIST kapalıyken (18:00+) SN açılış/kapanış/rollover engellendi
//   * BIST 18:00'da kapanıyor, VİOP 18:10'da
//   * SN işlemleri Spot gerektirir, BIST açık olmalı
//   * isBistOpen kontrolü eklendi (10:01-18:00)
// - BUG FIX: NF_BUDGET 2x → 3x (açılış 2 + kapanış GİE 1)
// - VIOP_RESERVE 4x → 5x (SN 2x + NF 3x)
// - İYİLEŞTİRME: NF_BUDGET ve VIOP_RESERVE artık dinamik (2n+1 formülü)
//   * NF_BUDGET = maxTeminat × (NF_MAX_POSITIONS × 2 + 1)
//   * VIOP_RESERVE = maxTeminat × (2 + 2n+1) + 5000
//   * n=1 → 3x, n=2 → 5x, n=3 → 7x
// - YENİ: orphanLegs dictionary - yarım kalan pozisyonları takip
//   * Near satıldı ama Spot alınamadı → orphanLegs'e kaydet
//   * Recovery spread kontrolünde açılış fiyatını kullanır
//   * Pending order veya recovery tamamlayınca orphanLegs'ten siler
//   * positions.json'a kaydedilir/yüklenir
// - İYİLEŞTİRME: Pending order manuel iptal kontrolü
//   * BekleyenEmirler'de yok + GerceklesenEmirler'de yok → Manuel iptal
//   * pendingOrders'tan temizlenir, bütçe serbest bırakılır
//   * orphanLegs Recovery'ye bırakılır (pozisyon hala açık olabilir)
// - İYİLEŞTİRME: Recovery'de orphanLegs manuel tamamlama kontrolü
//   * orphanLegs'te kayıt var ama broker'da pozisyon yok → Manuel tamamlanmış
//   * orphanLegs'ten temizlenir
// - YENİ: Erken kapanış dinamik k formülü (eski skor sistemi yerine)
//   * earnedTarget = expectedPnl × elapsedRatio × (1 + k)
//   * k = EARLY_EXIT_K × remainingRatio (vade sonuna yaklaştıkça k düşer)
//   * closePnl >= earnedTarget VE BB5 < BB_EXIT_HELPER → KAPAT
//   * Avantaj: Vade sonuna yaklaşınca imkansız eşikler yok, her zaman çıkış mümkün
//   * Yeni parametre: EARLY_EXIT_K (0.20), BB_EXIT_HELPER (30)
// - İYİLEŞTİRME: NF stratejisine devre kesici kontrolü eklendi
//   * Endeks ≥%5 düşüş: Yeni NF açılışı durdurulur (kar alma devam eder)
//   * Spot ≥%8 düşüş: O hisse için yeni NF açılışı durdurulur (kar alma devam eder)
//   * Devre kesicide spread daralabilir, kar alma fırsatı kaçırılmasın
//
// v17.9 DEĞİŞİKLİKLER (2026-01-28):
// - YENİ: ReadDepth() merkezi derinlik okuma fonksiyonu
//   * Tüm derinlik okumaları tek fonksiyondan yapılıyor
//   * 1. kademe 0 ise 3 kez 100ms arayla retry
//   * 3 deneme sonunda 0 ise "❌ SEMBOL BID/ASK derinlik yok (3 deneme)" logu
//   * Yüzeysel veri (AlisLot/SatisLot) KULLANILMIYOR - 26ms gecikme riski
// - GÜNCELLENDİ: OpenSN, AddToSN, CloseSN, PartialCloseSN, RolloverSN → ReadDepth kullanıyor
// - DÜZELTME: Rezerv moduna girmeden önce "kapatılabilir pozisyon var mı" kontrolü
//   * Yeni pozisyon açmadan önce threshold geçen en az 1 pozisyon olmalı
//   * Aksi halde rezerv açık kalıyordu (kritik bug)
//
// v17.8 DEĞİŞİKLİKLER (2026-01-28):
// - KALDIRILDI: Günlük BB kontrolü (SN_BB_ENTRY) - analiz sonucu işe yaramıyor
//   * BB her zaman %80 altında kaldığı için filtre hiç çalışmıyordu
//   * skipFilters (DTE < 15) mantığı da artık gereksiz
// - Form'dan "BB Entry %" alanı kaldırıldı
// - Config'den sn_bb_entry parametresi kaldırıldı
// - 5dk BB (BB93 stratejisi) gün içi için aktif kalmaya devam ediyor
// 
// v17.7 DEĞİŞİKLİKLER (2026-01-28):
// - Spread cache KALDIRILDI - artık grafik verisinden hesaplanıyor
// - YENİ: LoadSpreadBBFromChart() - 5dk grafik verisinden BB pozisyonu hesaplar
// - snBB → snBBPos: Artık sadece son BB değeri saklanıyor (0-100 arası)
// - Her 5 dakikada bir tüm semboller için BB güncelleniyor
// - spread_cache.json artık kullanılmıyor
// 
// v17.5 DEĞİŞİKLİKLER (2026-01-28):
// - İkinci recovery saati 17:50 → 17:35 (spread analizi sonucu: 17:40'ta genişleme başlıyor)
// - REZERV AÇILIŞ/BÜYÜTME: Near VE Spot derinlik kontrolü eklendi (2 kademe)
// - Miktar artık her iki tarafın derinliğine göre ayarlanıyor (min(Near, Spot))
// - Spot derinlik yoksa 3 deneme retry (emir göndermeden önce)
// - Spot kısmi dolumda fazla Near geri alınıyor (ExecGuar zaten 2x derinliğe emir atıyor)
// - ATR filtreleri tamamen kaldırıldı (NormATR, SpotATR) - saat analizi ile değiştirilecek
// - İYİLEŞTİRME: GetDays artık YüzeyselVeri.DaysToExpiry kullanıyor (VİOP'un resmi verisi)
// - İYİLEŞTİRME: GetHours da DaysToExpiry'den hesaplanıyor
// - Fallback: YüzeyselVeri alınamazsa eski manuel hesaplama kullanılır
// - YENİ: Rezerv modunda (yeni açılış + büyütme) anlık zarar kontrolü eklendi
//   * Kapatılacak pozisyon zararda ise, yeni işlemin beklenen karı bu zararı karşılamalı
//   * Formül: expectedPnl >= |worstCurrentPnl| × (1 + REPLACEMENT_THRESHOLD)
//   * Pozisyon kârda ise kontrol atlanır
//   * Hem yeni pozisyon açılışı hem de büyütme için geçerli
//
// v17.3 DEĞİŞİKLİKLER:
// - YENİ: SPOT_BUDGET_RESERVE = en yüksek fiyatlı spot × 50 lot
// - YENİ: spotBalance hesaplamasından SPOT_BUDGET_RESERVE düşülüyor
// - MANTIK: VIOP'ta VIOP_RESERVE nasıl düşülüyorsa, SPOT'ta da SPOT_BUDGET_RESERVE düşülür
// - AMAÇ: Her zaman en az 1 pozisyon açabilme garantisi (50 lot = 0.5 Near lot karşılığı)
//
// v17.2 DEĞİŞİKLİKLER:
// - DEĞİŞİKLİK: "Önce kapat sonra aç" modu tamamen kaldırıldı (spread kaçırma riski)
// - DEĞİŞİKLİK: Replacement/büyütme için bütçe yetersizse:
//   * Rezerv yeterliyse → Rezerv modu (önce aç sonra kapat)
//   * Rezerv yetersizse → PAS GEÇ (işlem yapılmaz)
// - MANTIK: Rezervler yetmiyorsa zaten sistem düzgün çalışmıyor demektir
//
// v17.1 DEĞİŞİKLİKLER:
// - YENİ: SPOT_RESERVE dinamik hesaplama (T+2 - 5000 TL = kredi olarak kullanılabilir)
// - YENİ: Rezerv modunda hem VIOP hem SPOT eksikse, her ikisi için de rezerv kullanılabiliyor
// - İYİLEŞTİRME: AdjustT2Balance içinde SPOT_RESERVE otomatik güncelleniyor
//
// v17.0 DEĞİŞİKLİKLER:
// - BUG FIX: Robot başlarken eski log dosyası siliniyor (temiz başlangıç)
// - BUG FIX: Veri bağlantısı kopunca: hemen → 1dk sonra → saatte bir Gist güncelleme
// - BUG FIX: Veri bağlantısı kopukken de broker bağlantı kontrolü yapılıyor
// - BUG FIX: Dashboard'a spot_bal olarak spotBudgetTotal gönderiliyor
// - BUG FIX: Başlangıçta dataConnected gerçek değerle set ediliyor
// - BUG FIX: expectedPnl 0 ise positions.json yüklenirken yeniden hesaplanıyor
// - BUG FIX: Replacement/büyütme için bütçe sınırda threshold kontrolü eklendi
// - BUG FIX: Replacement döngüsünde her pozisyon sonrası spread kontrolü (bozulursa dur)
// - BUG FIX: Dashboard currentPnl hesabı DayanakSatAl ile düzeltildi
// - YENİ: Pending orders için bütçe ayrılıyor (SPOT ve VIOP)
// - YENİ: Pending order olan sembol için OpenSN/AddToSN/CloseSN engelleniyor
// - YENİ: Replacement'da pending order olan semboller atlanıyor
// - YENİ: Büyütmede Near Ask derinlik kontrolü (ilk 3 kademe >= pozisyon x 5)
// - YENİ: Bütçe sınırda iken (boşluk < 2x pozisyon) threshold'a SN_TOTAL_COST ekleniyor
// - YENİ: Teminat kaydedilirken sembol listeleri D:\ideal\SembolListeleri'ne yazılıyor
// - YENİ: VIOP_RESERVE = maxTeminat × 2 + 5000 (önce aç sonra kapat için 2x gerekli)
//
// v16.30 DEĞİŞİKLİKLER:
// - BUG FIX: CACHE_PATH artık LOG_PATH ve STATS_FILE tarafından kullanılıyor
// - RAMDisk desteği düzgün çalışıyor: CACHE_PATH=Z:\ yapınca log ve stats Z:'ye yazılır
//
// v16.29 DEĞİŞİKLİKLER:
// - BUG FIX: entryTicks p[7]'ye taşındı (gün içi kar ve erken kar düzgün çalışıyor)
// - BUG FIX: BuildStatsJson'da spotEntry sıfır kontrolü eklendi
// - BUG FIX: CheckSNClose'da spotValue sıfır kontrolü eklendi (bölme hatası önlendi)
// - BUG FIX: CloseSN'de nQty sıfır kontrolü eklendi (kısmi kapanışta bölme hatası önlendi)
// - BUG FIX: HandleMarginCritical'da teminatToplam sıfır kontrolü eklendi
// - BUG FIX: CheckFilledQty lastOrderNo yerine son 10sn içindeki emirlere bakıyor
// - İYİLEŞTİRME: UpdateDashboard her zaman tam pozisyon bilgisi gönderiyor (fullStats kaldırıldı)
// - İYİLEŞTİRME: STOP anında ve bağlantı geri geldiğinde de tam stats gönderiliyor
// - İYİLEŞTİRME: Recovery önce lokal stats.json'dan pozisyon bilgisi almayı deniyor
// - YENİ: Cache path ayarı (RAMDisk desteği - stats.json ve loglar için Z:\ gibi)
// - YENİ: Log dosyası sabit isim (arb.log), 1000 satır limit, truncate (RAMDisk için optimize)
// - YENİ: VIOP_RESERVE = 25000 TL (Near kapatma için geçici teminat rezervi)
// - Veri yapısı: [spotQty, nearQty, spotEntry, nearEntry, entrySpread, expectedPnl, addCount, entryTicks]
// - positions.json ve stats.json'a entryTicks eklendi
// - Geriye uyumlu: Eski 7 elemanlı dosyalar okunabiliyor (entryTicks=şimdi)

// ====================================
// DOSYA YOLLARI
// ====================================
var BASE_PATH = @"D:\arbit\";
var CACHE_PATH = @"D:\arbit\";  // RAMDisk için Z:\ olarak değiştirilebilir (stats.json ve log için)
var LOG_PATH = CACHE_PATH + @"logs\";  // CACHE_PATH kullanır
var STATS_FILE = CACHE_PATH + "stats.json";  // CACHE_PATH kullanır
var TEMINAT_FILE = BASE_PATH + "teminat.json";
var SETTINGS_FILE = BASE_PATH + "settings.json";
var GIST_CREDENTIALS_FILE = BASE_PATH + "gist_credentials.json";
var POSITIONS_FILE = BASE_PATH + "positions.json";
var TEMETTU_FILE = BASE_PATH + "Temettu.json";  // Temettü verileri
var TEMETTU_SCRAPER = BASE_PATH + "Temettu_Scraper.py";  // Temettü scraper
var SRM_FILE = BASE_PATH + "srm.json";  // Sermaye artırımı verileri
var SRM_SCRAPER = BASE_PATH + "srm_scraper.py";  // Sermaye artırımı scraper
// Kullanılmayan eski değişkenler kaldırıldı (SPREAD_CACHE_MAX_AGE_MIN, SN_BB_ENTRY, ATR)

// Temettü verileri: {symbol: [{date, amount}, ...]}
var dividends = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.List<System.Tuple<DateTime, decimal>>>();
var lastTemettuCheck = DateTime.MinValue;  // Son temettü kontrolü

// Sermaye artırımı verileri: {symbol: date}
var sermayeArtirimlari = new System.Collections.Generic.Dictionary<string, DateTime>();
var lastSrmCheck = DateTime.MinValue;  // Son sermaye artırımı kontrolü
var lastSrmCloseCheck = DateTime.MinValue;  // Son sermaye artırımı kapatma kontrolü

var SPOT_PREFIX = "IMKBH'";
var FUTURES_PREFIX = "VIP'";
var ROBOT_NAME = "ArbBot";

// ====================================
// ÇALIŞMA SAATLERİ (BİST) + HACİM KONTROLÜ
// ====================================
var MARKET_OPEN_HOUR = 10;
var MARKET_OPEN_MINUTE = 1;
var MARKET_CLOSE_HOUR = 18;
var MARKET_CLOSE_MINUTE = 9;
var BIST_CLOSE_HOUR = 18;      // BIST kapanış saati (SN açılışı için)
var BIST_CLOSE_MINUTE = 0;     // BIST kapanış dakikası
var ENTRY_WAIT_MINUTES = 5;    // Piyasa açılışından sonra giriş bekleme süresi (temettü/volatilite koruması)
var lastXU030Volume = 0.0;
var lastVolumeCheckTime = DateTime.MinValue;
var isMarketOpen = false;

// ====================================
// FORWARD DECLARATIONS (Pair Trading'den önce kullanılması için)
// ====================================

// Bugün temettü günü mü kontrolü (ex-dividend date)
Func<string, bool> IsDividendDay = (sym) => {
    if (!dividends.ContainsKey(sym)) return false;
    
    var today = DateTime.Now.Date;
    foreach (var div in dividends[sym]) {
        if (div.Item1.Date == today) {
            return true;
        }
    }
    return false;
};

// Açılış volatilitesi bekleme süresi geçti mi kontrolü
Func<bool> IsAfterOpeningVolatility = () => {
    var now = DateTime.Now;
    var currentMinutes = now.Hour * 60 + now.Minute;
    var entryStartMinutes = MARKET_OPEN_HOUR * 60 + MARKET_OPEN_MINUTE + ENTRY_WAIT_MINUTES;  // 10:05 (veya 10:06)
    return currentMinutes >= entryStartMinutes;
};

// Sermaye artırımı durumunu kontrol et
// Returns: 0=Güvenli, 1=Bugün(bloke), 2=7 gün içinde(bloke)
Func<string, int> CheckSermayeArtirimi = (symbol) => {
    // Sembolü normalize et (THYAO, F_THYAO0226 -> THYAO)
    string normalizedSymbol = symbol.ToUpper();
    if (normalizedSymbol.StartsWith("F_")) {
        normalizedSymbol = normalizedSymbol.Substring(2);
        if (normalizedSymbol.Length > 4) {
            normalizedSymbol = normalizedSymbol.Substring(0, normalizedSymbol.Length - 4);
        }
    }
    
    if (!sermayeArtirimlari.ContainsKey(normalizedSymbol)) {
        return 0;  // Güvenli - listede yok
    }
    
    DateTime saDate = sermayeArtirimlari[normalizedSymbol];
    int gunFarki = (saDate.Date - DateTime.Today).Days;
    
    if (gunFarki == 0) {
        return 1;  // Bugün
    } else if (gunFarki > 0 && gunFarki <= 7) {
        return 2;  // 7 gün içinde
    }
    return 0;  // Geçmiş veya 7 günden uzak
};

// Sermaye artırımı nedeniyle işlem blokeli mi?
// Bugün VEYA 7 gün içinde ise TRUE döner
// NOT: Log fonksiyonu henüz tanımlı olmadığı için burada log yok, çağrı noktasında loglanır
Func<string, bool> IsSermayeArtirimiBlocked = (symbol) => {
    int status = CheckSermayeArtirimi(symbol);
    return status > 0;  // 1=Bugün, 2=7 gün içinde → blokeli
};

// ====================================
// KOMİSYON VE VERGİ
// ====================================
var COMMISSION_RATE = 0.00009m;
var TAKASBANK_RATE = 0.000004m;
var TAX_RATE = 0.05m;

// Sözleşme çarpanı - Sadece hisse (100x)
Func<string, int> GetMultiplier = (sym) => 100;

var TOTAL_COST_RATE = (COMMISSION_RATE + TAKASBANK_RATE) * (1 + TAX_RATE);
var SN_TOTAL_COST = TOTAL_COST_RATE * 4;

// ====================================
// RİSK YÖNETİMİ
// ====================================
var MAX_DAILY_LOSS = 10000m;
var REPLACEMENT_THRESHOLD = 0.10m;
var INTRADAY_MIN_PROFIT = 0.002m;  // Gün içi kar minimum (binde 2)

// Erken Kapanış Skor Sistemi
// Skor = (Kâr Oranı) × (Kalan Süre Oranı)
// Erken çıkış için dinamik k formülü: earnedTarget = expectedPnl × elapsedRatio × (1 + k)
// k = EARLY_EXIT_K × remainingRatio (vade sonuna yaklaştıkça k düşer)
var EARLY_EXIT_K = 0.20m;                  // Erken çıkış k katsayısı (0.20 = %20 marj başlangıçta)
var BB_EXIT_HELPER = 30m;                  // BB5 çıkış yardımcı referansı (altındaysa çık)

// BB93+ Giriş Stratejisi Parametreleri (Spot-Near)
var BB93_ENTRY_ENABLED = true;     // BB 93+ girişi aktif mi
var BB93_ENTRY_THRESHOLD = 93m;    // Giriş için BB eşiği
var BB93_EXIT_BB = 15m;            // Çıkış için BB eşiği
var BB93_EXIT_SPREAD = 0.0023m;    // Çıkış için spread daralması (%0.23)
var BB93_START_HOUR = 10;          // BB93 giriş başlangıç saati
var BB93_START_MIN = 0;            // BB93 giriş başlangıç dakikası
var BB93_END_HOUR = 12;            // BB93 giriş bitiş saati
var BB93_END_MIN = 55;             // BB93 giriş bitiş dakikası

// ====================================
// NEAR-FAR (NF) STRATEJİSİ PARAMETRELERİ
// ====================================
// Near AL + Far SAT (takvim spread arbitrajı)
var NF_ENABLED = true;             // Near-Far stratejisi aktif mi
var NF_MAX_POSITIONS = 1;          // Maksimum NF pozisyon sayısı (şimdilik 1)
var NF_ENTRY_BB = 99m;             // Giriş için BB eşiği (>= 99)
var NF_EXIT_BB = 27m;              // Çıkış için BB eşiği (<= 27)
var NF_EXIT_PROFIT = 0.003m;       // Çıkış için minimum kar (binde 3)
var NF_START_HOUR = 10;            // NF giriş başlangıç saati
var NF_START_MIN = 0;              // NF giriş başlangıç dakikası
var NF_END_HOUR = 12;              // NF giriş bitiş saati
var NF_END_MIN = 0;                // NF giriş bitiş dakikası
var NF_BUDGET = 0m;                // NF bütçesi (dinamik: en büyük teminat × 2)

// ====================================
// PAIR TRADING PARAMETRELERİ
// ====================================
// VIOP Near-Near kointegrasyon arbitrajı
var PAIR_ENABLED = true;           // Pair Trading aktif mi
var PAIR_BUDGET = 100000m;         // Pair Trading teminat bütçesi (SN/NF'den ayrı)
var PAIR_MAX_TIERS = 3;            // Maksimum kademe sayısı

// Z-Score eşikleri (kademeli giriş)
var PAIR_Z_ENTRY_1 = 2.0m;         // Kademe 1 giriş
var PAIR_Z_ENTRY_2 = 2.5m;         // Kademe 2 giriş  
var PAIR_Z_ENTRY_3 = 3.0m;         // Kademe 3 giriş
var PAIR_Z_EXIT = 0.5m;            // Çıkış eşiği

// Kademe bütçe dağılımı (toplam %100 olmalı)
var PAIR_ALLOC_1 = 30;             // Kademe 1 bütçe yüzdesi
var PAIR_ALLOC_2 = 30;             // Kademe 2 bütçe yüzdesi
var PAIR_ALLOC_3 = 40;             // Kademe 3 bütçe yüzdesi

// Beta oran sapma toleransı (Recovery'de düzeltme eşiği)
var PAIR_RATIO_TOLERANCE = 0.10m;  // %10 sapma toleransı (önceden %15'ti)

// Pair çalışma saatleri
var PAIR_START_HOUR = 10;
var PAIR_START_MIN = 5;
var PAIR_END_HOUR = 17;
var PAIR_END_MIN = 59;

// Margin Call Seviyeleri (kullanılabilir teminat / toplam teminat)
var MARGIN_WARNING_PCT = 0.10m;   // Sarı uyarı: <%10 kullanılabilir
var MARGIN_DANGER_PCT = 0.05m;    // Turuncu tehlike: <%5 kullanılabilir
var MARGIN_CRITICAL_PCT = 0.00m;  // Kırmızı kritik: %0 (teminat tükendi)

// Devre Kesici Koruması
var SPOT_CIRCUIT_PCT = -8.0m;     // Spot %8 düşüş = devre kesici
var INDEX_CIRCUIT_PCT = -5.0m;   // BIST100 %5 düşüş = endeks devre kesici

// ====================================
// TEKNİK PARAMETRELER
// ====================================
var MAX_LOG_LINES = 1000;  // RAMDisk için satır limiti (truncate)
var LOOP_MS = 2000;
var BB_PERIOD = 20;
var GIE_WAIT_MS = 3000;
var GIE_DEPTH_LEVELS = 1;  // GIE için kaç kademe derinlik kontrol edilsin (1 veya 2)
var COOLDOWN = 600000000L;
var GIST_TOKEN = "";
var GIST_ID = "";
var lastGistUpload = DateTime.MinValue;
var GIST_INTERVAL_MIN = 1;
var gistUploadInProgress = false;  // Async upload devam ediyor mu
var gistUploadThread = (System.Threading.Thread)null;  // Gist upload thread'i

// ====================================
// ÇALIŞMA PARAMETRELERİ
// ====================================
var IS_TEST = false;
var VIOP_BUDGET = 70000m;
var SPOT_BUDGET = 490000m;
var VIOP_RESERVE = 25000m;  // Near kapatma için geçici teminat rezervi (dinamik güncellenir)
var SPOT_RESERVE = 0m;      // Kredi olarak kullanılabilir SPOT rezervi (dinamik: t2Balance - 5000)
var SPOT_BUDGET_RESERVE = 0m;  // Bütçe yeterlilik için SPOT rezervi (dinamik: maxSpotPrice × 50)
// SN_BB_ENTRY kaldırıldı - günlük BB kontrolü analiz sonucu işe yaramıyor
var SN_MIN_MARGIN = -0.02m;
var ROLL_MIN_MARGIN = 0.005m;  // Rollover için minimum kar marjı (%0.5)
var RISK_FREE = 0.50m;

// Bakiye değişkenleri (test vs gerçek mod)
var viopBalance = 0m;  // Kullanılabilir VİOP teminatı
var spotBalance = 0m;  // Kullanılabilir SPOT bakiyesi (yeni poz açmak için)
var spotBudgetTotal = 0m;  // Toplam SPOT bütçe (dashboard için: spotUsed + t2Balance)
var t2Balance = 0m;    // T+2 bakiye (canlı mod için)
var apiDataOk = false; // API verisi geldi mi? (canlıda false ise hiç işlem yapma)
var t2NegativeDetected = false;  // T+2 negatif tespit edildi mi?
var t2NegativeTime = DateTime.MinValue;  // İlk tespit zamanı
var t2CriticalAlert = false;  // T+2 kritik uyarı (17:00 sonrası hala negatifse)

// ====================================
// API CACHE SİSTEMİ
// ====================================
// Tüm API çağrıları RefreshHesaplar üzerinden geçer (sıra: VIOP → BIST)
// Get fonksiyonları sadece cache'den okur, API çağırmaz
dynamic _bistHesap = null;
dynamic _viopHesap = null;

// Forward declarations
Action CheckPendingOrders = null;
Action CheckMarginStatus = null;
Func<string, DateTime, DateTime, System.Tuple<bool, decimal>> GetDividendsBetween = null;
var inMarginCheck = false;

// BIST hesap okuma (sadece cache'den, API çağırmaz)
Func<dynamic> GetBistHesap = () => {
    return _bistHesap;
};

// VIOP hesap okuma (sadece cache'den, API çağırmaz)
Func<dynamic> GetViopHesap = () => {
    return _viopHesap;
};

// Tek hesap yenileme fonksiyonu (sıra: VIOP → BIST, her zaman aynı)
// NOT: spotUsed henüz tanımlı olmayabilir, bu yüzden try-catch içinde
Action<bool> RefreshHesaplar = (waitFirst) => {
    if (waitFirst) System.Threading.Thread.Sleep(2000);  // Emir teyidi için bekleme
    try {
        _viopHesap = Sistem.ViopHesapOku();
    } catch { }
    System.Threading.Thread.Sleep(200);  // API güvenlik arası
    try {
        _bistHesap = Sistem.BistHesapOku();
        
        // T+2 hesapla (canlı mod)
        if (!IS_TEST && _bistHesap != null && _bistHesap.Bakiye > 0 && _bistHesap.Pozisyonlar != null) {
            var bakiye = (decimal)_bistHesap.Bakiye;
            decimal totalHisseValue = 0;
            var allPricesOk = true;
            
            var pozList = _bistHesap.Pozisyonlar;
            for (int i = 0; i < pozList.Count; i++) {
                var sym = pozList[i].Symbol ?? "";
                // IMKBH' prefix'ini temizle
                if (sym.StartsWith("IMKBH'")) sym = sym.Substring(6);
                var lot = (int)pozList[i].Lot;
                if (lot > 0) {
                    decimal price = 0;
                    
                    // 1. Önce LastPrice dene (güncel fiyat)
                    try { price = (decimal)pozList[i].LastPrice; } catch { }
                    
                    // 2. LastPrice yoksa Cost kullan (maliyet)
                    if (price <= 0) {
                        try { price = (decimal)pozList[i].Cost; } catch { }
                    }
                    
                    // 3. Piyasa açıksa SonFiyat dene
                    if (price <= 0 && isMarketOpen) {
                        try {
                            var livePrice = (decimal)Sistem.SonFiyat("IMKBH'" + sym);
                            if (livePrice > 0) price = livePrice;
                        } catch { }
                    }
                    
                    if (price > 0) {
                        totalHisseValue += price * lot;
                    } else {
                        allPricesOk = false;  // En az bir fiyat alınamadı
                    }
                }
            }
            
            // Tüm fiyatlar alındıysa T+2 güncelle
            if (allPricesOk && totalHisseValue > 0) {
                t2Balance = bakiye - totalHisseValue;
                // spotBalance = T+2 - SPOT_BUDGET_RESERVE (kullanılabilir bakiye)
                spotBalance = t2Balance - SPOT_BUDGET_RESERVE;
                if (spotBalance < 0) spotBalance = 0;
                // SPOT_RESERVE = T+2 - 5000 (kredi olarak kullanılabilir miktar)
                SPOT_RESERVE = t2Balance > 5000m ? t2Balance - 5000m : 0m;
                // spotBudgetTotal UpdateBalances'da güncellenir
            }
        }
    } catch { }
    System.Threading.Thread.Sleep(200);  // Sonraki çağrı için güvenlik
    
    // Bekleyen emirleri kontrol et
    if (CheckPendingOrders != null) CheckPendingOrders();
};

// ====================================
// VERİ YAPILARI
// ====================================
var teminat = new System.Collections.Generic.Dictionary<string, decimal>();
var symbols = new System.Collections.Generic.List<string>();
var snBBPos = new System.Collections.Generic.Dictionary<string, decimal>();  // Sembol -> BB pozisyonu (0-100)

// Spot-Near: [spotQty, nearQty, spotEntry, nearEntry, entrySpread, expectedPnl, addCount, entryTicks]
//               0        1         2          3           4            5           6          7
var snPos = new System.Collections.Generic.Dictionary<string, decimal[]>();

var blockedSymbols = new System.Collections.Generic.Dictionary<string, string>();
var lastBlockReset = DateTime.Today;

var isPaused = false;
var stopRequested = false;
var isRunning = false;  // Robot çalışıyor mu (dashboard için)
var settingsNeedReload = false;
System.Windows.Forms.Form mainForm = null;
System.Windows.Forms.Label lblStatus = null;
System.Windows.Forms.Label lblInfo = null;
System.Windows.Forms.Label lblLog = null;
System.Windows.Forms.Button btnPause = null;

var viopUsed = 0m;
var spotUsed = 0m;
var rejected = new System.Collections.Generic.Dictionary<string, long>();

// Near-Far pozisyonları
// nfPos[sym] = [nearQty, farQty, nearEntry, farEntry, entrySpread, expectedPnl, entryTicks]
var nfPos = new System.Collections.Generic.Dictionary<string, decimal[]>();
var nfContracts = new System.Collections.Generic.Dictionary<string, string[]>();  // nfContracts[sym] = [nearC, farC]
var nfViopUsed = 0m;  // NF için kullanılan VIOP teminatı

// Yetim bacaklar (bir bacak doldu, diğeri dolmadı)
// orphanLegs[sym] = { filledLeg, filledCode, filledSide, filledQty, filledPrice, targetLeg, targetCode, targetSide, targetQty, timestamp }
// Örnek: Near satıldı, Spot alınamadı → { "NEAR", "F_THYAO0126", "SELL", 2, 514.50, "SPOT", "THYAO", "BUY", 200, ticks }
var orphanLegs = new System.Collections.Generic.Dictionary<string, object[]>();

// ====================================
// PAIR TRADING DEĞİŞKENLERİ
// ====================================
// Çift tanımları string formatı: "SYMB_A-SYMB_B:BETA,SYMB_C-SYMB_D:BETA"
// Örnek: "TCELL-TTKOM:1.80,CIMSA-OYAKC:2.03"
var PAIR_DEFINITIONS = "TCELL-TTKOM:1.80,CIMSA-OYAKC:2.03";

// Parse edilmiş çift tanımları: {symA, symB, beta}
var PAIR_DEFS = new System.Collections.Generic.List<object[]>();

// Yasaklı semboller (SN/NF'den hariç) - dinamik güncellenir
var PAIR_BLOCKED = new System.Collections.Generic.HashSet<string>();

// Pair pozisyonları: {pairKey: [qtyA, qtyB, avgA, avgB, openZ, tier, entryTicks, expectedPnl]}
var pairPos = new System.Collections.Generic.Dictionary<string, decimal[]>();

// Pair kontratları: {pairKey: [nearA, nearB]} - Rollover için kontrat takibi
var pairContracts = new System.Collections.Generic.Dictionary<string, string[]>();

// Pair spread geçmişi (günlük): {pairKey: List<spread>}
var pairSpreads = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.List<decimal>>();

// Pair Z-Score cache
var pairZScores = new System.Collections.Generic.Dictionary<string, decimal>();

// Pair kullanılan teminat
var pairUsed = 0m;

// Pair istatistikleri
var totalClosedPair = 0;
var dailyPairPnl = 0m;
var lastPairDataLoad = DateTime.MinValue;

// Pair Pending Completion (tek bacak açık kalmış, ikinci bacak bekliyor)
// {pairKey: [pairIdx, tier, isLongA, contractOffset, filledLeg(A/B), filledSide, filledQty, filledPrice, filledContract, timestamp, retryCount]}
var pairPendingCompletion = new System.Collections.Generic.Dictionary<string, object[]>();
var PAIR_PENDING_WAIT_SEC = 30;    // İkinci bacak için bekleme süresi (saniye)
var PAIR_PENDING_MAX_RETRY = 2;    // Maksimum tekrar deneme sayısı

// Tavan/Taban fiyatları (warmup'ta yüklenir)
var tavanFiyat = new System.Collections.Generic.Dictionary<string, decimal>();  // Sembol -> Tavan fiyat
var tabanFiyat = new System.Collections.Generic.Dictionary<string, decimal>();  // Sembol -> Taban fiyat

// Tavan/Taban kontrol fonksiyonları
// TAVAN = Satıcı yok = Alış fiyatı tavana yapışık = ALINAMAZ
// TABAN = Alıcı yok = Satış fiyatı tabana yapışık = SATILAMAZ
Func<string, decimal, bool> IsTavan = (sembol, alisFiyat) => {
    if (!tavanFiyat.ContainsKey(sembol) || tavanFiyat[sembol] <= 0) return false;
    return alisFiyat >= tavanFiyat[sembol];
};

Func<string, decimal, bool> IsTaban = (sembol, satisFiyat) => {
    if (!tabanFiyat.ContainsKey(sembol) || tabanFiyat[sembol] <= 0) return false;
    return satisFiyat <= tabanFiyat[sembol];
};

// Spot işlem sonrası T+2 güncelleme (API beklemeden)
// amount: pozitif = alış (T+2 azalır), negatif = satış (T+2 artar)
// commission: her zaman pozitif, T+2'den düşülür
Action<decimal, decimal> AdjustT2Balance = (amount, commission) => {
    if (IS_TEST) return;  // Test modunda gerek yok
    
    // Alış: T+2 azalır (para çıkışı)
    // Satış: T+2 artar (para girişi)
    t2Balance -= amount;
    t2Balance -= commission;  // Komisyon her zaman düşer
    
    // spotBalance ve spotBudgetTotal güncelle (SPOT_BUDGET_RESERVE düşülür)
    spotBalance = t2Balance - SPOT_BUDGET_RESERVE;
    if (spotBalance < 0) spotBalance = 0;
    spotBudgetTotal = spotUsed + t2Balance;
    
    // SPOT_RESERVE = T+2 - 5000 (kredi olarak kullanılabilir miktar)
    SPOT_RESERVE = t2Balance > 5000m ? t2Balance - 5000m : 0m;
};

// VIOP işlem sonrası teminat güncelleme (API beklemeden)
// teminatChange: pozitif = teminat kullanıldı (azalır), negatif = teminat serbest (artar)
Action<decimal> AdjustViopBalance = (teminatChange) => {
    if (IS_TEST) {
        // Test modunda da güncelle
        viopBalance = VIOP_BUDGET - viopUsed - VIOP_RESERVE;
        if (viopBalance < 0) viopBalance = 0;
    } else {
        // Canlıda anlık güncelle
        viopBalance -= teminatChange;
        if (viopBalance < 0) viopBalance = 0;
    }
};

var dailyRealizedPnl = 0m;
var dailyTrades = 0;
var dailySpotCommission = 0m;   // SPOT işlem komisyonları
var dailyViopCommission = 0m;   // VİOP işlem komisyonları (henüz transfer edilmemiş)
var totalTransferredComm = 0m;  // SPOT'a transfer edilmiş toplam VİOP komisyonu
var lastCommissionTransfer = DateTime.MinValue;  // Son komisyon transfer zamanı

// Günlük kapanış takibi
var dailySNPnl = 0m;            // Günlük Spot-Near kar/zarar
var totalClosedSN = 0;          // Günlük kapatılan SN pozisyon sayısı
var lastStatsSaveDate = "";     // Son stats kayıt tarihi

// Stats history dosyası
var STATS_HISTORY_FILE = BASE_PATH + "stats_history.json";

var brokerConnected = true;     // Aracı kurum bağlantısı
var dataConnected = true;       // IdealData veri bağlantısı
var lastBrokerCheck = DateTime.MinValue;  // Son bağlantı kontrol zamanı

// Margin durumu: 0=Normal, 1=Warning(sarı), 2=Danger(turuncu), 3=Critical(kırmızı)
var marginStatus = 0;
// inMarginCheck yukarıda forward declaration olarak tanımlı

// Devre kesici durumu
var indexCircuitBreaker = false;  // Endeks devre kesici aktif mi
var spotCircuitBreakers = new System.Collections.Generic.HashSet<string>();  // Devre kesici aktif semboller

// ====================================
// LOG FONKSİYONU
// ====================================
var logLines = new System.Collections.Generic.List<string>();
var logPath = "";

Action<string> Log = (msg) => {
    var now = DateTime.Now;
    var line = now.ToString("HH:mm:ss.fff") + " " + msg;
    
    try {
        // Log klasörü yoksa oluştur
        if (!System.IO.Directory.Exists(LOG_PATH)) {
            System.IO.Directory.CreateDirectory(LOG_PATH);
        }
        
        // Sabit dosya adı (tarihsiz - RAMDisk için)
        var currentPath = LOG_PATH + "arb.log";
        
        // İlk çalıştırma veya path değişti - mevcut dosyayı oku
        if (logPath != currentPath) {
            logPath = currentPath;
            logLines.Clear();
            if (System.IO.File.Exists(logPath)) {
                var existingLines = System.IO.File.ReadAllLines(logPath, System.Text.Encoding.UTF8);
                logLines.AddRange(existingLines);
            }
        }
        
        // Yeni satırı ekle
        logLines.Add(line);
        
        // Limit aşıldıysa eski satırları sil (son 1000 satırı tut)
        if (logLines.Count > MAX_LOG_LINES) {
            var removeCount = logLines.Count - MAX_LOG_LINES;
            logLines.RemoveRange(0, removeCount);
        }
        
        // Dosyaya yaz (her 10 satırda bir veya önemli mesajlarda)
        // RAMDisk kullanıldığı için her satırda yaz
        if (msg.Contains("HATA") || msg.Contains("BAŞLADI") || msg.Contains("STOP") || msg.Contains("KAPAN") || msg.Contains("AÇILDI") || logLines.Count % 3 == 0) {
            // FileShare.ReadWrite ile yaz - diğer process'ler okuyabilir
            try {
                var utf8 = new System.Text.UTF8Encoding(false);
                var content = string.Join(Environment.NewLine, logLines.ToArray());
                var bytes = utf8.GetBytes(content);
                using (var fs = new System.IO.FileStream(logPath, System.IO.FileMode.Create, System.IO.FileAccess.Write, System.IO.FileShare.ReadWrite)) {
                    fs.Write(bytes, 0, bytes.Length);
                }
            } catch { }  // Log yazma hatası robotu durdurmamalı
        }
        
        // UI'da son 5 satırı göster
        if (mainForm != null && lblLog != null && !mainForm.IsDisposed) {
            try {
                mainForm.BeginInvoke(new Action(() => {
                    try {
                        var startIdx = Math.Max(0, logLines.Count - 8);
                        var last8 = new System.Text.StringBuilder();
                        for (int i = startIdx; i < logLines.Count; i++) {
                            if (last8.Length > 0) last8.AppendLine();
                            // Satırı kısalt (max 100 karakter)
                            var ln = logLines[i];
                            if (ln.Length > 100) ln = ln.Substring(0, 97) + "...";
                            last8.Append(ln);
                        }
                        lblLog.Text = last8.ToString();
                    } catch { }
                }));
            } catch { }
        }
    } catch { }
};

// ====================================
// KONTRAT VE SEMBOL FONKSİYONLARI
// ====================================
// Kontrat adı hesaplama - Sadece aylık vade (hisse)
Func<string, int, string> GetContract = (sym, offset) => {
    var now = DateTime.Now;
    var m = now.Month + offset;
    var y = now.Year % 100;
    while (m > 12) { m -= 12; y++; }
    
    // Ayın son iş gününü bul (vade tarihi)
    var fullYear = 2000 + y;
    var lastDay = new DateTime(fullYear, m, DateTime.DaysInMonth(fullYear, m));
    while (lastDay.DayOfWeek == DayOfWeek.Saturday || lastDay.DayOfWeek == DayOfWeek.Sunday) 
        lastDay = lastDay.AddDays(-1);
    
    // Eğer bugün vade tarihinden sonraysa, bir sonraki aya geç
    if (now.Date > lastDay.Date) {
        m++;
        if (m > 12) { m = 1; y++; }
    }
    
    return "F_" + sym + m.ToString("D2") + y.ToString("D2");
};

// Kontrat kodundan vade tarihini hesapla (ayın son iş günü)
Func<string, DateTime> GetExpiryDate = (contract) => {
    try {
        var l = contract.Length;
        var mm = int.Parse(contract.Substring(l - 4, 2));
        var yy = int.Parse(contract.Substring(l - 2, 2)) + 2000;
        var last = new DateTime(yy, mm, DateTime.DaysInMonth(yy, mm));
        while (last.DayOfWeek == DayOfWeek.Saturday || last.DayOfWeek == DayOfWeek.Sunday) 
            last = last.AddDays(-1);
        return last;
    } catch { 
        return DateTime.Now.AddDays(30); 
    }
};

Func<string, int> GetDays = (contract) => {
    try {
        // Önce YüzeyselVeri'den DaysToExpiry al (en doğru kaynak)
        var yuz = Sistem.YuzeyselVeriOku("VIP'" + contract);
        if (yuz != null) {
            var dte = (int)yuz.DaysToExpiry;
            if (dte >= 0) return dte;
        }
        // Fallback: Kontrat kodundan manuel hesapla
        var l = contract.Length;
        var mm = int.Parse(contract.Substring(l - 4, 2));
        var yy = int.Parse(contract.Substring(l - 2, 2)) + 2000;
        var last = new DateTime(yy, mm, DateTime.DaysInMonth(yy, mm));
        while (last.DayOfWeek == DayOfWeek.Saturday || last.DayOfWeek == DayOfWeek.Sunday) 
            last = last.AddDays(-1);
        return (int)(last - DateTime.Now).TotalDays;
    } catch { return 30; }
};

Func<string, int> GetHours = (contract) => {
    try {
        // Önce YüzeyselVeri'den DaysToExpiry al ve saate çevir
        var yuz = Sistem.YuzeyselVeriOku("VIP'" + contract);
        if (yuz != null) {
            var dte = (int)yuz.DaysToExpiry;
            if (dte >= 0) {
                // Gün sayısını saate çevir (18:10 kapanış varsayımı)
                var now = DateTime.Now;
                var hoursToday = (18 * 60 + 10 - now.Hour * 60 - now.Minute) / 60.0;
                return (int)(dte * 24 + (hoursToday > 0 ? hoursToday : 0));
            }
        }
        // Fallback: Kontrat kodundan manuel hesapla
        var l = contract.Length;
        var mm = int.Parse(contract.Substring(l - 4, 2));
        var yy = int.Parse(contract.Substring(l - 2, 2)) + 2000;
        var last = new DateTime(yy, mm, DateTime.DaysInMonth(yy, mm), 18, 10, 0);
        while (last.DayOfWeek == DayOfWeek.Saturday || last.DayOfWeek == DayOfWeek.Sunday) 
            last = last.AddDays(-1);
        return (int)(last - DateTime.Now).TotalHours;
    } catch { return 720; }
};

// ====================================
// YARDIMCI FONKSİYONLAR
// ====================================
// Güvenli dosya yazma - FileShare.ReadWrite ile diğer process'ler okuyabilir
Action<string, string> SafeWrite = (path, content) => {
    try {
        var tmp = path + ".tmp";
        var utf8 = new System.Text.UTF8Encoding(false);
        var bytes = utf8.GetBytes(content);
        
        // Temp dosyaya yaz (FileShare.Read - antivirus okuyabilir)
        using (var fs = new System.IO.FileStream(tmp, System.IO.FileMode.Create, System.IO.FileAccess.Write, System.IO.FileShare.Read)) {
            fs.Write(bytes, 0, bytes.Length);
        }
        
        // Atomic replace (3 deneme)
        for (int i = 0; i < 3; i++) {
            try {
                if (System.IO.File.Exists(path)) System.IO.File.Delete(path);
                System.IO.File.Move(tmp, path);
                break;
            } catch {
                if (i < 2) System.Threading.Thread.Sleep(100);
            }
        }
    } catch { }
};

// Piyasa kontrolü: Saat + XU030 hacim değişimi
// Tatil/yarım gün için hacim değişimi şart
Func<bool> CheckMarketOpen = () => {
    var now = DateTime.Now;
    
    // Hafta sonu kesin kapalı
    if (now.DayOfWeek == DayOfWeek.Saturday || now.DayOfWeek == DayOfWeek.Sunday) return false;
    
    // Saat kontrolü (10:01-18:09 dışında kesin kapalı)
    var currentMinutes = now.Hour * 60 + now.Minute;
    var openMinutes = MARKET_OPEN_HOUR * 60 + MARKET_OPEN_MINUTE;
    var closeMinutes = MARKET_CLOSE_HOUR * 60 + MARKET_CLOSE_MINUTE;
    if (currentMinutes < openMinutes || currentMinutes > closeMinutes) return false;
    
    // Hacim kontrolü (tatil/yarım gün tespiti)
    try {
        var currentVolume = Sistem.HacimGun("IMKBX'XU030");
        
        // İlk çağrı - hacmi kaydet
        if (lastXU030Volume == 0) {
            lastXU030Volume = currentVolume;
            lastVolumeCheckTime = now;
            return currentVolume > 0;  // Hacim varsa açık
        }
        
        // Hacim değiştiyse piyasa açık
        if (currentVolume > lastXU030Volume) {
            lastXU030Volume = currentVolume;
            lastVolumeCheckTime = now;
            return true;
        }
        
        // Hacim değişmediyse ama son 5 dakika içinde değişmişti → hala açık say
        if ((now - lastVolumeCheckTime).TotalMinutes < 5) {
            return true;
        }
        
        // 5 dakikadan fazla hacim değişmedi → piyasa kapalı (tatil/arıza)
        return false;
    } catch {
        return false;
    }
};

// Derinlik fonksiyonları
Func<string, bool, int, decimal> Depth2x = (sym, buy, qty) => {
    try {
        var d = Sistem.DerinlikVerisiOku(sym);
        if (d == null) return 0;
        var total = 0;
        var arr = buy ? d.Asks : d.Bids;
        for (int i = 0; i < 5 && i < arr.Count; i++) {
            total += (int)arr[i].Size;
            if (total >= qty * 2) return (decimal)arr[i].Price;
        }
        return arr.Count > 0 ? (decimal)arr[arr.Count - 1].Price : 0;
    } catch { return 0; }
};

// Test modu için: 2x derinliğe kadar ortalama fiyat hesapla
Func<string, bool, int, decimal> DepthAvgPrice = (sym, buy, qty) => {
    try {
        var d = Sistem.DerinlikVerisiOku(sym);
        if (d == null) return 0;
        var arr = buy ? d.Asks : d.Bids;
        if (arr == null || arr.Count == 0) return 0;
        
        decimal totalValue = 0;
        int totalQty = 0;
        int targetQty = qty;  // İstenen miktar
        
        for (int i = 0; i < arr.Count && totalQty < targetQty; i++) {
            var kademeFiyat = (decimal)arr[i].Price;
            var kademeMiktar = (int)arr[i].Size;
            var alQty = Math.Min(kademeMiktar, targetQty - totalQty);
            totalValue += kademeFiyat * alQty;
            totalQty += alQty;
        }
        
        return totalQty > 0 ? totalValue / totalQty : 0;
    } catch { return 0; }
};

// Bollinger Bands
Func<System.Collections.Generic.List<decimal>, System.Tuple<decimal, decimal, decimal>> CalcBB = (d) => {
    if (d == null || d.Count < BB_PERIOD) return System.Tuple.Create(0m, 0m, 0m);
    decimal sum = 0;
    for (int i = d.Count - BB_PERIOD; i < d.Count; i++) sum += d[i];
    var mid = sum / BB_PERIOD;
    decimal sq = 0;
    for (int i = d.Count - BB_PERIOD; i < d.Count; i++) { var x = d[i] - mid; sq += x * x; }
    var std = (decimal)Math.Sqrt((double)(sq / BB_PERIOD));
    return System.Tuple.Create(mid + 2 * std, mid, mid - 2 * std);
};

Func<decimal, decimal, decimal, decimal> BBPos = (v, u, l) => u == l ? 50 : ((v - l) / (u - l)) * 100;

// ====================================
// PAIR TRADING YARDIMCI FONKSİYONLARI
// ====================================
// Pair key oluştur
Func<string, string, string> GetPairKey = (a, b) => a + "-" + b;

// PAIR_DEFINITIONS string'ini parse et
Action ParsePairDefinitions = () => {
    PAIR_DEFS.Clear();
    PAIR_BLOCKED.Clear();
    
    if (string.IsNullOrEmpty(PAIR_DEFINITIONS) || PAIR_DEFINITIONS.Trim().Length == 0) {
        Log("📊 PAIR: Tanım yok, strateji pasif");
        return;
    }
    
    foreach (var pair in PAIR_DEFINITIONS.Split(',')) {
        try {
            var parts = pair.Trim().Split(':');
            if (parts.Length != 2) continue;
            var syms = parts[0].Split('-');
            if (syms.Length != 2) continue;
            
            decimal beta;
            if (!decimal.TryParse(parts[1].Trim(), System.Globalization.NumberStyles.Any, 
                System.Globalization.CultureInfo.InvariantCulture, out beta)) continue;
            
            var symA = syms[0].Trim().ToUpper();
            var symB = syms[1].Trim().ToUpper();
            
            PAIR_DEFS.Add(new object[] { symA, symB, beta });
            PAIR_BLOCKED.Add(symA);
            PAIR_BLOCKED.Add(symB);
            
            Log("📊 PAIR: " + symA + "-" + symB + " β=" + beta.ToString("F2") + " eklendi");
        } catch { }
    }
    
    if (PAIR_DEFS.Count == 0) {
        Log("📊 PAIR: Geçerli çift yok, strateji pasif");
    }
};

// Bütçeden lot sayısı hesapla (kademe bazlı)
// Kademe 1: Bütçenin %30'u, Kademe 2: %30'u, Kademe 3: %40'ı
Func<int, int, decimal, decimal, decimal, int[]> CalcPairLots = (pairIdx, tier, beta, priceA, priceB) => {
    // Kademe başına bütçe oranları
    var tierBudgetPct = new decimal[] { PAIR_ALLOC_1 / 100m, PAIR_ALLOC_2 / 100m, PAIR_ALLOC_3 / 100m };
    if (tier < 0 || tier >= tierBudgetPct.Length) return new int[] { 0, 0 };
    
    var def = PAIR_DEFS[pairIdx];
    var symA = (string)def[0];
    var symB = (string)def[1];
    
    // Teminat değerleri
    var temA = teminat.ContainsKey(symA) ? teminat[symA] : 1000m;
    var temB = teminat.ContainsKey(symB) ? teminat[symB] : 1000m;
    
    // Bu kademe için ayrılan bütçe
    var tierBudget = PAIR_BUDGET * tierBudgetPct[tier];
    
    // lotA × temA + lotB × temB = tierBudget
    // lotB = lotA × beta (yaklaşık)
    // lotA × temA + lotA × beta × temB = tierBudget
    // lotA = tierBudget / (temA + beta × temB)
    
    var denominator = temA + beta * temB;
    if (denominator <= 0) return new int[] { 0, 0 };
    
    var lotA = (int)Math.Floor(tierBudget / denominator);
    var lotB = (int)Math.Round(lotA * beta);
    
    // Minimum lot kontrolü
    if (lotA < 1 || lotB < 1) return new int[] { 0, 0 };
    
    return new int[] { lotA, lotB };
};

// Pair için devre kesici kontrolü (herhangi bir bacak)
// NOT: IsSpotCircuitBreaker henüz tanımlanmadığı için spotCircuitBreakers HashSet'ini doğrudan kullanıyoruz
Func<string, string, bool> IsPairCircuitBreaker = (symA, symB) => {
    return spotCircuitBreakers.Contains(symA) || spotCircuitBreakers.Contains(symB);
};

// Pair için taban/tavan kontrolü
// isLongA: true = A alınacak (A tavanda mı?), B satılacak (B tabanda mı?)
// isLongA: false = A satılacak (A tabanda mı?), B alınacak (B tavanda mı?)
Func<string, string, bool, bool> IsPairLimitBlocked = (symA, symB, isLongA) => {
    try {
        // VIOP kontrat isimleri (Near)
        var nearA = GetContract(symA, 0);
        var nearB = GetContract(symB, 0);
        if (string.IsNullOrEmpty(nearA) || string.IsNullOrEmpty(nearB)) return false;
        
        // Güncel fiyatları al (doğrudan DerinlikVerisiOku)
        decimal askA = 0, bidA = 0, askB = 0, bidB = 0;
        try {
            var depthA = Sistem.DerinlikVerisiOku("VIP'" + nearA);
            if (depthA != null && depthA.Length > 0) {
                askA = (decimal)depthA[0].SatisFiyat;
                bidA = (decimal)depthA[0].AlisFiyat;
            }
        } catch { }
        try {
            var depthB = Sistem.DerinlikVerisiOku("VIP'" + nearB);
            if (depthB != null && depthB.Length > 0) {
                askB = (decimal)depthB[0].SatisFiyat;
                bidB = (decimal)depthB[0].AlisFiyat;
            }
        } catch { }
        
        if (isLongA) {
            // A BUY (ask fiyatından) - A tavanda mı?
            if (askA > 0 && IsTavan(nearA, askA)) {
                Log("⚠️ PAIR LIMIT: " + symA + " TAVANDA - BUY yapılamaz");
                return true;
            }
            // B SELL (bid fiyatından) - B tabanda mı?
            if (bidB > 0 && IsTaban(nearB, bidB)) {
                Log("⚠️ PAIR LIMIT: " + symB + " TABANDA - SELL yapılamaz");
                return true;
            }
        } else {
            // A SELL (bid fiyatından) - A tabanda mı?
            if (bidA > 0 && IsTaban(nearA, bidA)) {
                Log("⚠️ PAIR LIMIT: " + symA + " TABANDA - SELL yapılamaz");
                return true;
            }
            // B BUY (ask fiyatından) - B tavanda mı?
            if (askB > 0 && IsTavan(nearB, askB)) {
                Log("⚠️ PAIR LIMIT: " + symB + " TAVANDA - BUY yapılamaz");
                return true;
            }
        }
        
        return false;
    } catch { return false; }
};

// Pair unrealized PnL hesapla
Func<string, decimal[], decimal> CalcPairUnrealizedPnl = (pairKey, pos) => {
    var parts = pairKey.Split('-');
    if (parts.Length != 2) return 0;
    
    var symA = parts[0];
    var symB = parts[1];
    var qtyA = (int)pos[0];
    var qtyB = (int)pos[1];
    var avgA = pos[2];
    var avgB = pos[3];
    var openZ = pos[4];
    
    // Güncel fiyatları al
    try {
        var yuzA = Sistem.YuzeyselVeriOku(SPOT_PREFIX + symA);
        var yuzB = Sistem.YuzeyselVeriOku(SPOT_PREFIX + symB);
        if (yuzA == null || yuzB == null) return 0;
        
        var priceA = (decimal)yuzA.LastPrice;
        var priceB = (decimal)yuzB.LastPrice;
        if (priceA <= 0 || priceB <= 0) return 0;
        
        var mult = GetMultiplier(symA);
        var isLongA = openZ < 0;
        
        decimal pnlA, pnlB;
        if (isLongA) {
            pnlA = (priceA - avgA) * qtyA * mult;
            pnlB = (avgB - priceB) * qtyB * mult;
        } else {
            pnlA = (avgA - priceA) * qtyA * mult;
            pnlB = (priceB - avgB) * qtyB * mult;
        }
        
        return pnlA + pnlB;
    } catch { return 0; }
};

// Z-Score hesapla (son 60 günlük veriden)
Func<System.Collections.Generic.List<decimal>, decimal> CalcZScore = (spreads) => {
    if (spreads == null || spreads.Count < 20) return 0;
    
    var n = Math.Min(60, spreads.Count);
    var startIdx = spreads.Count - n;
    
    decimal sum = 0;
    for (int i = startIdx; i < spreads.Count; i++) sum += spreads[i];
    var mean = sum / n;
    
    decimal sumSq = 0;
    for (int i = startIdx; i < spreads.Count; i++) {
        var diff = spreads[i] - mean;
        sumSq += diff * diff;
    }
    var std = (decimal)Math.Sqrt((double)(sumSq / n));
    
    if (std == 0) return 0;
    return (spreads[spreads.Count - 1] - mean) / std;
};

// Komisyon hesaplama
Func<string, decimal, int, decimal> CalcCommission = (sym, price, qty) => {
    var mult = GetMultiplier(sym);
    var value = price * qty * mult;
    var comm = value * (COMMISSION_RATE + TAKASBANK_RATE);
    return comm + comm * TAX_RATE;
};

Func<decimal, int, decimal> CalcSpotCommission = (price, qty) => {
    var value = price * qty;
    var comm = value * (COMMISSION_RATE + TAKASBANK_RATE);
    return comm + comm * TAX_RATE;
};

// Dinamik eşik
Func<int, decimal> SNThreshold = (daysN) => {
    var opp = RISK_FREE * daysN / 365m;
    return opp + SN_TOTAL_COST + SN_MIN_MARGIN;
};

// Sembol engelleme
Func<string, bool> IsBlocked = (sym) => {
    if (DateTime.Today > lastBlockReset) {
        blockedSymbols.Clear();
        lastBlockReset = DateTime.Today;
    }
    return blockedSymbols.ContainsKey(sym);
};

// Beklemede kalan emirler (nadir durum - izleme için)
var pendingOrders = new System.Collections.Generic.Dictionary<string, object[]>();  
// sym_side -> [0:side, 1:originalQty, 2:price, 3:time, 4:orderNo, 5:isSpot, 6:symbol, 7:orderDate, 8:orderType, 9:session, 10:status, 11:processedQty]

// En kötü pozisyonu bul
Func<string, System.Collections.Generic.HashSet<string>, System.Tuple<string, decimal>> FindWorstSNPosition = (excludeSym, excludeSet) => {
    string worstSym = null;
    decimal worstSpread = decimal.MaxValue;  // En düşük giriş spread'i = en kötü pozisyon
    foreach (var kv in snPos) {
        if (kv.Key == excludeSym) continue;
        if (excludeSet != null && excludeSet.Contains(kv.Key)) continue;
        // Pending order olan sembolleri atla
        if (pendingOrders.ContainsKey(kv.Key + "_BUY") || pendingOrders.ContainsKey(kv.Key + "_SELL")) continue;
        var entrySpread = kv.Value[4];  // Giriş spread'i (vade sonu garantili getiri)
        if (entrySpread < worstSpread) { worstSpread = entrySpread; worstSym = kv.Key; }
    }
    return System.Tuple.Create(worstSym, worstSpread);
};

// ====================================
// MERKEZİ DERİNLİK OKUMA FONKSİYONU
// ====================================
// Parametreler:
//   fullSym: Tam sembol (VIP'F_THYAO0126 veya IMKBH'THYAO gibi)
//   side: "BID" (satış için) veya "ASK" (alış için)
//   minQty: Minimum gereken miktar (0 ise sadece varlık kontrolü)
//   maxRetries: Derinlik 0 gelirse kaç kez tekrar denenecek (varsayılan 3)
//   retryDelayMs: Tekrar denemeler arası bekleme (varsayılan 100ms)
// Dönüş: Tuple<success, level1Size, level2Size, level1Price, level2Price, totalSize>
Func<string, string, int, int, int, System.Tuple<bool, int, int, decimal, decimal, int>> ReadDepth = 
    (fullSym, side, minQty, maxRetries, retryDelayMs) => {
    
    var level1Size = 0;
    var level2Size = 0;
    var level1Price = 0m;
    var level2Price = 0m;
    var totalSize = 0;
    var success = false;
    
    for (int attempt = 1; attempt <= maxRetries; attempt++) {
        try {
            dynamic depth = Sistem.DerinlikVerisiOku(fullSym);
            if (depth == null) {
                if (attempt < maxRetries) { System.Threading.Thread.Sleep(retryDelayMs); continue; }
                break;
            }
            
            var arr = (side == "BID") ? depth.Bids : depth.Asks;
            if (arr == null || arr.Count == 0) {
                if (attempt < maxRetries) { System.Threading.Thread.Sleep(retryDelayMs); continue; }
                break;
            }
            
            level1Size = (int)arr[0].Size;
            level1Price = (decimal)arr[0].Price;
            
            if (arr.Count > 1) {
                level2Size = (int)arr[1].Size;
                level2Price = (decimal)arr[1].Price;
            }
            
            totalSize = level1Size + level2Size;
            
            // 1. kademe > 0 ise başarılı
            if (level1Size > 0) {
                success = true;
                break;
            }
            
            // 1. kademe 0 - tekrar dene
            if (attempt < maxRetries) { 
                System.Threading.Thread.Sleep(retryDelayMs); 
            }
        } catch {
            if (attempt < maxRetries) { System.Threading.Thread.Sleep(retryDelayMs); }
        }
    }
    
    // 3+ deneme sonunda hala 0 ise log (tarama döngüsünde 1 deneme olduğu için log yok)
    if (!success && maxRetries > 1) {
        Log("❌ " + fullSym + " " + side + " derinlik yok (" + maxRetries + " deneme)");
    }
    
    // minQty kontrolü
    if (success && minQty > 0 && level1Size < minQty) {
        success = false;
    }
    
    return System.Tuple.Create(success, level1Size, level2Size, level1Price, level2Price, totalSize);
};

// Kısa kullanım için overload benzeri wrapper'lar
Func<string, string, int, System.Tuple<bool, int, int, decimal, decimal, int>> ReadDepthSimple = 
    (fullSym, side, minQty) => ReadDepth(fullSym, side, minQty, 3, 100);

Func<string, string, System.Tuple<bool, int, int, decimal, decimal, int>> ReadDepthBasic = 
    (fullSym, side) => ReadDepth(fullSym, side, 0, 3, 100);

// ====================================
// EMİR FONKSİYONLARI
// ====================================
// Son emir no takibi
var lastOrderNo = "";

Func<string, string, int, decimal, bool> SendGIE = (contract, side, qty, price) => {
    // Miktar kontrolü
    if (qty <= 0) {
        Log("⚠️ SendGIE: " + contract + " miktar 0, emir atlanıyor");
        return false;
    }
    
    try {
        // Göndermeden önce son OrderNo'yu kaydet
        try {
            var viopHesap = GetViopHesap();
            if (viopHesap != null && viopHesap.GerceklesenEmirler != null) {
                var emirList = viopHesap.GerceklesenEmirler;
                if (emirList.Count > 0) {
                    lastOrderNo = emirList[emirList.Count - 1].OrderNo ?? "";
                }
            }
        } catch { lastOrderNo = ""; }
        
        Sistem.EmirSembol = FUTURES_PREFIX + contract;
        Sistem.EmirIslem = side == "BUY" ? "ALIS" : "SATIS";
        Sistem.EmirMiktari = qty;
        Sistem.EmirSuresi = "GIE";
        Sistem.EmirTipi = "Limitli";
        Sistem.EmirFiyati = (double)price;
        Sistem.EmirGonder();
        return true;
    } catch { return false; }
};

Func<string, string, int, int> CheckFilledQty = (contract, side, qty) => {
    if (IS_TEST) return qty;  // Test modunda tam dolum
    
    var sym = FUTURES_PREFIX + contract;
    var yon = side == "BUY" ? "Alış" : "Satış";
    var now = DateTime.Now;
    
    for (int attempt = 1; attempt <= 2; attempt++) {
        try {
            RefreshHesaplar(true);  // Emir sonrası taze veri al
            var viopHesap = GetViopHesap();
            
            // Hesap null ise tekrar dene
            if (viopHesap == null) {
                Log("⚠️ CheckFilledQty: VIOP hesap null (deneme " + attempt + "/2)");
                continue;
            }
            
            // Hesap OK ama GerceklesenEmirler null/boş - gerçekleşmedi
            if (viopHesap.GerceklesenEmirler == null) {
                Log("⚠️ CheckFilledQty: GerceklesenEmirler null");
                return 0;
            }
            
            var emirList = viopHesap.GerceklesenEmirler;
            
            // Son 5 saniye içindeki emirleri kontrol et
            var totalFilled = 0;
            for (int i = emirList.Count - 1; i >= 0; i--) {  // Sondan başla (en yeni)
                var e = emirList[i];
                var eSymbol = e.Symbol ?? "";
                var eBuySell = e.BuySell ?? "";
                var eAmount = (int)e.GAmount;
                
                // Emir zamanını kontrol et (varsa)
                DateTime emirTime = now;
                try {
                    if (e.Time != null) emirTime = (DateTime)e.Time;
                } catch { }
                
                var secondsAgo = (now - emirTime).TotalSeconds;
                
                // 5 saniyeden eski emirleri atla (sondan başladığımız için döngüyü kır)
                if (secondsAgo > 10) break;  // 10 saniye tolerans
                
                // Sembol ve yön eşleşmesi
                if (eSymbol == sym && eBuySell == yon) {
                    totalFilled += eAmount;
                    Log("✓ Emir bulundu: " + eSymbol + " " + eBuySell + " x" + eAmount + " (" + secondsAgo.ToString("F1") + "sn önce)");
                }
            }
            
            if (totalFilled > 0) {
                Log("✅ CheckFilledQty: " + contract + " " + side + " toplam " + totalFilled + "/" + qty + " doldu");
            }
            
            // Beklenen miktardan fazla olamaz (eski emirler karışmasın)
            if (totalFilled > qty) totalFilled = qty;
            
            return totalFilled;
            
        } catch (Exception ex) { 
            Log("❌ CheckFilledQty hata: " + ex.Message);
        }
    }
    
    // 2 denemede de hesap null - güvenli tarafta kal
    return 0;
};

// Geriye uyumluluk için bool dönen wrapper
Func<string, string, int, bool> CheckFilled = (contract, side, qty) => {
    return CheckFilledQty(contract, side, qty) >= qty;
};

// Forward declarations (kullanımdan önce tanımlanmalı)
Action SavePositions = null;
Action SyncAndRecoverPositions = null;
Action<string, string, int, int> RecoverMissingLeg = null;
Action SaveDailyStats = null;
var inRecovery = false;  // Sonsuz döngü önleme flag'i

// Forward declaration for ExecGuar (CheckPendingOrders içinde kullanılacak)
Func<string, string, int, System.Tuple<int, decimal>> ExecGuar = null;

// Bekleyen emirleri kontrol et - gerçekleşti mi? Kısmi dolum da handle et
CheckPendingOrders = () => {
    if (pendingOrders.Count == 0) return;
    
    var toRemove = new System.Collections.Generic.List<string>();
    var toUpdate = new System.Collections.Generic.Dictionary<string, object[]>();
    
    foreach (var kv in pendingOrders) {
        try {
            var key = kv.Key;
            var data = kv.Value;
            var orderNo = (string)data[4];
            var isSpot = (bool)data[5];
            var entryTime = (DateTime)data[3];
            var originalQty = (int)data[1];
            var pendingPrice = (decimal)data[2];
            var side = (string)data[0];
            var fullSymbol = (string)data[6];
            var processedQty = data.Length > 11 ? (int)data[11] : 0;  // Daha önce işlenen miktar
            
            // Doğru hesabı kontrol et
            dynamic hesap = isSpot ? _bistHesap : _viopHesap;
            if (hesap == null) continue;
            
            // GerceklesenEmirler'de OrderNo ara
            var found = false;
            var totalFilledQty = 0;
            var filledPrice = 0m;
            
            try {
                var emirList = hesap.GerceklesenEmirler;
                if (emirList != null) {
                    for (int i = emirList.Count - 1; i >= 0 && i >= emirList.Count - 20; i--) {
                        var e = emirList[i];
                        if ((e.OrderNo ?? "") == orderNo) {
                            found = true;
                            totalFilledQty = (int)e.GAmount;  // API'den toplam dolmuş
                            filledPrice = (decimal)e.Price;
                            break;
                        }
                    }
                }
            } catch { }
            
            // Bu sefer yeni dolmuş miktar
            var newFilledQty = totalFilledQty - processedQty;
            
            if (found && newFilledQty > 0) {
                // Base sembolü çıkar (VIOP için)
                var baseSym = "";
                if (!isSpot) {
                    try {
                        var idx = fullSymbol.IndexOf("F_");
                        if (idx >= 0) {
                            baseSym = fullSymbol.Substring(idx + 2);
                            if (baseSym.Length > 4) baseSym = baseSym.Substring(0, baseSym.Length - 4);
                        }
                    } catch { }
                } else {
                    try {
                        var idx = fullSymbol.IndexOf("'");
                        if (idx >= 0) baseSym = fullSymbol.Substring(idx + 1);
                        else baseSym = fullSymbol;
                    } catch { baseSym = fullSymbol; }
                }
                
                var isComplete = totalFilledQty >= originalQty;
                
                Log("✅ BEKLEYEN EMİR " + (isComplete ? "TAM " : "KISMİ ") + "GERÇEKLEŞTİ: " + key + 
                    " OrderNo:" + orderNo + " Yeni:" + newFilledQty + " Toplam:" + totalFilledQty + "/" + originalQty + " @" + filledPrice.ToString("F2"));
                
                if (ExecGuar == null || string.IsNullOrEmpty(baseSym)) {
                    if (isComplete) toRemove.Add(key);
                    continue;
                }
                
                var mult = GetMultiplier(baseSym);
                
                // ========== NEAR BUY (Kapanış) - Karşılığı Spot SAT ==========
                if (!isSpot && side == "BUY") {
                    if (snPos.ContainsKey(baseSym)) {
                        var p = snPos[baseSym];
                        var spotToClose = (int)Math.Round((decimal)newFilledQty * mult);
                        var currentSpot = (int)p[0];
                        var currentNear = (int)p[1];
                        
                        if (spotToClose > currentSpot) spotToClose = currentSpot;
                        if (spotToClose > 0) {
                            Log("📊 PENDING NEAR BUY: " + baseSym + " Near:" + newFilledQty + " -> Spot:" + spotToClose + " satılıyor");
                            
                            var sr = ExecGuar(baseSym, "SELL", spotToClose);
                            if (sr.Item1 > 0) {
                                var spotPnl = (sr.Item2 - p[2]) * sr.Item1;
                                var nearPnl = (p[3] - filledPrice) * newFilledQty * mult;
                                var totalPnl = spotPnl + nearPnl;
                                var spotComm = CalcSpotCommission(sr.Item2, sr.Item1);
                                var nearComm = CalcCommission(baseSym, filledPrice, newFilledQty);
                                totalPnl -= (spotComm + nearComm);
                                
                                dailyRealizedPnl += totalPnl;
                                dailySpotCommission += spotComm;
                                dailyViopCommission += nearComm;
                                spotUsed -= sr.Item2 * sr.Item1;
                                if (spotUsed < 0) spotUsed = 0;
                                AdjustT2Balance(-(sr.Item2 * sr.Item1), spotComm);  // Satış
                                var viopTeminat = teminat.ContainsKey(baseSym) ? teminat[baseSym] * newFilledQty : 0;
                                viopUsed -= viopTeminat;
                                if (viopUsed < 0) viopUsed = 0;
                                AdjustViopBalance(-viopTeminat);  // Teminat serbest
                                
                                Log("💰 PENDING P&L: Spot:" + spotPnl.ToString("F0") + " Near:" + nearPnl.ToString("F0") + " Toplam:" + totalPnl.ToString("F0") + " TL");
                                
                                var remainSpot = currentSpot - sr.Item1;
                                var remainNear = currentNear - newFilledQty;
                                
                                if (remainSpot <= 0 && remainNear <= 0) {
                                    snPos.Remove(baseSym);
                                    totalClosedSN++;
                                    Log("✅ PENDING KAPANIŞ TAMAMLANDI: " + baseSym);
                                } else {
                                    var expPnlRatio = currentNear > 0 ? p[5] * remainNear / currentNear : 0;
                                    snPos[baseSym] = new decimal[] { remainSpot, remainNear, p[2], p[3], p[4], expPnlRatio, p[6], p[7] };
                                    Log("📊 PENDING GÜNCELLEME: " + baseSym + " Kalan S:" + remainSpot + " N:" + remainNear);
                                }
                                SavePositions();
                                if (SaveDailyStats != null) SaveDailyStats();
                            }
                        }
                    }
                    else if (orphanLegs.ContainsKey(baseSym)) {
                        // snPos'ta yok ama orphanLegs'te var - Near geri alımı tamamlandı
                        var orph = orphanLegs[baseSym];
                        if ((string)orph[0] == "NEAR" && (string)orph[2] == "SELL") {
                            var orphQty = (int)orph[3];
                            var orphPrice = (decimal)orph[4];
                            
                            // P&L hesapla: Near SELL @orphPrice, Near BUY @filledPrice
                            var nearPnl = (orphPrice - filledPrice) * newFilledQty * mult;
                            var nearComm = CalcCommission(baseSym, filledPrice, newFilledQty);
                            var totalPnl = nearPnl - nearComm;
                            
                            dailyRealizedPnl += totalPnl;
                            dailyViopCommission += nearComm;
                            
                            Log("💰 ORPHAN NEAR GERİ ALIM: " + baseSym + " @" + filledPrice.ToString("F2") + 
                                " (Açılış:" + orphPrice.ToString("F2") + ") P&L:" + totalPnl.ToString("F0") + " TL");
                            
                            // Miktarı kontrol et
                            if (newFilledQty >= orphQty) {
                                orphanLegs.Remove(baseSym);
                                Log("🗑️ ORPHAN: " + baseSym + " orphanLegs'ten silindi (tam geri alım)");
                            } else {
                                // Kısmi geri alım
                                orph[3] = orphQty - newFilledQty;
                                orphanLegs[baseSym] = orph;
                                Log("📊 ORPHAN: " + baseSym + " kalan miktar: " + (orphQty - newFilledQty));
                            }
                            SavePositions();
                            if (SaveDailyStats != null) SaveDailyStats();
                        }
                    }
                }
                // ========== NEAR SELL (Açılış) - Karşılığı Spot BUY ==========
                else if (!isSpot && side == "SELL") {
                    var spotToBuy = (int)Math.Round((decimal)newFilledQty * mult);
                    if (spotToBuy > 0) {
                        // AÇILIŞ VOLATİLİTESİ KORUMASI: 10:05'e kadar Spot açmayı beklet
                        // Piyasa kapalıyken veya açılış volatilitesinde yanlış fiyattan işlem önlenir
                        var recoveryNow = DateTime.Now;
                        var recoveryMinutes = recoveryNow.Hour * 60 + recoveryNow.Minute;
                        var recoveryStartMinutes = MARKET_OPEN_HOUR * 60 + MARKET_OPEN_MINUTE + 5;  // 10:05
                        
                        if (recoveryMinutes < recoveryStartMinutes) {
                            // 10:05'ten önce - orphanLegs'e kaydet ve bekle
                            if (!orphanLegs.ContainsKey(baseSym)) {
                                orphanLegs[baseSym] = new object[] {
                                    "NEAR", fullSymbol, "SELL", newFilledQty, filledPrice,
                                    "SPOT", baseSym, "BUY", spotToBuy, DateTime.Now.Ticks
                                };
                                Log("⏳ AÇILIŞ BEKLETMESİ: " + baseSym + " Near SELL x" + newFilledQty + " @" + filledPrice.ToString("F2") + 
                                    " - Spot BUY 10:05'te yapılacak");
                                SavePositions();
                            }
                            // Pending order'ı işlenmiş say ama silme (orphan'dan devam edecek)
                            data[11] = totalFilledQty;
                            toUpdate[key] = data;
                            continue;
                        }
                        
                        Log("📊 PENDING NEAR SELL: " + baseSym + " Near:" + newFilledQty + " -> Spot:" + spotToBuy + " alınıyor");
                        
                        var sr = ExecGuar(baseSym, "BUY", spotToBuy);
                        if (sr.Item1 > 0) {
                            var spotFilledQty = sr.Item1;
                            var spotAvgP = sr.Item2;
                            
                            if (snPos.ContainsKey(baseSym)) {
                                var p = snPos[baseSym];
                                var oldSQty = (int)p[0];
                                var oldNQty = (int)p[1];
                                var newSQty = oldSQty + spotFilledQty;
                                var newNQty = oldNQty + newFilledQty;
                                if (newSQty <= 0 || newNQty <= 0) {
                                    Log("❌ PENDING: Yeni miktar sıfır, güncelleme atlanıyor");
                                    continue;
                                }
                                var avgSpot = (p[2] * oldSQty + spotAvgP * spotFilledQty) / newSQty;
                                var avgNear = (p[3] * oldNQty + filledPrice * newFilledQty) / newNQty;
                                if (avgSpot <= 0) {
                                    Log("❌ PENDING: avgSpot sıfır, güncelleme atlanıyor");
                                    continue;
                                }
                                var newSpread = (avgNear - avgSpot) / avgSpot;
                                var newExpectedPnl = newSpread * avgSpot * newSQty;
                                
                                snPos[baseSym] = new decimal[] { newSQty, newNQty, avgSpot, avgNear, p[4], newExpectedPnl, p[6], p[7] };
                                Log("📊 PENDING AÇILIŞ EKLENDİ: " + baseSym + " S:" + oldSQty + "→" + newSQty + " N:" + oldNQty + "→" + newNQty);
                            } else {
                                if (spotAvgP <= 0) {
                                    Log("❌ PENDING: spotAvgP sıfır, yeni pozisyon atlanıyor");
                                    continue;
                                }
                                var openSpread = (filledPrice - spotAvgP) / spotAvgP;
                                var expectedPnl = openSpread * spotAvgP * spotFilledQty;
                                snPos[baseSym] = new decimal[] { spotFilledQty, newFilledQty, spotAvgP, filledPrice, openSpread, expectedPnl, 0, DateTime.Now.Ticks };
                                Log("📊 PENDING YENİ POZİSYON: " + baseSym + " S:" + spotFilledQty + " N:" + newFilledQty);
                            }
                            
                            var spotComm = CalcSpotCommission(spotAvgP, spotFilledQty);
                            var nearComm = CalcCommission(baseSym, filledPrice, newFilledQty);
                            dailySpotCommission += spotComm;
                            dailyViopCommission += nearComm;
                            spotUsed += spotAvgP * spotFilledQty;
                            AdjustT2Balance(spotAvgP * spotFilledQty, spotComm);  // Alış
                            var viopTeminat = teminat.ContainsKey(baseSym) ? teminat[baseSym] * newFilledQty : 0;
                            viopUsed += viopTeminat;
                            AdjustViopBalance(viopTeminat);  // Teminat kullanıldı
                            
                            SavePositions();
                            if (SaveDailyStats != null) SaveDailyStats();
                        }
                    }
                }
                // ========== SPOT BUY (Açılış) - Pozisyona ekle ==========
                else if (isSpot && side == "BUY") {
                    if (snPos.ContainsKey(baseSym)) {
                        var p = snPos[baseSym];
                        var oldSQty = (int)p[0];
                        var newSQty = oldSQty + newFilledQty;
                        if (newSQty <= 0) {
                            Log("❌ PENDING SPOT BUY: newSQty sıfır");
                            continue;
                        }
                        var avgSpot = (p[2] * oldSQty + filledPrice * newFilledQty) / newSQty;
                        if (avgSpot <= 0) {
                            Log("❌ PENDING SPOT BUY: avgSpot sıfır");
                            continue;
                        }
                        var newSpread = (p[3] - avgSpot) / avgSpot;
                        var newExpectedPnl = newSpread * avgSpot * newSQty;
                        
                        snPos[baseSym] = new decimal[] { newSQty, p[1], avgSpot, p[3], p[4], newExpectedPnl, p[6], p[7] };
                        Log("📊 PENDING SPOT BUY EKLENDİ: " + baseSym + " S:" + oldSQty + "→" + newSQty);
                        
                        var spotComm = CalcSpotCommission(filledPrice, newFilledQty);
                        dailySpotCommission += spotComm;
                        spotUsed += filledPrice * newFilledQty;
                        AdjustT2Balance(filledPrice * newFilledQty, spotComm);  // Alış
                        
                        SavePositions();
                    }
                }
                // ========== SPOT SELL (Kapanış) - Pozisyondan düş ==========
                else if (isSpot && side == "SELL") {
                    if (snPos.ContainsKey(baseSym)) {
                        var p = snPos[baseSym];
                        var currentSpot = (int)p[0];
                        var currentNear = (int)p[1];
                        
                        var spotPnl = (filledPrice - p[2]) * newFilledQty;
                        var spotComm = CalcSpotCommission(filledPrice, newFilledQty);
                        spotPnl -= spotComm;
                        dailyRealizedPnl += spotPnl;
                        dailySpotCommission += spotComm;
                        spotUsed -= filledPrice * newFilledQty;
                        if (spotUsed < 0) spotUsed = 0;
                        AdjustT2Balance(-(filledPrice * newFilledQty), spotComm);  // Satış
                        
                        var remainSpot = currentSpot - newFilledQty;
                        if (remainSpot <= 0 && currentNear <= 0) {
                            snPos.Remove(baseSym);
                            Log("✅ PENDING SPOT SELL KAPANIŞ: " + baseSym);
                        } else {
                            var expPnlRatio = currentSpot > 0 ? p[5] * remainSpot / currentSpot : 0;
                            snPos[baseSym] = new decimal[] { remainSpot, currentNear, p[2], p[3], p[4], expPnlRatio, p[6], p[7] };
                            Log("📊 PENDING SPOT SELL: " + baseSym + " S:" + currentSpot + "→" + remainSpot);
                        }
                        
                        SavePositions();
                        if (SaveDailyStats != null) SaveDailyStats();
                    }
                }
                
                // Tam dolduysa sil, kısmi dolduysa processedQty güncelle
                if (isComplete) {
                    toRemove.Add(key);
                } else {
                    // processedQty'yi güncelle (11. index)
                    if (data.Length > 11) {
                        data[11] = totalFilledQty;
                    } else {
                        var newData = new object[12];
                        for (int i = 0; i < data.Length; i++) newData[i] = data[i];
                        newData[11] = totalFilledQty;
                        data = newData;
                    }
                    toUpdate[key] = data;
                    Log("📊 PENDING processedQty GÜNCELLEME: " + key + " İşlenen:" + totalFilledQty + "/" + originalQty);
                }
            } else if (!found || newFilledQty == 0) {
                // Hala bekliyor veya değişiklik yok - ne kadar süredir?
                var waitTime = (DateTime.Now - entryTime).TotalMinutes;
                if (waitTime > 5 && newFilledQty == 0) {
                    Log("⚠️ BEKLEYEN EMİR " + waitTime.ToString("F0") + " dk'dır bekliyor: " + key + " OrderNo:" + orderNo);
                }
                
                // Manuel iptal kontrolü: BekleyenEmirler'de de yoksa silinmiş demektir
                var stillPending = false;
                try {
                    var bekleyenList = hesap.BekleyenEmirler;
                    if (bekleyenList != null) {
                        for (int i = 0; i < bekleyenList.Count; i++) {
                            if ((bekleyenList[i].OrderNo ?? "") == orderNo) {
                                stillPending = true;
                                break;
                            }
                        }
                    }
                } catch { stillPending = true; }  // Hata durumunda silme
                
                // BekleyenEmirler'de yok VE GerceklesenEmirler'de de yok → Manuel iptal edilmiş
                if (!stillPending && !found && waitTime > 1) {
                    Log("🗑️ BEKLEYEN EMİR MANUEL İPTAL EDİLMİŞ: " + key + " OrderNo:" + orderNo);
                    toRemove.Add(key);
                    
                    // orphanLegs'te bu sembol varsa onu da temizle
                    var baseSym2 = "";
                    if (!isSpot) {
                        try {
                            var idx = fullSymbol.IndexOf("F_");
                            if (idx >= 0) {
                                baseSym2 = fullSymbol.Substring(idx + 2);
                                if (baseSym2.Length > 4) baseSym2 = baseSym2.Substring(0, baseSym2.Length - 4);
                            }
                        } catch { }
                    }
                    // Not: orphanLegs'i burada silmiyoruz çünkü manuel iptal = pozisyon hala açık
                    // Recovery'nin halletmesine bırakıyoruz
                }
            }
        } catch { }
    }
    
    // Tam gerçekleşenleri sil ve bütçeyi geri ver
    foreach (var key in toRemove) {
        try {
            var data = pendingOrders[key];
            var orderQty = (int)data[1];
            var pendingPrice = (decimal)data[2];
            var isSpot = (bool)data[5];
            var fullSymbol = (string)data[6];
            
            // Ayrılan bütçeyi geri ver
            var pendingValue = pendingPrice * orderQty;
            if (isSpot) {
                spotUsed -= pendingValue;
                if (spotUsed < 0) spotUsed = 0;
                spotBudgetTotal = spotUsed + t2Balance;
                Log("💰 Pending SPOT bütçe serbest: " + pendingValue.ToString("N0"));
            } else {
                // Near için teminat serbest bırak
                var baseSym = "";
                try {
                    var idx = fullSymbol.IndexOf("F_");
                    if (idx >= 0) {
                        baseSym = fullSymbol.Substring(idx + 2);
                        if (baseSym.Length > 4) baseSym = baseSym.Substring(0, baseSym.Length - 4);
                    }
                } catch { }
                if (!string.IsNullOrEmpty(baseSym) && teminat.ContainsKey(baseSym)) {
                    var pendingTeminat = teminat[baseSym] * orderQty;
                    viopUsed -= pendingTeminat;
                    if (viopUsed < 0) viopUsed = 0;
                    Log("💰 Pending VIOP teminat serbest: " + pendingTeminat.ToString("N0"));
                }
            }
        } catch { }
        pendingOrders.Remove(key);
    }
    
    // processedQty güncellemelerini uygula
    foreach (var kv in toUpdate) {
        pendingOrders[kv.Key] = kv.Value;
    }
};

ExecGuar = (sym, side, qty) => {
    // Miktar kontrolü
    if (qty <= 0) {
        Log("⚠️ ExecGuar: " + sym + " miktar 0, emir atlanıyor");
        return System.Tuple.Create(0, 0m);
    }
    
    var buy = side == "BUY";
    var spot = !sym.StartsWith("F_");
    var full = spot ? SPOT_PREFIX + sym : FUTURES_PREFIX + sym;
    
    // Derinlikten fiyat al
    var limitPrice = Depth2x(full, buy, qty);
    var avgPrice = DepthAvgPrice(full, buy, qty);
    if (avgPrice <= 0) avgPrice = limitPrice;
    
    // Derinlik yoksa başarısız
    if (limitPrice <= 0 || avgPrice <= 0) {
        Log("❌ " + side + " " + sym + " derinlik yok");
        return System.Tuple.Create(0, 0m);
    }
    
    Log("📤 LMT: " + side + " " + sym + " x" + qty + " @" + limitPrice.ToString("F2"));
    
    // Emir gönder (KIE - Kalanı İptal Et)
    Sistem.EmirSembol = full;
    Sistem.EmirIslem = buy ? "ALIS" : "SATIS";
    Sistem.EmirMiktari = qty;
    Sistem.EmirSuresi = "KIE";
    Sistem.EmirTipi = spot ? "Limit" : "Limitli";
    Sistem.EmirFiyati = (double)limitPrice;
    Sistem.EmirGonder();
    
    // Test modu: Teyit beklemeden ortalama fiyatla doldu say
    if (IS_TEST) {
        return System.Tuple.Create(qty, avgPrice);
    }
    
    // Gerçek mod: 2 deneme teyit
    var yon = buy ? "Alış" : "Satış";
    
    for (int attempt = 1; attempt <= 2; attempt++) {
        RefreshHesaplar(true);  // 2sn bekle + taze veri
        
        dynamic hesap = spot ? GetBistHesap() : GetViopHesap();
        
        // Hesap null ise tekrar dene
        if (hesap == null) {
            Log("⚠️ " + side + " " + sym + " hesap null (deneme " + attempt + "/2)");
            continue;
        }
        
        // Gerçekleşen emirleri kontrol et (son 5 emir)
        try {
            var emirList = hesap.GerceklesenEmirler;
            if (emirList != null) {
                for (int i = emirList.Count - 1; i >= 0 && i >= emirList.Count - 5; i--) {
                    var e = emirList[i];
                    var eSym = e.Symbol ?? "";
                    var eYon = e.BuySell ?? "";
                    if ((spot && eSym.Contains(sym) && eYon == yon) || 
                        (!spot && eSym == full && eYon == yon)) {
                        var filledQty = (int)e.GAmount;
                        var filledPrice = (decimal)e.Price;
                        if (filledQty > 0) {
                            Log("✓ " + side + " " + sym + " teyit: " + filledQty + "@" + filledPrice.ToString("F2"));
                            return System.Tuple.Create(filledQty, filledPrice);
                        }
                    }
                }
            }
        } catch { }
        
        // Bekleyen emirleri kontrol et (KIE dolmamış mı?)
        try {
            var bekleyenList = hesap.BekleyenEmirler;
            if (bekleyenList != null) {
                for (int i = 0; i < bekleyenList.Count; i++) {
                    var e = bekleyenList[i];
                    var eSym = e.Symbol ?? "";
                    var eYon = e.BuySell ?? "";
                    if ((spot && eSym.Contains(sym) && eYon == yon) || 
                        (!spot && eSym == full && eYon == yon)) {
                        // Beklemede kaldı - izlemeye al
                        var orderNo = e.OrderNo ?? "";
                        var orderDate = e.OrderDate ?? "";
                        var orderType = e.OrderType ?? "";
                        var session = e.Session ?? "";
                        var status = e.Status ?? "";
                        var orderQty = (int)e.Amount;
                        var orderPrice = (decimal)e.Price;
                        Log("⚠️ " + side + " " + sym + " BEKLEMEDE KALDI!");
                        Log("   OrderNo:" + orderNo + " Date:" + orderDate + " Status:" + status);
                        Log("   Qty:" + orderQty + " @" + orderPrice.ToString("F2") + " Type:" + orderType + " Session:" + session);
                        pendingOrders[sym + "_" + side] = new object[] { 
                            side, orderQty, orderPrice, DateTime.Now, 
                            orderNo, spot, eSym, orderDate, orderType, session, status, 0  // 11:processedQty=0
                        };
                        
                        // Pending order için bütçe ayır
                        var pendingValue = orderPrice * orderQty;
                        if (spot) {
                            spotUsed += pendingValue;
                            spotBudgetTotal = spotUsed + t2Balance;
                            Log("💰 Pending SPOT bütçe ayrıldı: " + pendingValue.ToString("N0"));
                        } else {
                            // Near için teminat ayır
                            var baseSym = sym.Replace("F_", "").Substring(0, sym.Length - 5);  // F_THYAO0126 -> THYAO
                            if (teminat.ContainsKey(baseSym)) {
                                var pendingTeminat = teminat[baseSym] * orderQty;
                                viopUsed += pendingTeminat;
                                Log("💰 Pending VIOP teminat ayrıldı: " + pendingTeminat.ToString("N0"));
                            }
                        }
                        
                        return System.Tuple.Create(0, 0m);  // Dolmadı say
                    }
                }
            }
        } catch { }
        
        if (attempt == 1) {
            Log("⏳ " + side + " " + sym + " teyit bulunamadı, tekrar deneniyor...");
        }
    }
    
    // 2 denemede de teyit alınamadı
    Log("❌ " + side + " " + sym + " teyit alınamadı, dolmadı sayılıyor");
    return System.Tuple.Create(0, 0m);
};

// ====================================
// SPOT-NEAR AÇILIŞ (Kontrollü GİE)
// ====================================
Func<string, string, int, int, decimal, int, bool> OpenSN = (sym, nearC, sQty, nQty, minSp, bb93Flag) => {
    try {
        // Pair Trading için yasaklı sembol kontrolü
        if (PAIR_BLOCKED.Contains(sym)) {
            return false;  // Sessizce atla (normal durum)
        }
        
        // Miktar kontrolü
        if (nQty <= 0 || sQty <= 0) {
            Log("⚠️ OpenSN: " + sym + " miktar 0, açılış atlanıyor (S:" + sQty + " N:" + nQty + ")");
            return false;
        }
        
        // Pending order kontrolü
        if (pendingOrders.ContainsKey(sym + "_BUY") || pendingOrders.ContainsKey(sym + "_SELL")) {
            Log("⛔ SN AÇILIŞ: " + sym + " pending order var, açılmıyor");
            return false;
        }
        
        var nearS = FUTURES_PREFIX + nearC;
        var spotS = SPOT_PREFIX + sym;
        Log("📊 SN AÇILIŞ: " + sym + " S:" + sQty + " N:" + nQty);
        
        // === KONTROLLÜ GİE: 3 deneme ===
        decimal nearP = 0;
        var filled = false;
        
        for (int attempt = 1; attempt <= 3; attempt++) {
            // 1. Near Bid derinlik kontrolü (Near satıyoruz)
            var nearDepthResult = ReadDepth(nearS, "BID", 0, 3, 100);
            if (!nearDepthResult.Item1) {
                Log("❌ Near Bids boş (deneme " + attempt + ")");
                if (attempt == 3) return false;
                System.Threading.Thread.Sleep(200);
                continue;
            }
            
            var nearBid1Size = nearDepthResult.Item2;
            var nearBid2Size = nearDepthResult.Item3;
            var nearBid1Price = nearDepthResult.Item4;
            var nearBid2Price = nearDepthResult.Item5;
            var nearTotalSize = GIE_DEPTH_LEVELS >= 2 ? nearDepthResult.Item6 : nearBid1Size;
            
            // Derinlik yeterli mi?
            if (GIE_DEPTH_LEVELS == 1) {
                if (nearBid1Size < nQty) {
                    Log("❌ Near 1.kademe yetersiz: " + nearBid1Size + " < " + nQty + " (deneme " + attempt + ")");
                    if (attempt == 3) return false;
                    System.Threading.Thread.Sleep(200);
                    continue;
                }
            } else {
                if (nearTotalSize < nQty) {
                    Log("❌ Near 1+2.kademe yetersiz: " + nearTotalSize + " < " + nQty + " (deneme " + attempt + ")");
                    if (attempt == 3) return false;
                    System.Threading.Thread.Sleep(200);
                    continue;
                }
            }
            
            // 2. Spot Ask derinlik kontrolü (Spot alıyoruz)
            var spotDepthResult = ReadDepth(spotS, "ASK", 0, 3, 100);
            if (!spotDepthResult.Item1 || spotDepthResult.Item4 <= 0) {
                Log("❌ Spot derinlik yok (deneme " + attempt + ")");
                if (attempt == 3) return false;
                System.Threading.Thread.Sleep(200);
                continue;
            }
            
            var spotAsk1Price = spotDepthResult.Item4;
            var spotAsk1Size = spotDepthResult.Item2;
            
            // 3. GIE fiyatı ve spread kontrolü
            var giePrice = nearBid1Price;
            if (GIE_DEPTH_LEVELS >= 2 && nearBid1Size < nQty && nearBid2Price > 0) {
                giePrice = nearBid2Price;  // 2. kademeye gönder
            }
            
            // Spread kontrolü (GIE fiyatı üzerinden)
            var sp = (giePrice - spotAsk1Price) / spotAsk1Price;
            if (sp < minSp * 0.95m) {
                Log("❌ Spread düştü: " + (sp * 100).ToString("F3") + "% < " + (minSp * 0.95m * 100).ToString("F3") + "% (deneme " + attempt + ")");
                if (attempt == 3) return false;
                System.Threading.Thread.Sleep(200);
                continue;
            }
            
            // 4. Spot derinlik yeterliliği kontrolü (10 kademe toplam)
            dynamic spotDepthFull = Sistem.DerinlikVerisiOku(spotS);
            var cumQty = 0;
            if (spotDepthFull != null && spotDepthFull.Asks != null) {
                for (int i = 0; i < spotDepthFull.Asks.Count && i < 10; i++) {
                    cumQty += (int)spotDepthFull.Asks[i].Size;
                }
            }
            if (cumQty < sQty) {
                Log("❌ Spot derinlik yetersiz: " + cumQty + " < " + sQty + " (deneme " + attempt + ")");
                if (attempt == 3) return false;
                System.Threading.Thread.Sleep(200);
                continue;
            }
            
            // 5. Her şey uygun - Near GİE gönder
            nearP = giePrice;
            var gieInfo = (GIE_DEPTH_LEVELS >= 2 && giePrice < nearBid1Price) ? " [2.KDM]" : "";
            Log("📤 Near GİE: " + nearC + " SELL x" + nQty + " @" + nearP.ToString("F2") + gieInfo);
            SendGIE(nearC, "SELL", nQty, nearP);
            System.Threading.Thread.Sleep(GIE_WAIT_MS);
            
            // 6. Doldu mu kontrol et
            if (IS_TEST || CheckFilled(nearC, "SELL", nQty)) {
                filled = true;
                Log("✓ Near GİE doldu (deneme " + attempt + ")");
                break;
            }
            
            Log("⏳ Near dolmadı (deneme " + attempt + "/3)");
        }
        
        if (!filled) {
            Log("❌ Near 3 denemede dolmadı");
            return false;
        }
        
        // === Near doldu, şimdi Spot al (garantili) ===
        dynamic finalSpotDepth = Sistem.DerinlikVerisiOku(spotS);
        if (finalSpotDepth == null || finalSpotDepth.Asks == null || finalSpotDepth.Asks.Count == 0) {
            Log("❌ Spot derinlik kayboldu - Near geri alınıyor");
            // Yetim bacak kaydet (Near satıldı, Spot alınamadı)
            orphanLegs[sym] = new object[] {
                "NEAR", nearC, "SELL", nQty, nearP,  // Dolan bacak
                "SPOT", sym, "BUY", sQty, DateTime.Now.Ticks  // Hedef bacak
            };
            SavePositions();
            Log("📝 Yetim bacak kaydedildi: " + sym + " NEAR SELL x" + nQty + " @" + nearP.ToString("F2"));
            if (!IS_TEST) ExecGuar(nearC, "BUY", nQty);
            return false;
        }
        
        // Limit fiyat hesapla (2x derinlik)
        var targetQty = sQty * 2;
        var cumQtyFinal = 0;
        decimal limitPrice = 0;
        decimal avgTotal = 0;
        var avgQty = 0;
        
        for (int i = 0; i < finalSpotDepth.Asks.Count && i < 10; i++) {
            var kademeFiyat = (decimal)finalSpotDepth.Asks[i].Price;
            var kademeMiktar = (int)finalSpotDepth.Asks[i].Size;
            cumQtyFinal += kademeMiktar;
            if (avgQty < sQty) {
                var alQty = Math.Min(kademeMiktar, sQty - avgQty);
                avgTotal += kademeFiyat * alQty;
                avgQty += alQty;
            }
            if (cumQtyFinal >= targetQty && limitPrice == 0) limitPrice = kademeFiyat;
        }
        if (limitPrice == 0 && finalSpotDepth.Asks.Count > 0) {
            limitPrice = (decimal)finalSpotDepth.Asks[finalSpotDepth.Asks.Count - 1].Price;
        }
        
        if (cumQtyFinal < sQty) {
            Log("❌ Spot derinlik yetersiz - Near geri alınıyor");
            // Yetim bacak kaydet (Near satıldı, Spot alınamadı)
            orphanLegs[sym] = new object[] {
                "NEAR", nearC, "SELL", nQty, nearP,  // Dolan bacak
                "SPOT", sym, "BUY", sQty, DateTime.Now.Ticks  // Hedef bacak
            };
            SavePositions();
            Log("📝 Yetim bacak kaydedildi: " + sym + " NEAR SELL x" + nQty + " @" + nearP.ToString("F2"));
            if (!IS_TEST) ExecGuar(nearC, "BUY", nQty);
            return false;
        }
        
        // Spot emir (garantili yöntem)
        var spotResult = ExecGuar(sym, "BUY", sQty);
        if (spotResult.Item1 == 0) {
            Log("❌ Spot alınamadı - Near geri alınıyor");
            // Yetim bacak kaydet (Near satıldı, Spot alınamadı)
            orphanLegs[sym] = new object[] {
                "NEAR", nearC, "SELL", nQty, nearP,  // Dolan bacak
                "SPOT", sym, "BUY", sQty, DateTime.Now.Ticks  // Hedef bacak
            };
            SavePositions();
            Log("📝 Yetim bacak kaydedildi: " + sym + " NEAR SELL x" + nQty + " @" + nearP.ToString("F2"));
            if (!IS_TEST) ExecGuar(nearC, "BUY", nQty);
            return false;
        }
        
        decimal spotAvgP = spotResult.Item2;
        int spotFilledQty = spotResult.Item1;
        
        // Spot kısmi dolduysa, fazla Near'ı geri al
        var mult = GetMultiplier(sym);
        var neededNear = (int)Math.Ceiling((decimal)spotFilledQty / mult);  // Spot'a karşılık gelen Near
        var excessNear = nQty - neededNear;
        
        if (excessNear > 0 && spotFilledQty < sQty) {
            Log("⚠️ Spot kısmi doldu: " + spotFilledQty + "/" + sQty + " - Fazla Near geri alınıyor: " + excessNear);
            if (!IS_TEST) ExecGuar(nearC, "BUY", excessNear);
            nQty = neededNear;  // Kalan Near miktarı
        }
        
        // Pozisyon kaydet
        if (spotAvgP <= 0) {
            Log("❌ Spot ortalama fiyat sıfır, pozisyon kaydedilemiyor");
            return true;  // Near zaten açıldı, spot da doldu ama fiyat sıfır - anormal durum
        }
        var openSpread = (nearP - spotAvgP) / spotAvgP;
        var expectedPnl = openSpread * spotAvgP * spotFilledQty;
        var spotComm = CalcSpotCommission(spotAvgP, spotFilledQty);
        var nearComm = CalcCommission(sym, nearP, nQty);
        var totalComm = spotComm + nearComm;
        expectedPnl -= totalComm * 2;
        
        snPos[sym] = new decimal[] { spotFilledQty, nQty, spotAvgP, nearP, openSpread, expectedPnl, bb93Flag, DateTime.Now.Ticks };
        dailySpotCommission += spotComm;
        dailyViopCommission += nearComm;
        spotUsed += spotAvgP * spotFilledQty;
        AdjustT2Balance(spotAvgP * spotFilledQty, spotComm);  // Alış: T+2 azalır
        var viopTeminat = teminat.ContainsKey(sym) ? teminat[sym] * nQty : 0;
        viopUsed += viopTeminat;
        AdjustViopBalance(viopTeminat);  // Teminat kullanıldı
        
        // IdealData pozisyon listesine ekle
        try {
            Sistem.PozisyonKontrolGuncelle(ROBOT_NAME + "_SPOT," + sym, spotFilledQty, (double)spotAvgP, "SPOT");
            Sistem.PozisyonKontrolGuncelle(ROBOT_NAME + "_NEAR," + nearC, nQty, (double)nearP, "NEAR");
        } catch { }
        
        Log("✅ SN AÇILDI: " + sym + " S:" + spotFilledQty + "@" + spotAvgP.ToString("F2") + 
            " N:" + nQty + "@" + nearP.ToString("F2") + " Spread:" + (openSpread * 100).ToString("F3") + "%");
        SavePositions();
        return true;
    } catch (Exception ex) {
        Log("❌ SN AÇILIŞ HATA: " + sym + " - " + ex.Message);
        return false;
    }
};
// ====================================
// SPOT-NEAR BÜYÜTME (Kontrollü GİE)
// ====================================
Func<string, string, int, int, decimal, bool> AddToSN = (sym, nearC, addSQty, addNQty, minSp) => {
    if (!snPos.ContainsKey(sym)) return false;
    
    // Miktar kontrolü
    if (addNQty <= 0 || addSQty <= 0) {
        Log("⚠️ AddToSN: " + sym + " miktar 0, büyütme atlanıyor (S:" + addSQty + " N:" + addNQty + ")");
        return false;
    }
    
    // Pending order kontrolü
    if (pendingOrders.ContainsKey(sym + "_BUY") || pendingOrders.ContainsKey(sym + "_SELL")) {
        Log("⛔ SN BÜYÜTME: " + sym + " pending order var, büyütülmüyor");
        return false;
    }
    
    var p = snPos[sym];
    var currentAddCount = (int)p[6];
    if (currentAddCount >= 2) {
        Log("⛔ SN " + sym + " max ekleme (2) ulaşıldı");
        return false;
    }
    
    var nearS = FUTURES_PREFIX + nearC;
    var spotS = SPOT_PREFIX + sym;
    Log("📊 SN BÜYÜTME: " + sym + " +" + addSQty + "/" + addNQty + " (ekleme:" + (currentAddCount+1) + "/2)");
    
    // === KONTROLLÜ GİE: 3 deneme ===
    decimal nearP = 0;
    var filled = false;
    
    for (int attempt = 1; attempt <= 3; attempt++) {
        // 1. Near Bid derinlik kontrolü (Near satıyoruz)
        var nearBidResult = ReadDepth(nearS, "BID", 0, 3, 100);
        if (!nearBidResult.Item1) {
            if (attempt == 3) return false;
            System.Threading.Thread.Sleep(200);
            continue;
        }
        
        var nearBid1Size = nearBidResult.Item2;
        var nearBid2Size = nearBidResult.Item3;
        var nearBid1Price = nearBidResult.Item4;
        var nearBid2Price = nearBidResult.Item5;
        var nearTotalSize = GIE_DEPTH_LEVELS >= 2 ? nearBidResult.Item6 : nearBid1Size;
        
        // Derinlik yeterli mi?
        if (GIE_DEPTH_LEVELS == 1) {
            if (nearBid1Size < addNQty) {
                if (attempt == 3) return false;
                System.Threading.Thread.Sleep(200);
                continue;
            }
        } else {
            if (nearTotalSize < addNQty) {
                if (attempt == 3) return false;
                System.Threading.Thread.Sleep(200);
                continue;
            }
        }
        
        // Near Ask derinlik kontrolü (kapanışta sorun yaşamamak için)
        var currentNQty = (int)p[1];
        var totalNQtyAfterAdd = currentNQty + addNQty;
        var minAskDepthRequired = totalNQtyAfterAdd * 5;
        
        // Near Ask için ayrı okuma (3 kademe toplam lazım)
        dynamic nearDepthFull = Sistem.DerinlikVerisiOku(nearS);
        var nearAsk3Depth = 0;
        if (nearDepthFull != null && nearDepthFull.Asks != null) {
            for (int i = 0; i < nearDepthFull.Asks.Count && i < 3; i++) {
                nearAsk3Depth += (int)nearDepthFull.Asks[i].Size;
            }
        }
        
        if (nearAsk3Depth < minAskDepthRequired) {
            Log("⛔ SN BÜYÜTME: " + sym + " Near Ask derinlik yetersiz: " + nearAsk3Depth + " < " + minAskDepthRequired + " (poz:" + totalNQtyAfterAdd + " x5)");
            return false;
        }
        
        // 2. Spot Ask derinlik kontrolü (Spot alıyoruz)
        var spotDepthResult = ReadDepth(spotS, "ASK", 0, 3, 100);
        if (!spotDepthResult.Item1 || spotDepthResult.Item4 <= 0) {
            if (attempt == 3) return false;
            System.Threading.Thread.Sleep(200);
            continue;
        }
        
        var spotAsk1Price = spotDepthResult.Item4;
        
        // 3. GIE fiyatı ve Spread kontrolü
        var giePrice = nearBid1Price;
        if (GIE_DEPTH_LEVELS >= 2 && nearBid1Size < addNQty && nearBid2Price > 0) {
            giePrice = nearBid2Price;
        }
        
        var sp = (giePrice - spotAsk1Price) / spotAsk1Price;
        if (sp < minSp * 0.95m) {
            if (attempt == 3) return false;
            System.Threading.Thread.Sleep(200);
            continue;
        }
        
        // 4. Spot derinlik yeterliliği (10 kademe toplam)
        dynamic spotDepthFull = Sistem.DerinlikVerisiOku(spotS);
        var cumQty = 0;
        if (spotDepthFull != null && spotDepthFull.Asks != null) {
            for (int i = 0; i < spotDepthFull.Asks.Count && i < 10; i++) {
                cumQty += (int)spotDepthFull.Asks[i].Size;
            }
        }
        if (cumQty < addSQty) {
            if (attempt == 3) return false;
            System.Threading.Thread.Sleep(200);
            continue;
        }
        
        // 5. Her şey uygun - Near GİE gönder
        nearP = giePrice;
        SendGIE(nearC, "SELL", addNQty, nearP);
        System.Threading.Thread.Sleep(GIE_WAIT_MS);
        
        // 6. Doldu mu kontrol et
        if (IS_TEST || CheckFilled(nearC, "SELL", addNQty)) {
            filled = true;
            break;
        }
    }
    
    if (!filled) {
        Log("❌ Near 3 denemede dolmadı");
        return false;
    }
    
    // === Near doldu, Spot al (garantili) ===
    var spotResult = ExecGuar(sym, "BUY", addSQty);
    if (spotResult.Item1 == 0) {
        Log("❌ Spot alınamadı - Near geri alınıyor");
        if (!IS_TEST) ExecGuar(nearC, "BUY", addNQty);
        return false;
    }
    
    decimal spotAvgP = spotResult.Item2;
    int spotFilledQty = spotResult.Item1;
    
    // Spot kısmi dolduysa, fazla Near'ı geri al
    var mult = GetMultiplier(sym);
    var neededNear = (int)Math.Ceiling((decimal)spotFilledQty / mult);  // Spot'a karşılık gelen Near
    var excessNear = addNQty - neededNear;
    var actualAddNQty = addNQty;
    
    if (excessNear > 0 && spotFilledQty < addSQty) {
        Log("⚠️ Spot kısmi doldu: " + spotFilledQty + "/" + addSQty + " - Fazla Near geri alınıyor: " + excessNear);
        if (!IS_TEST) ExecGuar(nearC, "BUY", excessNear);
        actualAddNQty = neededNear;  // Kalan Near miktarı
    }
    
    // Ortalama hesapla
    var oldSQty = (int)p[0];
    var oldNQty = (int)p[1];
    var newSQty = oldSQty + spotFilledQty;
    var newNQty = oldNQty + actualAddNQty;
    if (newSQty <= 0 || newNQty <= 0) {
        Log("❌ AddToSN: Yeni miktar sıfır, güncelleme yapılamıyor");
        return true;
    }
    var avgSpot = (p[2] * oldSQty + spotAvgP * spotFilledQty) / newSQty;
    var avgNear = (p[3] * oldNQty + nearP * actualAddNQty) / newNQty;
    if (avgSpot <= 0) {
        Log("❌ AddToSN: Ortalama spot fiyat sıfır");
        return true;
    }
    var newSpread = (avgNear - avgSpot) / avgSpot;
    var newExpectedPnl = newSpread * avgSpot * newSQty;
    var spotComm = CalcSpotCommission(spotAvgP, spotFilledQty);
    var nearComm = CalcCommission(sym, nearP, actualAddNQty);
    var totalComm = spotComm + nearComm;
    newExpectedPnl -= totalComm * 2;
    
    // p[6] = bb93Flag korunur (BB93+ girişi ise 1, değilse 0 veya addCount)
    // BB93 pozisyonlarına ekleme yapılırsa flag korunur
    var bb93Flag = (int)p[6];
    snPos[sym] = new decimal[] { newSQty, newNQty, avgSpot, avgNear, newSpread, newExpectedPnl, bb93Flag, p[7] };
    dailySpotCommission += spotComm;
    dailyViopCommission += nearComm;
    spotUsed += spotAvgP * spotFilledQty;
    AdjustT2Balance(spotAvgP * spotFilledQty, spotComm);  // Alış: T+2 azalır
    var viopTeminat = teminat.ContainsKey(sym) ? teminat[sym] * actualAddNQty : 0;
    viopUsed += viopTeminat;
    AdjustViopBalance(viopTeminat);  // Teminat kullanıldı
    
    // IdealData pozisyon listesini güncelle
    try {
        Sistem.PozisyonKontrolGuncelle(ROBOT_NAME + "_SPOT," + sym, newSQty, (double)avgSpot, "SPOT");
        Sistem.PozisyonKontrolGuncelle(ROBOT_NAME + "_NEAR," + nearC, newNQty, (double)avgNear, "NEAR");
    } catch { }
    
    Log("✅ SN BÜYÜTÜLDÜ: " + sym + " S:" + oldSQty + "→" + newSQty + " Sp:" + (newSpread * 100).ToString("F3") + "%");
    SavePositions();
    return true;
};

// ====================================
// SPOT-NEAR KAPANIŞ (Kontrollü GİE)
// ====================================
Action<string, string, int, int, string> CloseSN = (sym, nearC, sQty, nQty, reason) => {
    // Miktar kontrolü - Near 0 ise kapanış yapma
    if (nQty <= 0) {
        Log("⚠️ CloseSN: " + sym + " Near miktarı 0, kapanış atlanıyor");
        return;
    }
    
    // Pending order kontrolü
    if (pendingOrders.ContainsKey(sym + "_BUY") || pendingOrders.ContainsKey(sym + "_SELL")) {
        Log("⛔ SN KAPANIŞ: " + sym + " pending order var, kapatılmıyor");
        return;
    }
    
    var nearS = FUTURES_PREFIX + nearC;
    var spotS = SPOT_PREFIX + sym;
    
    // TAVAN/TABAN KONTROLÜ - Kapanış
    // Near tavanda → Geri alınamaz (vade sonu hariç)
    var nearTavanFiyat = tavanFiyat.ContainsKey(nearS) ? tavanFiyat[nearS] : 0;
    if (nearTavanFiyat > 0) {
        var nearAlisFiyat = (decimal)Sistem.AlisFiyat(nearS);
        if (nearAlisFiyat >= nearTavanFiyat) {
            if (!reason.StartsWith("EXPIRY_MANDATORY")) {
                Log("⚠️ CloseSN: " + sym + " Near TAVANDA - geri alınamaz, kapanış atlanıyor");
                return;
            }
            // Vade sonu - zorunlu kapat (settlement'a bırak)
            Log("⚠️ CloseSN: " + sym + " Near TAVANDA ama vade sonu - settlement'a bırakılıyor");
        }
    }
    
    // Spot tabanda → Satılamaz (vade sonu hariç)
    var spotTabanFiyat = tabanFiyat.ContainsKey(spotS) ? tabanFiyat[spotS] : 0;
    if (spotTabanFiyat > 0) {
        var spotSatisFiyat = (decimal)Sistem.SatisFiyat(spotS);
        if (spotSatisFiyat <= spotTabanFiyat) {
            if (!reason.StartsWith("EXPIRY_MANDATORY")) {
                Log("⚠️ CloseSN: " + sym + " Spot TABANDA - satılamaz, kapanış atlanıyor");
                return;
            }
            // Vade sonu - zorunlu kapat (settlement'a bırak)
            Log("⚠️ CloseSN: " + sym + " Spot TABANDA ama vade sonu - settlement'a bırakılıyor");
        }
    }
    
    // Gün içi kar durumunda özel loglama
    var isIntraday = reason.StartsWith("INTRADAY_PROFIT") || reason.StartsWith("INTRADAY_BB93");
    var intradaySpotPnl = 0m;
    var intradayNearPnl = 0m;
    if (isIntraday) {
        var parts = reason.Split('|');
        if (parts.Length >= 4) {
            decimal.TryParse(parts[2], out intradaySpotPnl);
            decimal.TryParse(parts[3], out intradayNearPnl);
        }
        if (reason.StartsWith("INTRADAY_BB93")) {
            var exitType = reason.Contains("_BB|") ? "BB≤15" : "Spread≥0.23%";
            Log("📊 BB93 GÜN İÇİ KAPANIŞ: " + sym + " (" + exitType + ")");
        } else {
            Log("📊 GÜN İÇİ KAR KAPANIŞ: " + sym + " (T+0)");
        }
    } else {
        Log("📊 SN KAPANIŞ: " + sym + " Sebep: " + reason);
    }
    
    // === ÖNCE derinlik kontrolü ===
    var nearInitResult = ReadDepth(nearS, "ASK", 0, 3, 100);
    if (!nearInitResult.Item1) {
        Log("❌ Kapanış: Near Ask derinlik yok");
        return;
    }
    
    var spotInitResult = ReadDepth(spotS, "BID", 0, 3, 100);
    if (!spotInitResult.Item1) {
        Log("❌ Kapanış: Spot Bid derinlik yok");
        return;
    }
    
    // === ÖNCE Near al (3 deneme GİE) ===
    decimal nearPrice = 0;
    var nearFilledQty = 0;
    
    for (int attempt = 1; attempt <= 3; attempt++) {
        // Near Ask derinlik kontrolü (Near alıyoruz)
        var nearAskResult = ReadDepth(nearS, "ASK", 0, 3, 100);
        if (!nearAskResult.Item1) {
            Log("⏳ Near Ask boş (deneme " + attempt + "/3)");
            if (attempt == 3) break;
            System.Threading.Thread.Sleep(200);
            continue;
        }
        
        var nearAsk1Size = nearAskResult.Item2;
        var nearAsk2Size = nearAskResult.Item3;
        var nearAsk1Price = nearAskResult.Item4;
        var nearAsk2Price = nearAskResult.Item5;
        var nearTotalSize = GIE_DEPTH_LEVELS >= 2 ? nearAskResult.Item6 : nearAsk1Size;
        
        if (GIE_DEPTH_LEVELS == 1) {
            if (nearAsk1Size < nQty) {
                Log("⏳ Near Ask 1.kademe yetersiz (deneme " + attempt + "/3)");
                if (attempt == 3) break;
                System.Threading.Thread.Sleep(200);
                continue;
            }
        } else {
            if (nearTotalSize < nQty) {
                Log("⏳ Near Ask 1+2.kademe yetersiz (deneme " + attempt + "/3)");
                if (attempt == 3) break;
                System.Threading.Thread.Sleep(200);
                continue;
            }
        }
        
        // GIE fiyatı
        nearPrice = nearAsk1Price;
        if (GIE_DEPTH_LEVELS >= 2 && nearAsk1Size < nQty && nearAsk2Price > 0) {
            nearPrice = nearAsk2Price;
        }
        SendGIE(nearC, "BUY", nQty, nearPrice);
        System.Threading.Thread.Sleep(GIE_WAIT_MS);
        
        nearFilledQty = IS_TEST ? nQty : CheckFilledQty(nearC, "BUY", nQty);
        // Beklenen miktardan fazla olamaz (eski emirler karışmasın)
        if (nearFilledQty > nQty) nearFilledQty = nQty;
        if (nearFilledQty >= nQty) {
            break;  // Tam doldu
        } else if (nearFilledQty > 0) {
            Log("⚠️ Near kısmi doldu: " + nearFilledQty + "/" + nQty);
            break;  // Kısmi doldu - devam et
        }
        
        Log("⏳ Near dolmadı (deneme " + attempt + "/3)");
    }
    
    // Hiç dolmadıysa garantili yöntemle al
    if (nearFilledQty == 0) {
        Log("⚠️ Near GİE dolmadı, garantili alım yapılıyor");
        var nr = ExecGuar(nearC, "BUY", nQty);
        if (nr.Item1 == 0) {
            // Near kapatılamadı - Spot'a dokunma, pozisyon aynı kalsın
            Log("❌ Near kapatılamadı - kapanış iptal, pozisyon korunuyor");
            return;
        }
        nearFilledQty = nr.Item1;
        nearPrice = nr.Item2;
    }
    
    // Kısmi dolum durumunda oranla Spot hesapla
    var mult = GetMultiplier(sym);
    var closeSQty = (int)Math.Round((decimal)nearFilledQty * mult);  // Near lot -> Spot lot
    if (closeSQty > sQty) closeSQty = sQty;  // Max spot miktarını aşma
    if (closeSQty == 0) closeSQty = 1;  // En az 1 lot
    
    Log("📊 Near dolum: " + nearFilledQty + "/" + nQty + " -> Spot kapatılacak: " + closeSQty + "/" + sQty);
    
    // === Near kapandı, şimdi Spot sat (garantili) ===
    var sr = ExecGuar(sym, "SELL", closeSQty);
    if (sr.Item1 == 0) {
        // Spot satılamadı ama Near kapandı - orphan pozisyon!
        Log("❌ Spot satılamadı - ORPHAN POZİSYON! Near kapandı, Spot hala açık");
        if (snPos.ContainsKey(sym)) {
            var p = snPos[sym];
            // Near kapandı, P&L'yi sadece near kısmı için hesapla
            var nearPnl = (p[3] - nearPrice) * nearFilledQty * mult;
            var nearComm = CalcCommission(sym, nearPrice, nearFilledQty);
            nearPnl -= nearComm;
            dailyRealizedPnl += nearPnl;
            dailyViopCommission += nearComm;
            var viopTeminat = teminat.ContainsKey(sym) ? teminat[sym] * nearFilledQty : 0;
            viopUsed -= viopTeminat;
            if (viopUsed < 0) viopUsed = 0;
            AdjustViopBalance(-viopTeminat);  // Teminat serbest
            
            // Pozisyonu güncelle - Near kapananı düş, Spot aynı kalsın
            var remainNQty = nQty - nearFilledQty;
            var newExpPnl = nQty > 0 ? p[5] * remainNQty / nQty : 0;
            snPos[sym] = new decimal[] { p[0], remainNQty, p[2], p[3], p[4], newExpPnl, p[6], p[7] };
            Log("⚠️ " + sym + " pozisyon güncellendi: Spot=" + p[0] + ", Near=" + remainNQty + " (recovery bekliyor)");
        }
        SavePositions();
        return;
    }
    
    // === P&L hesapla ===
    if (snPos.ContainsKey(sym)) {
        var p = snPos[sym];
        
        var spotPnl = (sr.Item2 - p[2]) * closeSQty;
        var nearPnl = (p[3] - nearPrice) * nearFilledQty * mult;
        var totalPnl = spotPnl + nearPnl;
        
        var spotComm = CalcSpotCommission(sr.Item2, closeSQty);
        var nearComm = CalcCommission(sym, nearPrice, nearFilledQty);
        totalPnl -= (spotComm + nearComm);
        
        dailyRealizedPnl += totalPnl;
        dailySNPnl += totalPnl;
        dailySpotCommission += spotComm;
        dailyViopCommission += nearComm;
        spotUsed -= sr.Item2 * closeSQty;
        if (spotUsed < 0) spotUsed = 0;
        AdjustT2Balance(-(sr.Item2 * closeSQty), spotComm);  // Satış: T+2 artar (negatif amount)
        dailyTrades++;
        
        var viopTeminat = teminat.ContainsKey(sym) ? teminat[sym] * nearFilledQty : 0;
        viopUsed -= viopTeminat;
        if (viopUsed < 0) viopUsed = 0;
        AdjustViopBalance(-viopTeminat);  // Teminat serbest (negatif = artar)
        
        // Gün içi kar durumunda özel loglama
        if (isIntraday) {
            Log("💰 GÜN İÇİ KAR: Spot:" + spotPnl.ToString("F0") + " Near:" + nearPnl.ToString("F0") + " Net:" + totalPnl.ToString("F0") + " TL (T+0)");
        } else {
            Log("💰 SN P&L: Spot:" + spotPnl.ToString("F0") + " Near:" + nearPnl.ToString("F0") + " Toplam:" + totalPnl.ToString("F0") + " TL");
        }
        
        // Kısmi kapanış mı tam kapanış mı?
        if (nearFilledQty >= nQty && closeSQty >= sQty) {
            // Tam kapanış
            totalClosedSN++;
            snPos.Remove(sym);
            try {
                Sistem.PozisyonKontrolGuncelle(ROBOT_NAME + "_SPOT," + sym, 0, 0, "X");
                Sistem.PozisyonKontrolGuncelle(ROBOT_NAME + "_NEAR," + nearC, 0, 0, "X");
            } catch { }
            Log("✅ SN KAPANDI: " + sym);
        } else {
            // Kısmi kapanış - kalan pozisyonu güncelle
            var remainSQty = sQty - closeSQty;
            var remainNQty = nQty - nearFilledQty;
            var newExpPnl = nQty > 0 ? p[5] * remainNQty / nQty : 0;
            snPos[sym] = new decimal[] { remainSQty, remainNQty, p[2], p[3], p[4], newExpPnl, p[6], p[7] };
            try {
                Sistem.PozisyonKontrolGuncelle(ROBOT_NAME + "_SPOT," + sym, remainSQty, (double)p[2], "SPOT");
                Sistem.PozisyonKontrolGuncelle(ROBOT_NAME + "_NEAR," + nearC, remainNQty, (double)p[3], "NEAR");
            } catch { }
            Log("⚠️ SN KISMİ KAPANDI: " + sym + " Kalan S:" + remainSQty + " N:" + remainNQty);
        }
        
        if (SaveDailyStats != null) SaveDailyStats();
    }
    
    SavePositions();
};

// ====================================
// SPOT-NEAR KISMİ KAPANIŞ (Sadece gerektiği kadar kapat)
// ====================================
Func<string, string, int, int, string, bool> PartialCloseSN = (sym, nearC, closeSQty, closeNQty, reason) => {
    if (!snPos.ContainsKey(sym)) return false;
    var p = snPos[sym];
    var totalSQty = (int)p[0];
    var totalNQty = (int)p[1];
    
    // Miktar kontrolü
    if (closeNQty <= 0 || closeSQty <= 0) {
        Log("⚠️ PartialCloseSN: " + sym + " miktar 0, kapanış atlanıyor (S:" + closeSQty + " N:" + closeNQty + ")");
        return false;
    }
    
    // Tam kapanış mı?
    if (closeSQty >= totalSQty || closeNQty >= totalNQty) {
        CloseSN(sym, nearC, totalSQty, totalNQty, reason);
        return true;
    }
    
    Log("📊 SN KISMİ KAPANIŞ: " + sym + " S:" + closeSQty + "/" + totalSQty + " N:" + closeNQty + "/" + totalNQty + " Sebep: " + reason);
    
    var nearS = FUTURES_PREFIX + nearC;
    var spotS = SPOT_PREFIX + sym;
    
    // Derinlik ön kontrolü
    var nearDepthPre = ReadDepth(nearS, "ASK", 0, 3, 100);
    if (!nearDepthPre.Item1) {
        Log("❌ Kısmi Kapanış: Near Ask derinlik yok");
        return false;
    }
    
    var spotDepthPre = ReadDepth(spotS, "BID", 0, 3, 100);
    if (!spotDepthPre.Item1) {
        Log("❌ Kısmi Kapanış: Spot Bid derinlik yok");
        return false;
    }
    
    // === ÖNCE Near al (3 deneme GİE) ===
    decimal nearPrice = 0;
    var nearFilledQty = 0;
    
    for (int attempt = 1; attempt <= 3; attempt++) {
        var nearAskResult = ReadDepth(nearS, "ASK", 0, 3, 100);
        if (!nearAskResult.Item1) {
            if (attempt == 3) break;
            System.Threading.Thread.Sleep(200);
            continue;
        }
        
        var nearAsk1Price = nearAskResult.Item4;
        var nearAsk1Size = nearAskResult.Item2;
        var nearAsk2Price = nearAskResult.Item5;
        var nearAsk2Size = nearAskResult.Item3;
        var nearTotalSize = GIE_DEPTH_LEVELS >= 2 ? nearAskResult.Item6 : nearAsk1Size;
        
        if (GIE_DEPTH_LEVELS == 1) {
            if (nearAsk1Size < closeNQty) {
                if (attempt == 3) break;
                System.Threading.Thread.Sleep(200);
                continue;
            }
        } else {
            if (nearTotalSize < closeNQty) {
                if (attempt == 3) break;
                System.Threading.Thread.Sleep(200);
                continue;
            }
        }
        
        nearPrice = nearAsk1Price;
        if (GIE_DEPTH_LEVELS >= 2 && nearAsk1Size < closeNQty && nearAsk2Price > 0) {
            nearPrice = nearAsk2Price;
        }
        SendGIE(nearC, "BUY", closeNQty, nearPrice);
        System.Threading.Thread.Sleep(GIE_WAIT_MS);
        
        nearFilledQty = IS_TEST ? closeNQty : CheckFilledQty(nearC, "BUY", closeNQty);
        // Beklenen miktardan fazla olamaz (eski emirler karışmasın)
        if (nearFilledQty > closeNQty) nearFilledQty = closeNQty;
        if (nearFilledQty >= closeNQty) {
            break;  // Tam doldu
        } else if (nearFilledQty > 0) {
            Log("⚠️ Near kısmi doldu: " + nearFilledQty + "/" + closeNQty);
            break;  // Kısmi doldu - devam et
        }
    }
    
    // Hiç dolmadıysa garantili yöntemle al
    if (nearFilledQty == 0) {
        Log("⚠️ Near GİE dolmadı, garantili alım yapılıyor");
        var nr = ExecGuar(nearC, "BUY", closeNQty);
        if (nr.Item1 == 0) {
            // Near kapatılamadı - Spot'a dokunma, pozisyon aynı kalsın
            Log("❌ Kısmi Kapanış: Near kapatılamadı - işlem iptal, pozisyon korunuyor");
            return false;
        }
        nearFilledQty = nr.Item1;
        nearPrice = nr.Item2;
    }
    
    // Kısmi dolum durumunda oranla Spot hesapla
    var mult = GetMultiplier(sym);
    var actualCloseSQty = (int)Math.Round((decimal)nearFilledQty * mult);  // Near lot -> Spot lot
    if (actualCloseSQty > closeSQty) actualCloseSQty = closeSQty;  // Max istenen miktarı aşma
    if (actualCloseSQty > totalSQty) actualCloseSQty = totalSQty;  // Max pozisyonu aşma
    if (actualCloseSQty == 0) actualCloseSQty = 1;  // En az 1 lot
    
    Log("📊 Near dolum: " + nearFilledQty + "/" + closeNQty + " -> Spot kapatılacak: " + actualCloseSQty + "/" + closeSQty);
    
    // === Near kapandı, şimdi Spot sat ===
    var sr = ExecGuar(sym, "SELL", actualCloseSQty);
    if (sr.Item1 == 0) {
        // Spot satılamadı ama Near kapandı - orphan pozisyon!
        Log("❌ Spot satılamadı - ORPHAN POZİSYON! Kısmi Near kapandı, Spot hala açık");
        // Near kapandı, P&L'yi sadece near kısmı için hesapla
        var nearPnl = (p[3] - nearPrice) * nearFilledQty * mult;
        var nearComm = CalcCommission(sym, nearPrice, nearFilledQty);
        nearPnl -= nearComm;
        dailyRealizedPnl += nearPnl;
        dailyViopCommission += nearComm;
        var viopTeminat = teminat.ContainsKey(sym) ? teminat[sym] * nearFilledQty : 0;
        viopUsed -= viopTeminat;
        if (viopUsed < 0) viopUsed = 0;
        AdjustViopBalance(-viopTeminat);  // Teminat serbest
        
        var remainNQty = totalNQty - nearFilledQty;
        // Spot değişmedi, kalan Near ile güncelle
        var expPnlRatio = totalNQty > 0 ? p[5] * remainNQty / totalNQty : 0;
        snPos[sym] = new decimal[] { totalSQty, remainNQty, p[2], p[3], p[4], expPnlRatio, p[6], p[7] };
        Log("⚠️ " + sym + " pozisyon güncellendi: Spot=" + totalSQty + ", Near=" + remainNQty + " (uyumsuz - recovery bekliyor)");
        SavePositions();
        return false;
    }
    
    // === İki bacak da kapandı - P&L hesapla ===
    var spotPnl = (sr.Item2 - p[2]) * actualCloseSQty;
    var nearPnl2 = (p[3] - nearPrice) * nearFilledQty * mult;
    var totalPnl = spotPnl + nearPnl2;
    
    var spotComm = CalcSpotCommission(sr.Item2, actualCloseSQty);
    var nearComm2 = CalcCommission(sym, nearPrice, nearFilledQty);
    totalPnl -= (spotComm + nearComm2);
    
    dailyRealizedPnl += totalPnl;
    dailySpotCommission += spotComm;
    dailyViopCommission += nearComm2;
    spotUsed -= sr.Item2 * actualCloseSQty;
    if (spotUsed < 0) spotUsed = 0;
    AdjustT2Balance(-(sr.Item2 * actualCloseSQty), spotComm);  // Satış: T+2 artar
    dailyTrades++;
    
    var viopTeminat2 = teminat.ContainsKey(sym) ? teminat[sym] * nearFilledQty : 0;
    viopUsed -= viopTeminat2;
    if (viopUsed < 0) viopUsed = 0;
    AdjustViopBalance(-viopTeminat2);  // Teminat serbest
    
    // Kalan pozisyonu güncelle
    var remainSQty = totalSQty - actualCloseSQty;
    var remainNQty2 = totalNQty - nearFilledQty;
    var expPnlRatio2 = totalSQty > 0 ? p[5] * remainSQty / totalSQty : 0;
    snPos[sym] = new decimal[] { remainSQty, remainNQty2, p[2], p[3], p[4], expPnlRatio2, p[6], p[7] };
    
    // IdealData güncelle
    try {
        Sistem.PozisyonKontrolGuncelle(ROBOT_NAME + "_SPOT," + sym, remainSQty, (double)p[2], "SPOT");
        Sistem.PozisyonKontrolGuncelle(ROBOT_NAME + "_NEAR," + nearC, remainNQty2, (double)p[3], "NEAR");
    } catch { }
    
    Log("💰 SN KISMİ P&L: Spot:" + spotPnl.ToString("F0") + " Near:" + nearPnl2.ToString("F0") + " Toplam:" + totalPnl.ToString("F0") + " TL");
    Log("✅ SN KISMİ KAPANDI: " + sym + " Kalan S:" + remainSQty + " N:" + remainNQty2);
    SavePositions();
    return true;
};


// ====================================
// SPOT-NEAR ROLLOVER (Near→Far) - Kontrollü GİE
// ====================================
Func<string, string, string, int, bool> RolloverSN = (sym, nearC, farC, nQty) => {
    Log("🔄 SN ROLLOVER: " + sym + " Near→Far");
    
    var farS = FUTURES_PREFIX + farC;
    
    // === ÖNCE Far derinlik kontrolü (Near kapatmadan önce!) ===
    // Far derinlik ön kontrolü
    var farDepthPre = ReadDepth(farS, "BID", 0, 3, 100);
    if (!farDepthPre.Item1) {
        Log("❌ Rollover: Far derinlik yok, işlem yapılmadı");
        return false;
    }
    
    var preBid1Size = farDepthPre.Item2;
    var preTotalSize = GIE_DEPTH_LEVELS >= 2 ? farDepthPre.Item6 : preBid1Size;
    
    if (GIE_DEPTH_LEVELS == 1) {
        if (preBid1Size < nQty) {
            Log("❌ Rollover: Far 1.kademe yetersiz, işlem yapılmadı");
            return false;
        }
    } else {
        if (preTotalSize < nQty) {
            Log("❌ Rollover: Far 1+2.kademe yetersiz, işlem yapılmadı");
            return false;
        }
    }
    
    // === Near kapat (garantili) ===
    var nearResult = ExecGuar(nearC, "BUY", nQty);
    if (nearResult.Item1 == 0) {
        Log("❌ Rollover: Near kapatılamadı");
        return false;
    }
    
    // === Far aç (3 deneme) ===
    decimal farPrice = 0;
    var filled = false;
    
    for (int attempt = 1; attempt <= 3; attempt++) {
        // Derinlik oku
        var farDepthResult = ReadDepth(farS, "BID", 0, 3, 100);
        if (!farDepthResult.Item1) {
            Log("⏳ Far Bid boş (deneme " + attempt + "/3)");
            if (attempt == 3) break;
            System.Threading.Thread.Sleep(200);
            continue;
        }
        
        var farBid1Price = farDepthResult.Item4;
        var farBid1Size = farDepthResult.Item2;
        var farBid2Price = farDepthResult.Item5;
        var farBid2Size = farDepthResult.Item3;
        var farTotalSize = GIE_DEPTH_LEVELS >= 2 ? farDepthResult.Item6 : farBid1Size;
        
        if (GIE_DEPTH_LEVELS == 1) {
            if (farBid1Size < nQty) {
                Log("⏳ Far Bid 1.kademe yetersiz (deneme " + attempt + "/3)");
                if (attempt == 3) break;
                System.Threading.Thread.Sleep(200);
                continue;
            }
        } else {
            if (farTotalSize < nQty) {
                Log("⏳ Far Bid 1+2.kademe yetersiz (deneme " + attempt + "/3)");
                if (attempt == 3) break;
                System.Threading.Thread.Sleep(200);
                continue;
            }
        }
        
        farPrice = farBid1Price;
        if (GIE_DEPTH_LEVELS >= 2 && farBid1Size < nQty && farBid2Price > 0) {
            farPrice = farBid2Price;
        }
        SendGIE(farC, "SELL", nQty, farPrice);
        System.Threading.Thread.Sleep(GIE_WAIT_MS);
        
        if (IS_TEST || CheckFilled(farC, "SELL", nQty)) {
            filled = true;
            break;
        }
        
        Log("⏳ Far dolmadı (deneme " + attempt + "/3)");
    }
    
    if (!filled) {
        Log("❌ Rollover: Far 3 denemede dolmadı - Spot kapatılıyor");
        // Spot'u garantili emirle sat
        var spotQty = (int)snPos[sym][0];
        var spotResult = ExecGuar(sym, "SELL", spotQty);
        
        // Pozisyon kapat ve kaydet
        var p = snPos[sym];
        var pnl = p[5];  // Mevcut beklenen PnL
        dailySNPnl += pnl;
        totalClosedSN++;
        
        // Bakiye güncellemeleri
        var spotValue = p[2] * spotQty;  // spotEntry * spotQty
        spotUsed -= spotValue;
        if (spotUsed < 0) spotUsed = 0;
        var spotCommRoll = CalcSpotCommission(spotResult.Item2, spotQty);
        AdjustT2Balance(-spotValue, spotCommRoll);  // Satış
        
        var viopTeminatRoll = teminat.ContainsKey(sym) ? teminat[sym] * nQty : 0;
        viopUsed -= viopTeminatRoll;
        if (viopUsed < 0) viopUsed = 0;
        AdjustViopBalance(-viopTeminatRoll);  // Teminat serbest (Near zaten kapatılmıştı)
        
        snPos.Remove(sym);
        SavePositions();
        Log("✅ Pozisyon kapatıldı (Rollover başarısız): " + sym);
        return false;
    }
    
    // === Pozisyon güncelle (Spot aynı kalıyor!) ===
    var pos = snPos[sym];
    var spotEntry = pos[2];
    if (spotEntry <= 0) {
        Log("❌ Rollover: Spot entry sıfır, pozisyon güncelleme atlanıyor");
        return false;
    }
    var newSpread = (farPrice - spotEntry) / spotEntry;
    var newExpectedPnl = newSpread * spotEntry * pos[0];
    var nearComm = CalcCommission(sym, nearResult.Item2, nQty);
    var farComm = CalcCommission(sym, farPrice, nQty);
    newExpectedPnl -= (nearComm + farComm);
    dailyViopCommission += nearComm + farComm;
    
    snPos[sym] = new decimal[] { pos[0], nQty, spotEntry, farPrice, newSpread, newExpectedPnl, 0, DateTime.Now.Ticks };
    
    // IdealData pozisyon listesini güncelle
    try {
        Sistem.PozisyonKontrolGuncelle(ROBOT_NAME + "_NEAR," + nearC, 0, 0, "X");
        Sistem.PozisyonKontrolGuncelle(ROBOT_NAME + "_NEAR," + farC, nQty, (double)farPrice, "NEAR");
    } catch { }
    
    Log("✅ SN ROLLOVER: " + sym + " Near:" + nearResult.Item2.ToString("F2") + "→Far:" + farPrice.ToString("F2") + " Spread:" + (newSpread * 100).ToString("F3") + "%");
    SavePositions();
    return true;
};

// ====================================
// KAPANIŞ KOŞULLARI
// ====================================
Func<string, string, decimal, decimal, int, decimal, string> CheckSNClose = 
    (sym, nearC, spotBid, nearAsk, daysN, currentBBPos) => {
    
    if (!snPos.ContainsKey(sym)) return null;
    var p = snPos[sym];
    var sQty = (int)p[0];
    var nQty = (int)p[1];
    
    // Near 0 ise kapanış kontrolü yapma (yetim pozisyon - recovery halledecek)
    if (nQty <= 0) return null;
    
    var spotEntry = p[2];
    var nearEntry = p[3];
    // p[4] = entrySpread, p[5] = expectedPnl, p[6] = bb93Flag, p[7] = entryTicks
    var bb93Flag = p.Length > 6 ? (int)p[6] : 0;
    var entryTicks = p.Length > 7 ? (long)p[7] : 0L;
    var expectedPnl = p[5];
    var entrySpread = p[4];
    
    var spotSym = SPOT_PREFIX + sym;
    var nearSym = FUTURES_PREFIX + nearC;
    
    // TAVAN/TABAN KONTROLÜ - P&L HESABI
    // Kapanış için: Spot SATIYORUZ (spotBid) + Near ALIYORUZ (nearAsk)
    //
    // TAVAN = Satıcı yok = Ask tarafı boş/0 = Alış fiyatı tavana yapışık
    // TABAN = Alıcı yok = Bid tarafı boş/0 = Satış fiyatı tabana yapışık
    //
    // Spot tavan: spotBid normal (alıcılar tavanda bekliyor), satılabilir AMA fiyat tavanda
    // Spot taban: spotBid = 0 veya taban fiyatı (alıcı yok), SATILAMAZ
    // Near tavan: nearAsk = 0 veya tavan fiyatı (satıcı yok), ALINAMAZ  
    // Near taban: nearAsk normal (satıcılar tabanda bekliyor), alınabilir AMA fiyat tabanda
    
    // P&L hesabı için fiyat düzeltmeleri
    var spotBidForPnL = spotBid;
    var nearAskForPnL = nearAsk;
    
    // Spot tavan kontrolü (Bid tarafı tavana yapışık mı?)
    var spotTavanFiyat = tavanFiyat.ContainsKey(spotSym) ? tavanFiyat[spotSym] : 0;
    var spotTavanda = spotTavanFiyat > 0 && spotBid >= spotTavanFiyat;
    if (spotTavanda) spotBidForPnL = spotTavanFiyat;  // Tavanda satılabilir
    
    // Spot taban kontrolü (Bid = 0 veya taban?)
    var spotTabanFiyat = tabanFiyat.ContainsKey(spotSym) ? tabanFiyat[spotSym] : 0;
    var spotTabanda = spotTabanFiyat > 0 && (spotBid <= 0 || spotBid <= spotTabanFiyat);
    if (spotTabanda) {
        spotBidForPnL = spotTabanFiyat;  // P&L hesabı için taban fiyatı kullan
        // Spot tabanda → SATILAMAZ → pozisyon kapatılamaz (vade sonu hariç)
        if (daysN > 0) return null;
    }
    
    // Near tavan kontrolü (Ask = 0 veya tavan?)
    var nearTavanFiyat = tavanFiyat.ContainsKey(nearSym) ? tavanFiyat[nearSym] : 0;
    var nearTavanda = nearTavanFiyat > 0 && (nearAsk <= 0 || nearAsk >= nearTavanFiyat);
    if (nearTavanda) {
        nearAskForPnL = nearTavanFiyat;  // P&L hesabı için tavan fiyatı kullan
        // Near tavanda → ALINAMAZ → pozisyon kapatılamaz (vade sonu hariç)
        if (daysN > 0) return null;
    }
    
    // Near taban kontrolü (Ask tarafı tabana yapışık mı?)
    var nearTabanFiyat = tabanFiyat.ContainsKey(nearSym) ? tabanFiyat[nearSym] : 0;
    var nearTabanda = nearTabanFiyat > 0 && nearAsk <= nearTabanFiyat;
    if (nearTabanda) nearAskForPnL = nearTabanFiyat;  // Tabanda alınabilir
    
    // nearAsk direkt kullanılıyor (dayanakSatAl yerine)
    var mult = GetMultiplier(sym);
    var closePnl = (spotBidForPnL - spotEntry) * sQty + (nearEntry - nearAskForPnL) * nQty * mult;
    var closeComm = CalcSpotCommission(spotBidForPnL, sQty) + CalcCommission(sym, nearAskForPnL, nQty);
    closePnl -= closeComm;
    
    // Mevcut spread hesapla
    var currentSpread = spotBidForPnL > 0 ? (nearAskForPnL - spotBidForPnL) / spotBidForPnL : 0;
    var spreadDaralma = entrySpread - currentSpread;  // Pozitif = spread daraldı (iyi)
    
    // 1. VADE SONU - ZORUNLU (12:00 sonrası - yarım gün vade 12:30 kapanışına 30dk marj)
    if (daysN <= 0) {
        var expiryNow = DateTime.Now;
        var expiryMinutes = expiryNow.Hour * 60 + expiryNow.Minute;
        if (expiryMinutes >= 12 * 60) {  // 12:00 sonrası
            return "EXPIRY_MANDATORY";
        }
        // 12:00 öncesi - henüz kapatma
        return null;
    }
    
    // 2. GÜNLÜK ZARAR
    if (dailyRealizedPnl <= -MAX_DAILY_LOSS) return "DAILY_LOSS";
    
    // 3. BB93+ POZİSYON KAPANIS KONTROLÜ (gün içi kar mekanizmasına entegre)
    // BB93+ girişleri için: BB <= 15 VEYA spread >= %0.23 daralma
    if (bb93Flag == 1 && BB93_ENTRY_ENABLED) {
        // Çıkış koşulları: BB <= 15 VEYA spread daralması >= %0.23
        if (currentBBPos >= 0 && currentBBPos <= BB93_EXIT_BB) {
            var spotPnl = (spotBidForPnL - spotEntry) * sQty - CalcSpotCommission(spotBidForPnL, sQty);
            var nearPnl = (nearEntry - nearAskForPnL) * nQty * mult - CalcCommission(sym, nearAskForPnL, nQty);
            return "INTRADAY_BB93_BB|" + closePnl.ToString("F0") + "|" + spotPnl.ToString("F0") + "|" + nearPnl.ToString("F0") + "|BB:" + currentBBPos.ToString("F0");
        }
        if (spreadDaralma >= BB93_EXIT_SPREAD) {
            var spotPnl = (spotBidForPnL - spotEntry) * sQty - CalcSpotCommission(spotBidForPnL, sQty);
            var nearPnl = (nearEntry - nearAskForPnL) * nQty * mult - CalcCommission(sym, nearAskForPnL, nQty);
            return "INTRADAY_BB93_SPREAD|" + closePnl.ToString("F0") + "|" + spotPnl.ToString("F0") + "|" + nearPnl.ToString("F0") + "|D:" + (spreadDaralma * 100).ToString("F2") + "%";
        }
        // BB93+ pozisyonları için sadece bu koşullar geçerli - diğer koşullar uygulanmaz
        return null;
    }
    
    // 4. GÜN İÇİ KAR (T+0 - sadece bugün açılan pozisyonlar, BB93+ hariç)
    var entryDate = new DateTime(entryTicks).Date;
    if (entryDate == DateTime.Now.Date && daysN > 0) {
        var spotValue = spotBidForPnL * sQty;
        if (spotValue > 0) {  // spotValue sıfır kontrolü
            var minimumKar = spotValue * INTRADAY_MIN_PROFIT;  // Ayarlanabilir minimum
            var gunIciKarOrani = closePnl / spotValue;
            var gunlukTasimaGetirisi = (expectedPnl / spotValue) / daysN;  // vade sonuna kadar taşıma varsayımı
            
            // Gün içi kapat: minimum kar VE taşımaktan daha karlı
            if (closePnl >= minimumKar && gunIciKarOrani >= gunlukTasimaGetirisi) {
                // Spot ve Near kar/zarar ayrı hesapla (loglama için)
                var spotPnl = (spotBidForPnL - spotEntry) * sQty - CalcSpotCommission(spotBidForPnL, sQty);
                var nearPnl = (nearEntry - nearAskForPnL) * nQty * mult - CalcCommission(sym, nearAskForPnL, nQty);
                return "INTRADAY_PROFIT|" + closePnl.ToString("F0") + "|" + spotPnl.ToString("F0") + "|" + nearPnl.ToString("F0");
            }
        }
    }
    
    // 5. ERKEN KAPANIŞ - DİNAMİK K FORMÜLÜ
    // Mantık: Geçen sürenin karşılığını aldın mı?
    // earnedTarget = expectedPnl × elapsedRatio × (1 + k)
    // k = EARLY_EXIT_K × remainingRatio (vade sonuna yaklaştıkça k düşer)
    if (expectedPnl > 0 && entryTicks > 0) {
        var entryTime = new DateTime(entryTicks);
        var hoursElapsed = (decimal)(DateTime.Now - entryTime).TotalHours;
        var hoursTotal = (decimal)GetHours(nearC) + hoursElapsed;
        
        if (hoursTotal > 0 && hoursElapsed > 0) {
            var elapsedRatio = hoursElapsed / hoursTotal;       // Geçen süre oranı (0-1)
            var remainingRatio = 1m - elapsedRatio;             // Kalan süre oranı (0-1)
            var k = EARLY_EXIT_K * remainingRatio;              // Dinamik marj
            var earnedTarget = expectedPnl * elapsedRatio * (1m + k);  // Hedef kâr
            
            // Hedef kârı yakaladık VE BB5 düşük (spread sakin)
            if (closePnl >= earnedTarget && currentBBPos < BB_EXIT_HELPER && currentBBPos > 0) {
                var profitPct = expectedPnl > 0 ? (closePnl / expectedPnl * 100m).ToString("F0") : "∞";
                var targetPct = expectedPnl > 0 ? (earnedTarget / expectedPnl * 100m).ToString("F0") : "∞";
                Log("📊 ERKEN KAPANIŞ: " + sym + " Kâr:" + profitPct + "% Hedef:" + targetPct + 
                    "% (k:" + k.ToString("F3") + " geçen:" + (elapsedRatio * 100).ToString("F0") + "%) BB5:" + currentBBPos.ToString("F0"));
                return "EARLY_EXIT";
            }
        }
    }
    
    return null;
};

// ====================================
// NEAR-FAR (NF) STRATEJİSİ FONKSİYONLARI
// ====================================
// Near AL + Far SAT (takvim spread arbitrajı)
// Pozisyon: nfPos[sym] = [nearQty, farQty, nearEntry, farEntry, entrySpread, expectedPnl, entryTicks]

// NF Spread hesapla (Far - Near) / Near
Func<string, string, decimal, decimal, decimal> CalcNFSpread = (nearC, farC, nearPrice, farPrice) => {
    if (nearPrice <= 0) return 0;
    return (farPrice - nearPrice) / nearPrice;
};

// NF pozisyon aç: Near AL + Far SAT
// GIE sırası: Önce Far SAT (likit olmayan taraf), sonra Near AL
Func<string, string, string, int, bool> OpenNF = (sym, nearC, farC, qty) => {
    // Pair Trading için yasaklı sembol kontrolü
    if (PAIR_BLOCKED.Contains(sym)) {
        return false;  // Sessizce atla (normal durum)
    }
    
    if (nfPos.Count >= NF_MAX_POSITIONS) {
        Log("⚠️ NF: Maksimum pozisyon sayısına ulaşıldı (" + NF_MAX_POSITIONS + ")");
        return false;
    }
    
    // Çakışma kontrolü: Spot-Near'da bu sembol varsa NF açılamaz
    if (snPos.ContainsKey(sym)) {
        Log("⚠️ NF: " + sym + " Spot-Near pozisyonu var, NF açılamaz");
        return false;
    }
    
    // Temettü kontrolü: Near-Far arası temettü varsa spread hesabını etkiler
    var nearExpiry = GetExpiryDate(nearC);
    var farExpiry = GetExpiryDate(farC);
    var divCheck = GetDividendsBetween(sym, nearExpiry, farExpiry);
    var hasDividend = divCheck.Item1;
    var dividendAmount = divCheck.Item2;
    
    if (hasDividend) {
        // Temettü varsa, spread hesabına dahil et
        // Far fiyatı temettü kadar düşük olmalı (zaten düşmüş olabilir)
        // Uyarı ver ama pozisyon açılmasını engelleme (spread zaten ayarlanmış olmalı)
        Log("📊 NF: " + sym + " Near-Far arası temettü: " + dividendAmount.ToString("F4") + " TL/hisse");
    }
    
    var nearSym = FUTURES_PREFIX + nearC;
    var farSym = FUTURES_PREFIX + farC;
    
    // Tavan/Taban kontrolü
    // Near ALIYORUZ → Near tavan ise alınamaz
    var nearTavanFiyat = tavanFiyat.ContainsKey(nearSym) ? tavanFiyat[nearSym] : 0;
    if (nearTavanFiyat > 0) {
        var nearAskFiyat = (decimal)Sistem.AlisFiyat(nearSym);
        if (nearAskFiyat >= nearTavanFiyat) {
            Log("⚠️ NF: " + sym + " Near TAVANDA - alınamaz");
            return false;
        }
    }
    
    // Far SATIYORUZ → Far taban ise satılamaz
    var farTabanFiyat = tabanFiyat.ContainsKey(farSym) ? tabanFiyat[farSym] : 0;
    if (farTabanFiyat > 0) {
        var farBidFiyat = (decimal)Sistem.SatisFiyat(farSym);
        if (farBidFiyat <= farTabanFiyat) {
            Log("⚠️ NF: " + sym + " Far TABANDA - satılamaz");
            return false;
        }
    }
    
    Log("🔷 NF AÇILIŞ: " + sym + " Near:" + nearC + " Far:" + farC + " Qty:" + qty);
    
    // === ÖN KONTROL: Near Ask derinliği var mı? ===
    // Far SHORT açmadan ÖNCE Near'da likidite olduğundan emin ol
    // Yoksa Far'ı sattıktan sonra geri almak çok pahalı olabilir
    var preCheckNearAsk = ReadDepth(nearSym, "ASK", 0, 3, 100);
    if (!preCheckNearAsk.Item1 || preCheckNearAsk.Item2 < qty) {
        Log("⚠️ NF: " + sym + " Near Ask derinliği yetersiz (" + preCheckNearAsk.Item2 + "<" + qty + ") - işlem iptal");
        return false;
    }
    
    // === ÖNCE Far SAT (3 deneme GIE) ===
    decimal farPrice = 0;
    var farFilledQty = 0;
    
    for (int attempt = 1; attempt <= 3; attempt++) {
        var farBidResult = ReadDepth(farSym, "BID", 0, 3, 100);
        if (!farBidResult.Item1) {
            Log("⏳ Far Bid boş (deneme " + attempt + "/3)");
            if (attempt == 3) {
                Log("❌ NF: Far SAT başarısız - derinlik yok");
                return false;
            }
            System.Threading.Thread.Sleep(200);
            continue;
        }
        
        var farBid1Size = farBidResult.Item2;
        var farBid1Price = farBidResult.Item4;
        
        if (farBid1Size < qty) {
            Log("⏳ Far Bid kademe yetersiz (deneme " + attempt + "/3)");
            if (attempt == 3) {
                Log("❌ NF: Far SAT başarısız - derinlik yetersiz");
                return false;
            }
            System.Threading.Thread.Sleep(200);
            continue;
        }
        
        // Far SAT emri
        farPrice = farBid1Price;
        var farOrderId = IS_TEST ? "TEST_NF_FAR_" + DateTime.Now.Ticks : 
            Sistem.Sat(farSym, (double)farPrice, qty).ToString();
        
        if (string.IsNullOrEmpty(farOrderId) || farOrderId == "0") {
            Log("❌ NF: Far SAT emri başarısız");
            if (attempt == 3) return false;
            System.Threading.Thread.Sleep(200);
            continue;
        }
        
        // Dolum kontrolü
        System.Threading.Thread.Sleep(300);
        var farFilled = IS_TEST ? qty : (int)Sistem.GerceklesenLot(farSym);
        
        if (farFilled >= qty) {
            farFilledQty = qty;
            var farComm = CalcCommission(sym, farPrice, qty);
            Log("✅ NF Far SAT: " + farSym + " " + qty + " lot @ " + farPrice.ToString("F2") + " Kom:" + farComm.ToString("F2"));
            break;
        } else {
            // Kısmi dolum veya dolum yok - iptal et
            if (!IS_TEST) Sistem.EmirIptal(farSym);
            Log("⚠️ Far kısmi dolum: " + farFilled + "/" + qty + " (deneme " + attempt + "/3)");
            if (attempt == 3) {
                Log("❌ NF: Far SAT başarısız - dolum yok");
                return false;
            }
            System.Threading.Thread.Sleep(500);
        }
    }
    
    if (farFilledQty == 0) {
        Log("❌ NF: Far SAT başarısız");
        return false;
    }
    
    // === SONRA Near AL (3 deneme GIE) ===
    decimal nearPrice = 0;
    var nearFilledQty = 0;
    
    for (int attempt = 1; attempt <= 3; attempt++) {
        var nearAskResult = ReadDepth(nearSym, "ASK", 0, 3, 100);
        if (!nearAskResult.Item1) {
            Log("⏳ Near Ask boş (deneme " + attempt + "/3)");
            if (attempt == 3) break;
            System.Threading.Thread.Sleep(200);
            continue;
        }
        
        var nearAsk1Size = nearAskResult.Item2;
        var nearAsk1Price = nearAskResult.Item4;
        
        if (nearAsk1Size < qty) {
            Log("⏳ Near Ask kademe yetersiz (deneme " + attempt + "/3)");
            if (attempt == 3) break;
            System.Threading.Thread.Sleep(200);
            continue;
        }
        
        // Near AL emri
        nearPrice = nearAsk1Price;
        var nearOrderId = IS_TEST ? "TEST_NF_NEAR_" + DateTime.Now.Ticks :
            Sistem.Al(nearSym, (double)nearPrice, qty).ToString();
        
        if (string.IsNullOrEmpty(nearOrderId) || nearOrderId == "0") {
            Log("❌ NF: Near AL emri başarısız");
            if (attempt == 3) break;
            System.Threading.Thread.Sleep(200);
            continue;
        }
        
        // Dolum kontrolü
        System.Threading.Thread.Sleep(300);
        var nearFilled = IS_TEST ? qty : (int)Sistem.GerceklesenLot(nearSym);
        
        if (nearFilled >= qty) {
            nearFilledQty = qty;
            var nearComm = CalcCommission(sym, nearPrice, qty);
            Log("✅ NF Near AL: " + nearSym + " " + qty + " lot @ " + nearPrice.ToString("F2") + " Kom:" + nearComm.ToString("F2"));
            break;
        } else {
            // Kısmi dolum veya dolum yok - iptal et
            if (!IS_TEST) Sistem.EmirIptal(nearSym);
            Log("⚠️ Near kısmi dolum: " + nearFilled + "/" + qty + " (deneme " + attempt + "/3)");
            if (attempt == 3) break;
            System.Threading.Thread.Sleep(500);
        }
    }
    
    // Near başarısız olduysa Far'ı geri al
    if (nearFilledQty == 0) {
        Log("⚠️ NF: Near AL başarısız, Far geri alınıyor...");
        // Far'ı geri al (Far AL)
        for (int attempt = 1; attempt <= 3; attempt++) {
            var farAskResult = ReadDepth(farSym, "ASK", 0, 3, 100);
            if (farAskResult.Item1 && farAskResult.Item2 >= farFilledQty) {
                var buyBackPrice = farAskResult.Item4;
                var buyBackId = IS_TEST ? "TEST_NF_BUYBACK_" + DateTime.Now.Ticks :
                    Sistem.Al(farSym, (double)buyBackPrice, farFilledQty).ToString();
                System.Threading.Thread.Sleep(300);
                var buyBackFilled = IS_TEST ? farFilledQty : (int)Sistem.GerceklesenLot(farSym);
                if (buyBackFilled >= farFilledQty) {
                    Log("✅ NF Far geri alındı: " + farFilledQty + " lot @ " + buyBackPrice.ToString("F2"));
                    break;
                }
            }
            System.Threading.Thread.Sleep(500);
        }
        return false;
    }
    
    // Pozisyonu kaydet
    var entrySpread = CalcNFSpread(nearC, farC, nearPrice, farPrice);
    var mult = GetMultiplier(sym);
    var openComm = CalcCommission(sym, nearPrice, qty) + CalcCommission(sym, farPrice, qty);
    var expectedPnl = entrySpread * nearPrice * qty * mult - openComm * 2;
    
    nfPos[sym] = new decimal[] { 
        qty,                    // [0] nearQty
        qty,                    // [1] farQty
        nearPrice,              // [2] nearEntry
        farPrice,               // [3] farEntry
        entrySpread,            // [4] entrySpread
        expectedPnl,            // [5] expectedPnl
        DateTime.Now.Ticks      // [6] entryTicks
    };
    
    // Kontrat kodlarını sakla (vade geçişinde doğru kontratları bulmak için)
    nfContracts[sym] = new string[] { nearC, farC };
    
    // VIOP kullanımını güncelle
    var temNear = teminat.ContainsKey(sym) ? teminat[sym] : 5000m;
    var temFar = temNear;  // Far teminatı da aynı varsayılır
    nfViopUsed += temNear + temFar;
    
    Log("✅ NF AÇILDI: " + sym + " N:" + nearPrice.ToString("F2") + " F:" + farPrice.ToString("F2") + 
        " Spread:" + (entrySpread * 100).ToString("F3") + "% Beklenen:" + expectedPnl.ToString("F0"));
    
    SavePositions();
    return true;
};

// NF pozisyon kapat: Near SAT + Far AL
// GIE sırası: Önce Far AL (likit olmayan taraf), sonra Near SAT
Action<string, string, string, int, int, string> CloseNF = (sym, nearC, farC, nearQty, farQty, reason) => {
    if (!nfPos.ContainsKey(sym)) return;
    
    var nearSym = FUTURES_PREFIX + nearC;
    var farSym = FUTURES_PREFIX + farC;
    
    // Tavan/Taban kontrolü
    // Far ALIYORUZ → Far tavan ise alınamaz
    var farTavanFiyat = tavanFiyat.ContainsKey(farSym) ? tavanFiyat[farSym] : 0;
    if (farTavanFiyat > 0) {
        var farAskFiyat = (decimal)Sistem.AlisFiyat(farSym);
        if (farAskFiyat >= farTavanFiyat) {
            if (!reason.StartsWith("EXPIRY")) {
                Log("⚠️ CloseNF: " + sym + " Far TAVANDA - alınamaz, kapanış atlanıyor");
                return;
            }
        }
    }
    
    // Near SATIYORUZ → Near taban ise satılamaz
    var nearTabanFiyat = tabanFiyat.ContainsKey(nearSym) ? tabanFiyat[nearSym] : 0;
    if (nearTabanFiyat > 0) {
        var nearBidFiyat = (decimal)Sistem.SatisFiyat(nearSym);
        if (nearBidFiyat <= nearTabanFiyat) {
            if (!reason.StartsWith("EXPIRY")) {
                Log("⚠️ CloseNF: " + sym + " Near TABANDA - satılamaz, kapanış atlanıyor");
                return;
            }
        }
    }
    
    Log("🔶 NF KAPANIŞ: " + sym + " Sebep: " + reason);
    
    var p = nfPos[sym];
    var nearEntry = p[2];
    var farEntry = p[3];
    
    // === ÖN KONTROL: Near Bid derinliği var mı? ===
    // Far AL öncesi Near'da alıcı olduğundan emin ol
    // Yoksa Far'ı aldıktan sonra geri satmak pahalı olabilir
    var preCheckNearBid = ReadDepth(nearSym, "BID", 0, 3, 100);
    if (!preCheckNearBid.Item1 || preCheckNearBid.Item2 < nearQty) {
        if (!reason.StartsWith("EXPIRY")) {  // Vade günü zorla kapat
            Log("⚠️ NF: " + sym + " Near Bid derinliği yetersiz (" + preCheckNearBid.Item2 + "<" + nearQty + ") - kapanış ertelendi");
            return;
        }
    }
    
    // === ÖNCE Far AL (3 deneme GIE) ===
    decimal farPrice = 0;
    var farFilledQty = 0;
    
    for (int attempt = 1; attempt <= 3; attempt++) {
        var farAskResult = ReadDepth(farSym, "ASK", 0, 3, 100);
        if (!farAskResult.Item1 || farAskResult.Item2 < farQty) {
            Log("⏳ Far Ask yetersiz (deneme " + attempt + "/3)");
            if (attempt == 3) break;
            System.Threading.Thread.Sleep(200);
            continue;
        }
        
        farPrice = farAskResult.Item4;
        var farOrderId = IS_TEST ? "TEST_NF_CLOSE_FAR_" + DateTime.Now.Ticks :
            Sistem.Al(farSym, (double)farPrice, farQty).ToString();
        
        if (string.IsNullOrEmpty(farOrderId) || farOrderId == "0") {
            if (attempt == 3) break;
            System.Threading.Thread.Sleep(200);
            continue;
        }
        
        System.Threading.Thread.Sleep(300);
        var farFilled = IS_TEST ? farQty : (int)Sistem.GerceklesenLot(farSym);
        
        if (farFilled >= farQty) {
            farFilledQty = farQty;
            Log("✅ NF Far AL: " + farSym + " " + farQty + " lot @ " + farPrice.ToString("F2"));
            break;
        } else {
            if (!IS_TEST) Sistem.EmirIptal(farSym);
            if (attempt == 3) break;
            System.Threading.Thread.Sleep(500);
        }
    }
    
    if (farFilledQty == 0) {
        Log("❌ NF: Far AL başarısız - kapanış iptal");
        return;
    }
    
    // === SONRA Near SAT (3 deneme GIE) ===
    decimal nearPrice = 0;
    var nearFilledQty = 0;
    
    for (int attempt = 1; attempt <= 3; attempt++) {
        var nearBidResult = ReadDepth(nearSym, "BID", 0, 3, 100);
        if (!nearBidResult.Item1 || nearBidResult.Item2 < nearQty) {
            Log("⏳ Near Bid yetersiz (deneme " + attempt + "/3)");
            if (attempt == 3) break;
            System.Threading.Thread.Sleep(200);
            continue;
        }
        
        nearPrice = nearBidResult.Item4;
        var nearOrderId = IS_TEST ? "TEST_NF_CLOSE_NEAR_" + DateTime.Now.Ticks :
            Sistem.Sat(nearSym, (double)nearPrice, nearQty).ToString();
        
        if (string.IsNullOrEmpty(nearOrderId) || nearOrderId == "0") {
            if (attempt == 3) break;
            System.Threading.Thread.Sleep(200);
            continue;
        }
        
        System.Threading.Thread.Sleep(300);
        var nearFilled = IS_TEST ? nearQty : (int)Sistem.GerceklesenLot(nearSym);
        
        if (nearFilled >= nearQty) {
            nearFilledQty = nearQty;
            Log("✅ NF Near SAT: " + nearSym + " " + nearQty + " lot @ " + nearPrice.ToString("F2"));
            break;
        } else {
            if (!IS_TEST) Sistem.EmirIptal(nearSym);
            if (attempt == 3) break;
            System.Threading.Thread.Sleep(500);
        }
    }
    
    // Near başarısız olduysa Far'ı geri sat
    if (nearFilledQty == 0) {
        Log("⚠️ NF: Near SAT başarısız, Far geri satılıyor...");
        for (int attempt = 1; attempt <= 3; attempt++) {
            var farBidResult = ReadDepth(farSym, "BID", 0, 3, 100);
            if (farBidResult.Item1 && farBidResult.Item2 >= farFilledQty) {
                var sellBackPrice = farBidResult.Item4;
                var sellBackId = IS_TEST ? "TEST_NF_SELLBACK_" + DateTime.Now.Ticks :
                    Sistem.Sat(farSym, (double)sellBackPrice, farFilledQty).ToString();
                System.Threading.Thread.Sleep(300);
                Log("✅ NF Far geri satıldı");
                break;
            }
            System.Threading.Thread.Sleep(500);
        }
        return;
    }
    
    // P&L hesapla
    var mult = GetMultiplier(sym);
    var nearPnl = (nearPrice - nearEntry) * nearQty * mult;  // Near aldık, şimdi satıyoruz
    var farPnl = (farEntry - farPrice) * farQty * mult;      // Far sattık, şimdi alıyoruz
    var closeComm = CalcCommission(sym, nearPrice, nearQty) + CalcCommission(sym, farPrice, farQty);
    var totalPnl = nearPnl + farPnl - closeComm;
    
    dailyRealizedPnl += totalPnl;
    dailyTrades++;
    dailyViopCommission += closeComm;
    
    // VIOP kullanımını güncelle
    var temNear = teminat.ContainsKey(sym) ? teminat[sym] : 5000m;
    nfViopUsed -= temNear * 2;
    if (nfViopUsed < 0) nfViopUsed = 0;
    
    Log("✅ NF KAPANDI: " + sym + " P&L:" + totalPnl.ToString("F0") + " (Near:" + nearPnl.ToString("F0") + " Far:" + farPnl.ToString("F0") + ")");
    
    nfPos.Remove(sym);
    if (nfContracts.ContainsKey(sym)) nfContracts.Remove(sym);
    SavePositions();
};

// NF kapanış koşullarını kontrol et
Func<string, string, string, decimal, decimal, int, string> CheckNFClose = 
    (sym, nearC, farC, nearBid, farAsk, daysN) => {
    
    if (!nfPos.ContainsKey(sym)) return null;
    var p = nfPos[sym];
    var nearQty = (int)p[0];
    var farQty = (int)p[1];
    var nearEntry = p[2];
    var farEntry = p[3];
    var entrySpread = p[4];
    
    // Near vade sonu kontrolü (12:00 sonrası - yarım gün 12:30 kapanışına 30dk marj)
    if (daysN <= 0) {
        var expiryNow = DateTime.Now;
        var expiryMinutes = expiryNow.Hour * 60 + expiryNow.Minute;
        if (expiryMinutes >= 12 * 60) {  // 12:00 sonrası
            return "NF_EXPIRY";
        }
        return null;  // 12:00 öncesi bekle
    }
    
    // P&L hesapla (kapanış için: Near SAT @ nearBid, Far AL @ farAsk)
    var mult = GetMultiplier(sym);
    var nearPnl = (nearBid - nearEntry) * nearQty * mult;
    var farPnl = (farEntry - farAsk) * farQty * mult;
    var closeComm = CalcCommission(sym, nearBid, nearQty) + CalcCommission(sym, farAsk, farQty);
    var closePnl = nearPnl + farPnl - closeComm;
    
    // Pozisyon değeri
    var posValue = nearEntry * nearQty * mult;
    var profitPct = posValue > 0 ? closePnl / posValue : 0;
    
    // Mevcut spread
    var currentSpread = nearBid > 0 ? (farAsk - nearBid) / nearBid : 0;
    
    // BB kontrolü için spread BB pozisyonunu hesapla
    // (snBB dictionary'sinden alınabilir veya ayrı hesaplanabilir)
    var nfBBPos = snBBPos.ContainsKey(sym) ? snBBPos[sym] : 50m;  // Varsayılan orta
    
    // Çıkış koşulu 1: BB <= 27
    if (nfBBPos <= NF_EXIT_BB) {
        return "NF_BB_EXIT|" + closePnl.ToString("F0") + "|BB:" + nfBBPos.ToString("F0");
    }
    
    // Çıkış koşulu 2: Binde 3 kar
    if (profitPct >= NF_EXIT_PROFIT) {
        return "NF_PROFIT|" + closePnl.ToString("F0") + "|" + (profitPct * 1000).ToString("F1") + "‰";
    }
    
    return null;
};

// ====================================
// VERİ YÜKLEME
// ====================================
Action LoadTeminatFromFile = () => {
    try {
        if (!System.IO.File.Exists(TEMINAT_FILE)) return;
        var j = System.IO.File.ReadAllText(TEMINAT_FILE).Trim().TrimStart('{').TrimEnd('}');
        foreach (var p in j.Split(',')) {
            var kv = p.Split(':');
            if (kv.Length == 2) {
                decimal val;
                if (decimal.TryParse(kv[1].Trim(), System.Globalization.NumberStyles.Any,
                    System.Globalization.CultureInfo.InvariantCulture, out val)) {
                    var sym = kv[0].Trim().Trim('"');
                    teminat[sym] = val;
                    if (!symbols.Contains(sym)) symbols.Add(sym);
                }
            }
        }
        // VIOP_RESERVE = en yüksek teminat x (2 + 2n+1) + 5000 (SN için 2x + NF için 2n+1)
        // NF_BUDGET = en yüksek teminat x (2n+1) (Near-Far: açılış 2n + kapanış GİE 1)
        decimal maxTeminat = 0;
        foreach (var kv in teminat) {
            if (kv.Value > maxTeminat) maxTeminat = kv.Value;
        }
        var nfBudgetMultiplier = NF_MAX_POSITIONS * 2 + 1;  // 2n+1 formülü
        VIOP_RESERVE = maxTeminat * (2 + nfBudgetMultiplier) + 5000m;  // SN rezerv (2x) + NF rezerv (2n+1) + güvenlik marjı
        NF_BUDGET = maxTeminat * nfBudgetMultiplier;  // NF için ayrılmış bütçe (2n+1)
        
        // SPOT_BUDGET_RESERVE = en yüksek fiyatlı spot × 50 lot (minimum 1 pozisyon açabilme garantisi)
        decimal maxSpotPrice = 0;
        foreach (var sym in symbols) {
            try {
                var p = (decimal)Sistem.SonFiyat(SPOT_PREFIX + sym);
                if (p > maxSpotPrice) maxSpotPrice = p;
            } catch { }
        }
        SPOT_BUDGET_RESERVE = maxSpotPrice * 50m;  // 50 lot = 0.5 Near lot karşılığı
        
        Log("Teminat yüklendi: " + teminat.Count + " sembol, VIOP_RESERVE=" + VIOP_RESERVE.ToString("N0") + ", SPOT_BUDGET_RESERVE=" + SPOT_BUDGET_RESERVE.ToString("N0"));
    } catch (Exception ex) { Log("Teminat hata: " + ex.Message); }
};

Action SaveTeminatToFile = () => {
    try {
        var sb = new System.Text.StringBuilder();
        sb.Append("{");
        var first = true;
        foreach (var kv in teminat) {
            if (!first) sb.Append(",");
            first = false;
            sb.Append("\"" + kv.Key + "\":" + kv.Value.ToString(System.Globalization.CultureInfo.InvariantCulture));
        }
        sb.Append("}");
        SafeWrite(TEMINAT_FILE, sb.ToString());
        
        // Sembol listelerini oluştur (IdealData için)
        try {
            var listePath = @"D:\ideal\SembolListeleri\";
            if (!System.IO.Directory.Exists(listePath)) {
                System.IO.Directory.CreateDirectory(listePath);
            }
            
            // Near vade kodunu GetContract'tan al (THYAO için hesapla, sonra kodu çıkar)
            var sampleContract = GetContract("X", 0);  // F_X0126 gibi
            var vadeKodu = sampleContract.Substring(sampleContract.Length - 4);  // 0126
            
            var viopSb = new System.Text.StringBuilder();
            var spotSb = new System.Text.StringBuilder();
            
            // Endeks/döviz/emtia hariç sadece hisse sembolleri
            var excludeList = new System.Collections.Generic.HashSet<string> { 
                "EURTRY", "USDTRY", "X10XB", "XLBNK", "XU030", "KONTR01", "KONTR02",
                "AGUSD", "GLD", "GOZ", "EUR", "GBP", "RUB", "USD", "EUD", "XPDUSD", "XPTUSD"
            };
            
            foreach (var kv in teminat) {
                if (excludeList.Contains(kv.Key)) continue;
                if (kv.Key.Length < 3) continue;  // Geçersiz semboller
                
                viopSb.AppendLine("VIP'F_" + kv.Key + vadeKodu);
                spotSb.AppendLine("IMKBH'" + kv.Key);
            }
            
            System.IO.File.WriteAllText(listePath + "viop_liste", viopSb.ToString().TrimEnd(), System.Text.Encoding.UTF8);
            System.IO.File.WriteAllText(listePath + "spot_liste", spotSb.ToString().TrimEnd(), System.Text.Encoding.UTF8);
        } catch { }
    } catch { }
};

Action UpdateTeminatFromVIOP = () => {
    try {
        var list = Sistem.SembolAdListesi(FUTURES_PREFIX + "F_", "");
        if (list == null) return;
        
        var nearContracts = new System.Collections.Generic.Dictionary<string, string>();
        foreach (var s in list) {
            try {
                var fullSym = s.ToString();
                if (!fullSym.StartsWith(FUTURES_PREFIX + "F_")) continue;
                
                // SubMarket kontrolü - sadece pay vadeliler (19220)
                var yuz = Sistem.YuzeyselVeriOku(fullSym);
                if (yuz == null) continue;
                if (yuz.SubMarket.ToString() != "19220") continue;  // Pay vadeli değilse atla
                
                var contract = fullSym.Substring(FUTURES_PREFIX.Length);
                if (contract.Length <= 6) continue;
                var baseSym = contract.Substring(2, contract.Length - 6);
                var mmyy = contract.Substring(contract.Length - 4);
                
                if (!nearContracts.ContainsKey(baseSym)) {
                    nearContracts[baseSym] = fullSym;
                } else {
                    var existingMmyy = nearContracts[baseSym].Substring(nearContracts[baseSym].Length - 4);
                    var existingYY = int.Parse(existingMmyy.Substring(2));
                    var existingMM = int.Parse(existingMmyy.Substring(0, 2));
                    var newYY = int.Parse(mmyy.Substring(2));
                    var newMM = int.Parse(mmyy.Substring(0, 2));
                    if (newYY < existingYY || (newYY == existingYY && newMM < existingMM)) {
                        nearContracts[baseSym] = fullSym;
                    }
                }
            } catch { }
        }
        
        foreach (var kv in nearContracts) {
            try {
                var yuzeysel = Sistem.YuzeyselVeriOku(kv.Value);
                if (yuzeysel == null) continue;
                var tem = (decimal)yuzeysel.FI273;
                if (tem <= 0) continue;
                teminat[kv.Key] = tem;
                if (!symbols.Contains(kv.Key)) symbols.Add(kv.Key);
            } catch { }
        }
        
        // VIOP_RESERVE = en yüksek teminat x 5 + 5000 (SN için 2x + NF için 3x)
        // NF_BUDGET = en yüksek teminat x 3 (Near-Far: açılış 2x + kapanış GİE 1x)
        decimal maxTeminat = 0;
        foreach (var kv in teminat) {
            if (kv.Value > maxTeminat) maxTeminat = kv.Value;
        }
        var nfBudgetMultiplier = NF_MAX_POSITIONS * 2 + 1;  // 2n+1 formülü
        VIOP_RESERVE = maxTeminat * (2 + nfBudgetMultiplier) + 5000m;  // SN rezerv (2x) + NF rezerv (2n+1) + güvenlik marjı
        NF_BUDGET = maxTeminat * nfBudgetMultiplier;  // NF için ayrılmış bütçe (2n+1)
        
        // SPOT_BUDGET_RESERVE = en yüksek fiyatlı spot × 50 lot
        decimal maxSpotPrice = 0;
        foreach (var sym in symbols) {
            try {
                var p = (decimal)Sistem.SonFiyat(SPOT_PREFIX + sym);
                if (p > maxSpotPrice) maxSpotPrice = p;
            } catch { }
        }
        SPOT_BUDGET_RESERVE = maxSpotPrice * 50m;
        
        SaveTeminatToFile();
        Log("Teminat güncellendi: " + teminat.Count + " sembol, VIOP_RESERVE=" + VIOP_RESERVE.ToString("N0") + ", SPOT_BUDGET_RESERVE=" + SPOT_BUDGET_RESERVE.ToString("N0"));
    } catch (Exception ex) { Log("Teminat güncelleme hata: " + ex.Message); }
};

// Dosya bu aya ait mi kontrol et
Func<bool> IsTeminatFileCurrentMonth = () => {
    try {
        if (!System.IO.File.Exists(TEMINAT_FILE)) return false;
        var fileDate = System.IO.File.GetLastWriteTime(TEMINAT_FILE);
        var now = DateTime.Now;
        return fileDate.Year == now.Year && fileDate.Month == now.Month;
    } catch { return false; }
};

// ====================================
// PAIR TRADING FONKSİYONLARI
// ====================================

// Günlük grafik verisinden pair spread geçmişi yükle
Action LoadPairData = () => {
    if (!PAIR_ENABLED) return;
    if (PAIR_DEFS.Count == 0) return;
    
    foreach (var def in PAIR_DEFS) {
        var symA = (string)def[0];
        var symB = (string)def[1];
        var beta = (decimal)def[2];
        var pairKey = GetPairKey(symA, symB);
        
        try {
            var spotSymA = SPOT_PREFIX + symA;
            var spotSymB = SPOT_PREFIX + symB;
            
            dynamic dataA = Sistem.GrafikVerileriniOku(spotSymA, "G");
            dynamic dataB = Sistem.GrafikVerileriniOku(spotSymB, "G");
            
            if (dataA == null || dataB == null) {
                Log("⚠️ PAIR: " + pairKey + " veri yok");
                continue;
            }
            
            int countA = dataA.Count;
            int countB = dataB.Count;
            
            if (countA < 60 || countB < 60) {
                Log("⚠️ PAIR: " + pairKey + " yetersiz veri (A:" + countA + " B:" + countB + ")");
                continue;
            }
            
            // B verilerini tarihe göre dictionary'e at
            var dictB = new System.Collections.Generic.Dictionary<string, decimal>();
            for (int i = 0; i < countB; i++) {
                try {
                    dynamic bar = dataB[i];
                    DateTime dt = bar.Date;
                    decimal close = (decimal)bar.Close;
                    dictB[dt.ToString("yyyyMMdd")] = close;
                } catch { }
            }
            
            // Spread serisi oluştur
            var spreads = new System.Collections.Generic.List<decimal>();
            for (int i = 0; i < countA; i++) {
                try {
                    dynamic bar = dataA[i];
                    DateTime dt = bar.Date;
                    var key = dt.ToString("yyyyMMdd");
                    if (!dictB.ContainsKey(key)) continue;
                    
                    decimal closeA = (decimal)bar.Close;
                    var closeB = dictB[key];
                    if (closeA <= 0 || closeB <= 0) continue;
                    
                    spreads.Add(closeA - beta * closeB);
                } catch { }
            }
            
            if (spreads.Count >= 20) {
                pairSpreads[pairKey] = spreads;
                pairZScores[pairKey] = CalcZScore(spreads);
                Log("📊 PAIR: " + pairKey + " yüklendi (" + spreads.Count + " gün) Z=" + pairZScores[pairKey].ToString("F2"));
            }
        } catch (Exception ex) {
            Log("❌ PAIR: " + pairKey + " yükleme hatası: " + ex.Message);
        }
    }
    lastPairDataLoad = DateTime.Now;
};

// Canlı fiyatlarla Z-Score güncelle
Action UpdatePairZScores = () => {
    foreach (var def in PAIR_DEFS) {
        var symA = (string)def[0];
        var symB = (string)def[1];
        var beta = (decimal)def[2];
        var pairKey = GetPairKey(symA, symB);
        
        if (!pairSpreads.ContainsKey(pairKey)) continue;
        
        try {
            var yuzA = Sistem.YuzeyselVeriOku(SPOT_PREFIX + symA);
            var yuzB = Sistem.YuzeyselVeriOku(SPOT_PREFIX + symB);
            if (yuzA == null || yuzB == null) continue;
            
            var priceA = (decimal)yuzA.LastPrice;
            var priceB = (decimal)yuzB.LastPrice;
            if (priceA <= 0 || priceB <= 0) continue;
            
            var currentSpread = priceA - beta * priceB;
            
            // Geçici liste (son spread'i güncel fiyatla değiştir)
            var spreads = new System.Collections.Generic.List<decimal>(pairSpreads[pairKey]);
            if (spreads.Count > 0) spreads[spreads.Count - 1] = currentSpread;
            
            pairZScores[pairKey] = CalcZScore(spreads);
        } catch { }
    }
};

// Pair pozisyon açma (kontrollü GIE ile)
// contractOffset: 0=Near (normal), 1=Far (rollover için)
Func<int, int, bool, int, bool> OpenPair = null;
OpenPair = (pairIdx, tier, isLongA, contractOffset) => {
    if (pairIdx < 0 || pairIdx >= PAIR_DEFS.Count) return false;
    if (tier < 0 || tier >= PAIR_MAX_TIERS) return false;
    
    var def = PAIR_DEFS[pairIdx];
    var symA = (string)def[0];
    var symB = (string)def[1];
    var beta = (decimal)def[2];
    var pairKey = GetPairKey(symA, symB);
    
    // Güncel fiyatları al (lot hesabı için)
    decimal priceA = 0, priceB = 0;
    try {
        var yuzA = Sistem.YuzeyselVeriOku(SPOT_PREFIX + symA);
        var yuzB = Sistem.YuzeyselVeriOku(SPOT_PREFIX + symB);
        if (yuzA != null) priceA = (decimal)yuzA.LastPrice;
        if (yuzB != null) priceB = (decimal)yuzB.LastPrice;
    } catch { }
    
    // Lot sayısını bütçeden hesapla
    var lots = CalcPairLots(pairIdx, tier, beta, priceA, priceB);
    var lotA = lots[0];
    var lotB = lots[1];
    
    if (lotA <= 0 || lotB <= 0) {
        Log("⚠️ PAIR: " + pairKey + " kademe " + (tier + 1) + " lot hesaplanamadı");
        return false;
    }
    
    // Kontratları bul (offset: 0=Near, 1=Far)
    var nearA = GetContract(symA, contractOffset);
    var nearB = GetContract(symB, contractOffset);
    if (string.IsNullOrEmpty(nearA) || string.IsNullOrEmpty(nearB)) {
        Log("❌ PAIR: " + pairKey + " kontrat bulunamadı (offset=" + contractOffset + ")");
        return false;
    }
    
    // Teminat kontrolü
    var temA = teminat.ContainsKey(symA) ? teminat[symA] : 1000m;
    var temB = teminat.ContainsKey(symB) ? teminat[symB] : 1000m;
    var reqTeminat = (lotA * temA) + (lotB * temB);
    
    if (pairUsed + reqTeminat > PAIR_BUDGET) {
        Log("⚠️ PAIR: Bütçe yetersiz. Gerekli:" + reqTeminat.ToString("F0") + " Kullanılan:" + pairUsed.ToString("F0"));
        return false;
    }
    
    // Emir yönleri
    var sideA = isLongA ? "BUY" : "SELL";
    var sideB = isLongA ? "SELL" : "BUY";
    
    // Likidite sıralaması: Düşük teminat = az likit = önce gönder
    var aFirst = temA < temB;
    
    var firstSym = aFirst ? symA : symB;
    var firstNear = aFirst ? nearA : nearB;
    var firstSide = aFirst ? sideA : sideB;
    var firstLot = aFirst ? lotA : lotB;
    
    var secondSym = aFirst ? symB : symA;
    var secondNear = aFirst ? nearB : nearA;
    var secondSide = aFirst ? sideB : sideA;
    var secondLot = aFirst ? lotB : lotA;
    
    Log("📊 PAIR AÇILIŞ: " + pairKey + " Kademe " + (tier + 1) + 
        " | " + firstSym + " " + firstSide + " x" + firstLot + " (önce)" +
        " | " + secondSym + " " + secondSide + " x" + secondLot);
    
    if (IS_TEST) {
        // Test modunda emir gönderme
        var testPriceA = priceA > 0 ? priceA : 50m;
        var testPriceB = priceB > 0 ? priceB : 25m;
        var currentZ = pairZScores.ContainsKey(pairKey) ? pairZScores[pairKey] : 0m;
        
        // Beklenen kar hesapla (Z normale dönünce)
        var mult = GetMultiplier(symA);
        var expectedMove = Math.Abs(currentZ) * 0.5m;  // Ortalama %50 geri dönüş
        var expectedPnl = expectedMove * testPriceA * lotA * mult * 0.02m;  // Yaklaşık
        
        if (pairPos.ContainsKey(pairKey)) {
            var p = pairPos[pairKey];
            var oldQtyA = (int)p[0];
            var oldQtyB = (int)p[1];
            var newQtyA = oldQtyA + lotA;
            var newQtyB = oldQtyB + lotB;
            var oldExp = p.Length > 7 ? p[7] : 0m;
            pairPos[pairKey] = new decimal[] { newQtyA, newQtyB, p[2], p[3], p[4], tier + 1, p[6], oldExp + expectedPnl };
            Log("✅ PAIR EKLENDİ (TEST): " + pairKey + " A:" + oldQtyA + "→" + newQtyA + " B:" + oldQtyB + "→" + newQtyB);
        } else {
            pairPos[pairKey] = new decimal[] { lotA, lotB, testPriceA, testPriceB, currentZ, tier + 1, DateTime.Now.Ticks, expectedPnl };
            // Kontratları kaydet
            pairContracts[pairKey] = new string[] { nearA, nearB };
            Log("✅ PAIR AÇILDI (TEST): " + pairKey + " A:" + lotA + " B:" + lotB + " Z=" + currentZ.ToString("F2") + " [" + nearA + "/" + nearB + "]");
        }
        pairUsed += reqTeminat;
        SavePositions();
        return true;
    }
    
    // === İLK BACAK (az likit) ===
    var res1 = ExecGuar("F_" + firstNear, firstSide, firstLot);
    if (res1.Item1 <= 0) {
        Log("❌ PAIR: " + firstSym + " " + firstSide + " başarısız");
        return false;
    }
    
    // İlk bacak kısmi dolum kontrolü
    if (res1.Item1 < firstLot) {
        Log("⚠️ PAIR: " + firstSym + " kısmi dolum " + res1.Item1 + "/" + firstLot + " - geri alınıyor");
        var reverseSide1 = firstSide == "BUY" ? "SELL" : "BUY";
        ExecGuar("F_" + firstNear, reverseSide1, res1.Item1);
        return false;
    }
    
    // === İKİNCİ BACAK (3 deneme) ===
    System.Tuple<int, decimal> res2 = null;
    var success = false;
    var totalFilled2 = 0;
    
    for (int retry = 0; retry < 3; retry++) {
        var remaining = secondLot - totalFilled2;
        if (remaining <= 0) break;
        
        res2 = ExecGuar("F_" + secondNear, secondSide, remaining);
        if (res2.Item1 > 0) {
            totalFilled2 += res2.Item1;
            if (totalFilled2 >= secondLot) {
                success = true;
                break;
            }
            Log("⚠️ PAIR: " + secondSym + " kısmi dolum " + totalFilled2 + "/" + secondLot + " - deneme " + (retry + 1) + "/3");
        } else {
            Log("⚠️ PAIR: " + secondSym + " deneme " + (retry + 1) + "/3 başarısız");
        }
        System.Threading.Thread.Sleep(2000);
    }
    
    if (!success) {
        // İkinci bacak tam dolmadı - pairPendingCompletion'a ekle (30sn sonra tekrar denenecek)
        Log("⏳ PAIR: " + secondSym + " tam dolmadı (" + totalFilled2 + "/" + secondLot + ") - beklemeye alındı");
        
        // İkinci bacaktan dolan kısmı geri al (varsa)
        if (totalFilled2 > 0) {
            var reverseSide2 = secondSide == "BUY" ? "SELL" : "BUY";
            ExecGuar("F_" + secondNear, reverseSide2, totalFilled2);
        }
        
        // İlk bacağı pairPendingCompletion'a ekle
        var filledLeg = aFirst ? "A" : "B";
        pairPendingCompletion[pairKey] = new object[] {
            pairIdx,           // [0] pairIdx
            tier,              // [1] tier
            isLongA,           // [2] isLongA
            contractOffset,    // [3] contractOffset
            filledLeg,         // [4] filledLeg (A veya B)
            firstSide,         // [5] filledSide
            res1.Item1,        // [6] filledQty
            res1.Item2,        // [7] filledPrice
            firstNear,         // [8] filledContract
            DateTime.Now,      // [9] timestamp
            0                  // [10] retryCount
        };
        
        Log("📋 PAIR PENDING: " + pairKey + " " + filledLeg + " beklemeye alındı. " + PAIR_PENDING_WAIT_SEC + "sn sonra tekrar denenecek.");
        return false;
    }
    
    // Her iki bacak da tam doldu - son fiyatı al
    var finalPrice2 = res2 != null ? res2.Item2 : 0m;
    
    // Her iki bacak da tam doldu - pozisyonu kaydet
    var filledA = aFirst ? res1.Item1 : totalFilled2;
    var filledB = aFirst ? totalFilled2 : res1.Item1;
    var realPriceA = aFirst ? res1.Item2 : finalPrice2;
    var realPriceB = aFirst ? finalPrice2 : res1.Item2;
    
    var currentZScore = pairZScores.ContainsKey(pairKey) ? pairZScores[pairKey] : 0m;
    
    // Beklenen kar hesapla
    var realMult = GetMultiplier(symA);
    var realExpectedMove = Math.Abs(currentZScore) * 0.5m;
    var realExpectedPnl = realExpectedMove * realPriceA * filledA * realMult * 0.02m;
    
    if (pairPos.ContainsKey(pairKey)) {
        // Mevcut pozisyona ekle
        var p = pairPos[pairKey];
        var oldQtyA = (int)p[0];
        var oldQtyB = (int)p[1];
        var newQtyA = oldQtyA + filledA;
        var newQtyB = oldQtyB + filledB;
        if (newQtyA <= 0 || newQtyB <= 0) {
            Log("❌ PAIR: " + pairKey + " geçersiz miktar hesaplandı");
            return false;
        }
        var newAvgA = (p[2] * oldQtyA + realPriceA * filledA) / newQtyA;
        var newAvgB = (p[3] * oldQtyB + realPriceB * filledB) / newQtyB;
        var oldExp = p.Length > 7 ? p[7] : 0m;
        
        pairPos[pairKey] = new decimal[] { newQtyA, newQtyB, newAvgA, newAvgB, p[4], tier + 1, p[6], oldExp + realExpectedPnl };
        Log("✅ PAIR EKLENDİ: " + pairKey + " A:" + oldQtyA + "→" + newQtyA + " B:" + oldQtyB + "→" + newQtyB + " Kademe:" + (tier + 1));
    } else {
        // Yeni pozisyon
        pairPos[pairKey] = new decimal[] { filledA, filledB, realPriceA, realPriceB, currentZScore, tier + 1, DateTime.Now.Ticks, realExpectedPnl };
        // Kontratları kaydet (yeni pozisyon açıldığında)
        pairContracts[pairKey] = new string[] { nearA, nearB };
        Log("✅ PAIR AÇILDI: " + pairKey + " A:" + filledA + "@" + realPriceA.ToString("F2") + " B:" + filledB + "@" + realPriceB.ToString("F2") + " Z=" + currentZScore.ToString("F2") + " [" + nearA + "/" + nearB + "]");
    }
    
    // Teminat ve komisyon
    pairUsed += (filledA * temA) + (filledB * temB);
    dailyViopCommission += CalcCommission(symA, realPriceA, filledA) + CalcCommission(symB, realPriceB, filledB);
    
    SavePositions();
    return true;
};

// Pair pozisyon kapatma
Func<int, bool> ClosePair = (pairIdx) => {
    if (pairIdx < 0 || pairIdx >= PAIR_DEFS.Count) return false;
    
    var def = PAIR_DEFS[pairIdx];
    var symA = (string)def[0];
    var symB = (string)def[1];
    var pairKey = GetPairKey(symA, symB);
    
    if (!pairPos.ContainsKey(pairKey)) return false;
    
    var p = pairPos[pairKey];
    var qtyA = (int)p[0];
    var qtyB = (int)p[1];
    var avgA = p[2];
    var avgB = p[3];
    var openZ = p[4];
    
    // Kontratları pairContracts'tan al (yoksa fallback olarak GetContract kullan)
    var nearA = pairContracts.ContainsKey(pairKey) ? pairContracts[pairKey][0] : GetContract(symA, 0);
    var nearB = pairContracts.ContainsKey(pairKey) ? pairContracts[pairKey][1] : GetContract(symB, 0);
    if (string.IsNullOrEmpty(nearA) || string.IsNullOrEmpty(nearB)) return false;
    
    // Pozisyon yönü (openZ'ye göre)
    var isLongA = openZ < 0;
    var sideA = isLongA ? "SELL" : "BUY";
    var sideB = isLongA ? "BUY" : "SELL";
    
    Log("📊 PAIR KAPANIŞ: " + pairKey + " | " + symA + " " + sideA + " x" + qtyA + " | " + symB + " " + sideB + " x" + qtyB + " [" + nearA + "/" + nearB + "]");
    
    // Teminat serbest (pozisyon silinmeden önce hesapla)
    var temA = teminat.ContainsKey(symA) ? teminat[symA] : 1000m;
    var temB = teminat.ContainsKey(symB) ? teminat[symB] : 1000m;
    
    if (IS_TEST) {
        // Test modunda
        var currentZ = pairZScores.ContainsKey(pairKey) ? pairZScores[pairKey] : 0m;
        Log("✅ PAIR KAPANDI (TEST): " + pairKey + " | Z: " + openZ.ToString("F2") + " → " + currentZ.ToString("F2"));
        
        pairUsed -= (qtyA * temA) + (qtyB * temB);
        if (pairUsed < 0) pairUsed = 0;
        pairPos.Remove(pairKey);
        if (pairContracts.ContainsKey(pairKey)) pairContracts.Remove(pairKey);
        totalClosedPair++;
        SavePositions();
        return true;
    }
    
    // Kapanış emirleri - A bacağı
    var resA = ExecGuar("F_" + nearA, sideA, qtyA);
    if (resA.Item1 <= 0) {
        Log("❌ PAIR KAPAT: " + symA + " başarısız");
        return false;
    }
    
    // A kısmi dolum kontrolü
    if (resA.Item1 < qtyA) {
        Log("⚠️ PAIR KAPAT: " + symA + " kısmi dolum " + resA.Item1 + "/" + qtyA + " - kalan denenecek");
        // Kalan kısmı tekrar dene
        var remainingA = qtyA - resA.Item1;
        for (int retry = 0; retry < 2; retry++) {
            System.Threading.Thread.Sleep(2000);
            var resA2 = ExecGuar("F_" + nearA, sideA, remainingA);
            if (resA2.Item1 > 0) {
                resA = System.Tuple.Create(resA.Item1 + resA2.Item1, (resA.Item2 * resA.Item1 + resA2.Item2 * resA2.Item1) / (resA.Item1 + resA2.Item1));
                remainingA -= resA2.Item1;
                if (remainingA <= 0) break;
            }
        }
        if (remainingA > 0) {
            Log("⚠️ PAIR KAPAT: " + symA + " tam kapatılamadı! Kalan: " + remainingA);
        }
    }
    
    // B bacağı - 3 deneme ile tam dolum hedefi
    var totalFilledB = 0;
    decimal avgPriceB = 0;
    
    for (int retry = 0; retry < 3; retry++) {
        var remaining = qtyB - totalFilledB;
        if (remaining <= 0) break;
        
        var resB = ExecGuar("F_" + nearB, sideB, remaining);
        if (resB.Item1 > 0) {
            avgPriceB = (avgPriceB * totalFilledB + resB.Item2 * resB.Item1) / (totalFilledB + resB.Item1);
            totalFilledB += resB.Item1;
            if (totalFilledB >= qtyB) break;
            Log("⚠️ PAIR KAPAT: " + symB + " kısmi " + totalFilledB + "/" + qtyB + " - deneme " + (retry + 1) + "/3");
        } else {
            Log("⚠️ PAIR KAPAT: " + symB + " deneme " + (retry + 1) + "/3 başarısız");
        }
        System.Threading.Thread.Sleep(2000);
    }
    
    if (totalFilledB <= 0) {
        Log("⏳ PAIR KAPAT: " + symB + " hiç dolmadı - beklemeye alınıyor");
        
        // A kapatıldı, B beklemede - pairPendingCompletion'a ekle
        pairPendingCompletion[pairKey + "_CLOSE"] = new object[] {
            pairIdx,           // [0] pairIdx
            -1,                // [1] tier (-1 = kapanış modu)
            isLongA,           // [2] isLongA
            0,                 // [3] contractOffset (kullanılmıyor)
            "A_CLOSED",        // [4] filledLeg (A kapatıldı, B bekliyor)
            sideB,             // [5] B'nin kapanış yönü
            qtyB,              // [6] B'nin miktarı
            resA.Item2,        // [7] A'nın kapanış fiyatı (P&L hesabı için)
            nearB,             // [8] B'nin kontratı
            DateTime.Now,      // [9] timestamp
            0,                 // [10] retryCount
            qtyA,              // [11] A'nın miktarı
            resA.Item1,        // [12] A'nın dolan miktarı
            avgA,              // [13] A giriş fiyatı
            avgB,              // [14] B giriş fiyatı
            nearA,             // [15] A kontratı
            symA,              // [16] sembol A
            symB,              // [17] sembol B
            openZ              // [18] açılış Z-Score
        };
        
        Log("📋 PAIR PENDING CLOSE: " + pairKey + " B beklemeye alındı. " + PAIR_PENDING_WAIT_SEC + "sn sonra tekrar denenecek.");
        return false;
    }
    
    if (totalFilledB < qtyB) {
        Log("⚠️ PAIR KAPAT: " + symB + " kısmi kapatıldı " + totalFilledB + "/" + qtyB + " - kalan açık!");
    }
    
    // P&L hesapla (dolan miktarlar üzerinden)
    var mult = GetMultiplier(symA);
    decimal pnlA, pnlB;
    
    if (isLongA) {
        pnlA = (resA.Item2 - avgA) * resA.Item1 * mult;
        pnlB = (avgB - avgPriceB) * totalFilledB * mult;
    } else {
        pnlA = (avgA - resA.Item2) * resA.Item1 * mult;
        pnlB = (avgPriceB - avgB) * totalFilledB * mult;
    }
    
    var totalPnl = pnlA + pnlB;
    var commA = CalcCommission(symA, resA.Item2, resA.Item1);
    var commB = CalcCommission(symB, avgPriceB, totalFilledB);
    totalPnl -= (commA + commB);
    
    dailyRealizedPnl += totalPnl;
    dailyPairPnl += totalPnl;
    dailyViopCommission += commA + commB;
    
    // Teminat serbest - sadece kapatılan miktarlar için
    var freedTeminat = (resA.Item1 * temA) + (totalFilledB * temB);
    pairUsed -= freedTeminat;
    if (pairUsed < 0) pairUsed = 0;
    
    // Kısmi kapanış mı tam kapanış mı?
    var fullyClosedA = resA.Item1 >= qtyA;
    var fullyClosedB = totalFilledB >= qtyB;
    
    var currentZFinal = pairZScores.ContainsKey(pairKey) ? pairZScores[pairKey] : 0m;
    
    if (fullyClosedA && fullyClosedB) {
        Log("✅ PAIR KAPANDI: " + pairKey + " P&L:" + totalPnl.ToString("F0") + " TL | Z: " + openZ.ToString("F2") + " → " + currentZFinal.ToString("F2"));
        pairPos.Remove(pairKey);
        if (pairContracts.ContainsKey(pairKey)) pairContracts.Remove(pairKey);
    } else {
        // Kısmi kapanış - kalan miktarları güncelle
        var remainingA = qtyA - resA.Item1;
        var remainingB = qtyB - totalFilledB;
        Log("⚠️ PAIR KISMİ KAPANDI: " + pairKey + " P&L:" + totalPnl.ToString("F0") + " TL | Kalan A:" + remainingA + " B:" + remainingB);
        
        if (remainingA > 0 || remainingB > 0) {
            // Pozisyonu güncelle (kalan miktarlarla)
            pairPos[pairKey] = new decimal[] { remainingA, remainingB, avgA, avgB, openZ, p[5], p[6], p.Length > 7 ? p[7] : 0m };
        } else {
            pairPos.Remove(pairKey);
            if (pairContracts.ContainsKey(pairKey)) pairContracts.Remove(pairKey);
        }
    }
    totalClosedPair++;
    
    SavePositions();
    if (SaveDailyStats != null) SaveDailyStats();
    return true;
};

// Pair Pending Completion kontrolü - tek bacak açık kalmış emirleri tamamlamaya çalışır
Action CheckPairPending = () => {
    if (pairPendingCompletion.Count == 0) return;
    if (!isMarketOpen || isPaused || !apiDataOk) return;
    
    var toRemove = new System.Collections.Generic.List<string>();
    
    foreach (var kv in pairPendingCompletion) {
        try {
            var pendingKey = kv.Key;
            var data = kv.Value;
            var pairIdx = (int)data[0];
            var tier = (int)data[1];
            var isLongA = (bool)data[2];
            var contractOffset = (int)data[3];
            var filledLeg = (string)data[4];
            var filledSide = (string)data[5];
            var filledQty = (int)data[6];
            var filledPrice = (decimal)data[7];
            var filledContract = (string)data[8];
            var timestamp = (DateTime)data[9];
            var retryCount = (int)data[10];
            
            var waitSec = (DateTime.Now - timestamp).TotalSeconds;
            
            // Henüz bekleme süresi dolmadı
            if (waitSec < PAIR_PENDING_WAIT_SEC) continue;
            
            // KAPANIŞ MODU (tier == -1)
            if (tier == -1) {
                // Kapanış modunda ek veriler
                var closeQtyA = (int)data[11];
                var closeFilledA = (int)data[12];
                var closeAvgA = (decimal)data[13];
                var closeAvgB = (decimal)data[14];
                var closeNearA = (string)data[15];
                var closeSymA = (string)data[16];
                var closeSymB = (string)data[17];
                var closeOpenZ = (decimal)data[18];
                var closePairKey = pendingKey.Replace("_CLOSE", "");
                
                // Max retry aşıldı - Recovery'ye bırak
                if (retryCount >= PAIR_PENDING_MAX_RETRY) {
                    Log("❌ PAIR PENDING CLOSE: " + closePairKey + " max retry aşıldı - Recovery'ye bırakılıyor");
                    // pairPos'u güncelle (A kapatıldı, B hala açık)
                    if (pairPos.ContainsKey(closePairKey)) {
                        var oldPos = pairPos[closePairKey];
                        var remainingA = closeQtyA - closeFilledA;
                        pairPos[closePairKey] = new decimal[] { remainingA, filledQty, closeAvgA, closeAvgB, closeOpenZ, oldPos[5], oldPos[6], oldPos.Length > 7 ? oldPos[7] : 0m };
                        Log("⚠️ PAIR PENDING CLOSE: " + closePairKey + " pairPos güncellendi. Kalan A:" + remainingA + " B:" + filledQty);
                        SavePositions();
                    }
                    toRemove.Add(pendingKey);
                    continue;
                }
                
                // B bacağını tekrar dene
                Log("🔄 PAIR PENDING CLOSE: " + closePairKey + " B tekrar deneniyor (retry " + (retryCount + 1) + "/" + PAIR_PENDING_MAX_RETRY + ")");
                
                var closeDepthType = filledSide == "BUY" ? "ASK" : "BID";
                var closeResult = ReadDepth(FUTURES_PREFIX + filledContract, closeDepthType, 0, 3, 100);
                
                if (closeResult.Item1 && closeResult.Item2 >= filledQty) {
                    var closePrice = closeResult.Item4;
                    var closeOrderId = IS_TEST ? "TEST_PAIR_CLOSE_RETRY_" + DateTime.Now.Ticks :
                        (filledSide == "BUY" ? Sistem.Al(FUTURES_PREFIX + filledContract, (double)closePrice, filledQty) :
                                               Sistem.Sat(FUTURES_PREFIX + filledContract, (double)closePrice, filledQty)).ToString();
                    
                    System.Threading.Thread.Sleep(300);
                    var closeFilled = IS_TEST ? filledQty : (int)Sistem.GerceklesenLot(FUTURES_PREFIX + filledContract);
                    
                    if (closeFilled >= filledQty) {
                        // Başarılı! P&L hesapla ve pozisyonu kapat
                        Log("✅ PAIR PENDING CLOSE: " + closePairKey + " B tamamlandı! " + filledQty + " lot @ " + closePrice.ToString("F2"));
                        
                        var mult = GetMultiplier(closeSymA);
                        decimal pnlA, pnlB;
                        
                        if (isLongA) {
                            pnlA = (filledPrice - closeAvgA) * closeFilledA * mult;  // filledPrice = A kapanış fiyatı
                            pnlB = (closeAvgB - closePrice) * closeFilled * mult;
                        } else {
                            pnlA = (closeAvgA - filledPrice) * closeFilledA * mult;
                            pnlB = (closePrice - closeAvgB) * closeFilled * mult;
                        }
                        
                        var totalPnl = pnlA + pnlB;
                        var commA = CalcCommission(closeSymA, filledPrice, closeFilledA);
                        var commB = CalcCommission(closeSymB, closePrice, closeFilled);
                        totalPnl -= (commA + commB);
                        
                        dailyRealizedPnl += totalPnl;
                        dailyPairPnl += totalPnl;
                        dailyViopCommission += commA + commB;
                        
                        // Teminat serbest
                        var temA = teminat.ContainsKey(closeSymA) ? teminat[closeSymA] : 1000m;
                        var temB = teminat.ContainsKey(closeSymB) ? teminat[closeSymB] : 1000m;
                        var freedTeminat = (closeFilledA * temA) + (closeFilled * temB);
                        pairUsed -= freedTeminat;
                        if (pairUsed < 0) pairUsed = 0;
                        
                        Log("✅ PAIR KAPANDI (PENDING): " + closePairKey + " P&L:" + totalPnl.ToString("F0") + " TL");
                        
                        pairPos.Remove(closePairKey);
                        if (pairContracts.ContainsKey(closePairKey)) pairContracts.Remove(closePairKey);
                        totalClosedPair++;
                        
                        SavePositions();
                        if (SaveDailyStats != null) SaveDailyStats();
                        toRemove.Add(pendingKey);
                    } else {
                        // Yine başarısız
                        Log("⚠️ PAIR PENDING CLOSE: " + closePairKey + " B yine dolmadı (" + closeFilled + "/" + filledQty + ")");
                        if (!IS_TEST) Sistem.EmirIptal(FUTURES_PREFIX + filledContract);
                        data[9] = DateTime.Now;
                        data[10] = retryCount + 1;
                    }
                } else {
                    // Derinlik yok
                    Log("⏳ PAIR PENDING CLOSE: " + closePairKey + " B derinlik yetersiz, bekleniyor...");
                    data[9] = DateTime.Now;
                    data[10] = retryCount + 1;
                }
                continue;
            }
            
            // AÇILIŞ MODU (tier >= 0)
            var def = PAIR_DEFS[pairIdx];
            var symA = (string)def[0];
            var symB = (string)def[1];
            var pairKey = GetPairKey(symA, symB);
            
            // Max retry aşıldı - geri kapat
            if (retryCount >= PAIR_PENDING_MAX_RETRY) {
                Log("⚠️ PAIR PENDING: " + pairKey + " max retry aşıldı (" + retryCount + ") - geri kapatılıyor");
                
                // Açık bacağı geri kapat
                var reverseSide = filledSide == "BUY" ? "SELL" : "BUY";
                var reverseDepthType = reverseSide == "BUY" ? "ASK" : "BID";
                var reverseResult = ReadDepth(FUTURES_PREFIX + filledContract, reverseDepthType, 0, 3, 100);
                
                if (reverseResult.Item1 && reverseResult.Item2 >= filledQty) {
                    var reversePrice = reverseResult.Item4;
                    var reverseOrderId = IS_TEST ? "TEST_PAIR_REVERSE_" + DateTime.Now.Ticks :
                        (reverseSide == "BUY" ? Sistem.Al(FUTURES_PREFIX + filledContract, (double)reversePrice, filledQty) :
                                                Sistem.Sat(FUTURES_PREFIX + filledContract, (double)reversePrice, filledQty)).ToString();
                    
                    System.Threading.Thread.Sleep(300);
                    var reverseFilled = IS_TEST ? filledQty : (int)Sistem.GerceklesenLot(FUTURES_PREFIX + filledContract);
                    
                    if (reverseFilled >= filledQty) {
                        var slippage = filledSide == "BUY" ? (reversePrice - filledPrice) : (filledPrice - reversePrice);
                        var loss = slippage * filledQty * 100;  // Yaklaşık zarar
                        Log("✅ PAIR PENDING: " + pairKey + " " + filledLeg + " geri kapatıldı. Slippage:" + slippage.ToString("F2") + " Zarar:" + loss.ToString("F0"));
                        toRemove.Add(pendingKey);
                    } else {
                        Log("❌ PAIR PENDING: " + pairKey + " geri kapatma başarısız - Recovery'ye bırakılıyor");
                        toRemove.Add(pendingKey);
                    }
                } else {
                    Log("❌ PAIR PENDING: " + pairKey + " geri kapatma için derinlik yok - Recovery'ye bırakılıyor");
                    toRemove.Add(pendingKey);
                }
                continue;
            }
            
            // Z-Score hala uygun mu kontrol et
            var currentZ = pairZScores.ContainsKey(pairKey) ? pairZScores[pairKey] : 0m;
            var absZ = Math.Abs(currentZ);
            
            // Giriş için Z-Score hala yeterli mi?
            var minZ = tier == 0 ? PAIR_Z_ENTRY_1 : tier == 1 ? PAIR_Z_ENTRY_2 : PAIR_Z_ENTRY_3;
            if (absZ < minZ - 0.2m) {  // 0.2 tolerans
                Log("⚠️ PAIR PENDING: " + pairKey + " Z-Score düştü (" + currentZ.ToString("F2") + " < " + minZ.ToString("F1") + ") - geri kapatılıyor");
                retryCount = PAIR_PENDING_MAX_RETRY;  // Max retry'a set et, yukarıdaki blok kapatacak
                data[10] = retryCount;
                continue;
            }
            
            // İkinci bacağı tekrar dene
            Log("🔄 PAIR PENDING: " + pairKey + " ikinci bacak tekrar deneniyor (retry " + (retryCount + 1) + "/" + PAIR_PENDING_MAX_RETRY + ")");
            
            var secondLeg = filledLeg == "A" ? "B" : "A";
            var secondSym = secondLeg == "A" ? symA : symB;
            var secondSide = secondLeg == "A" ? (isLongA ? "BUY" : "SELL") : (isLongA ? "SELL" : "BUY");
            var secondContract = GetContract(secondSym, contractOffset);
            
            // Lot hesapla (ilk bacaktan orantılı)
            var beta = (decimal)def[2];
            var secondQty = filledLeg == "A" ? (int)Math.Round(filledQty * beta) : (int)Math.Round(filledQty / beta);
            if (secondQty <= 0) secondQty = 1;
            
            var secondDepthType = secondSide == "BUY" ? "ASK" : "BID";
            var secondResult = ReadDepth(FUTURES_PREFIX + secondContract, secondDepthType, 0, 3, 100);
            
            if (secondResult.Item1 && secondResult.Item2 >= secondQty) {
                var secondPrice = secondResult.Item4;
                var secondOrderId = IS_TEST ? "TEST_PAIR_RETRY_" + DateTime.Now.Ticks :
                    (secondSide == "BUY" ? Sistem.Al(FUTURES_PREFIX + secondContract, (double)secondPrice, secondQty) :
                                           Sistem.Sat(FUTURES_PREFIX + secondContract, (double)secondPrice, secondQty)).ToString();
                
                System.Threading.Thread.Sleep(300);
                var secondFilled = IS_TEST ? secondQty : (int)Sistem.GerceklesenLot(FUTURES_PREFIX + secondContract);
                
                if (secondFilled >= secondQty) {
                    // Başarılı! Pozisyonu kaydet
                    Log("✅ PAIR PENDING: " + pairKey + " " + secondLeg + " tamamlandı! " + secondQty + " lot @ " + secondPrice.ToString("F2"));
                    
                    var qtyA = filledLeg == "A" ? filledQty : secondFilled;
                    var qtyB = filledLeg == "B" ? filledQty : secondFilled;
                    var avgA = filledLeg == "A" ? filledPrice : secondPrice;
                    var avgB = filledLeg == "B" ? filledPrice : secondPrice;
                    
                    var temA = teminat.ContainsKey(symA) ? teminat[symA] : 1000m;
                    var temB = teminat.ContainsKey(symB) ? teminat[symB] : 1000m;
                    
                    // Pozisyon zaten var mı? (kademe ekleme)
                    if (pairPos.ContainsKey(pairKey)) {
                        var existingPos = pairPos[pairKey];
                        var existingQtyA = (int)existingPos[0];
                        var existingQtyB = (int)existingPos[1];
                        var existingAvgA = existingPos[2];
                        var existingAvgB = existingPos[3];
                        var existingTier = (int)existingPos[5];
                        
                        // Ortalama hesapla
                        var newQtyA = existingQtyA + qtyA;
                        var newQtyB = existingQtyB + qtyB;
                        var newAvgA = (existingAvgA * existingQtyA + avgA * qtyA) / newQtyA;
                        var newAvgB = (existingAvgB * existingQtyB + avgB * qtyB) / newQtyB;
                        var newTier = existingTier + 1;
                        
                        pairPos[pairKey] = new decimal[] { newQtyA, newQtyB, newAvgA, newAvgB, currentZ, newTier, existingPos[6], 0 };
                        pairUsed += (qtyA * temA) + (qtyB * temB);
                        Log("📊 PAIR PENDING: " + pairKey + " kademe " + newTier + " eklendi. A:" + newQtyA + " B:" + newQtyB);
                    } else {
                        // Yeni pozisyon
                        pairPos[pairKey] = new decimal[] { qtyA, qtyB, avgA, avgB, currentZ, tier, DateTime.Now.Ticks, 0 };
                        pairContracts[pairKey] = new string[] { 
                            filledLeg == "A" ? filledContract : secondContract,
                            filledLeg == "B" ? filledContract : secondContract 
                        };
                        pairUsed += (qtyA * temA) + (qtyB * temB);
                        Log("📊 PAIR PENDING: " + pairKey + " yeni pozisyon açıldı. A:" + qtyA + " B:" + qtyB);
                    }
                    
                    SavePositions();
                    toRemove.Add(pendingKey);
                } else {
                    // Yine başarısız - retry sayısını artır, timestamp güncelle
                    Log("⚠️ PAIR PENDING: " + pairKey + " " + secondLeg + " yine dolmadı (" + secondFilled + "/" + secondQty + ")");
                    if (!IS_TEST) Sistem.EmirIptal(FUTURES_PREFIX + secondContract);
                    data[9] = DateTime.Now;
                    data[10] = retryCount + 1;
                }
            } else {
                // Derinlik yok - bekle
                Log("⏳ PAIR PENDING: " + pairKey + " " + secondLeg + " derinlik yetersiz, bekleniyor...");
                data[9] = DateTime.Now;
                data[10] = retryCount + 1;
            }
        } catch (Exception ex) {
            Log("❌ PAIR PENDING hata: " + kv.Key + " - " + ex.Message);
        }
    }
    
    foreach (var key in toRemove) {
        pairPendingCompletion.Remove(key);
    }
};

// Pair sinyal kontrolü
Action CheckPairSignals = () => {
    if (!PAIR_ENABLED || !isMarketOpen || isPaused || !apiDataOk) return;
    if (PAIR_DEFS.Count == 0) return;  // Çift tanımı yoksa çık
    
    var now = DateTime.Now;
    
    // Saat kontrolü
    var pairTimeOk = (now.Hour > PAIR_START_HOUR || (now.Hour == PAIR_START_HOUR && now.Minute >= PAIR_START_MIN)) &&
                     (now.Hour < PAIR_END_HOUR || (now.Hour == PAIR_END_HOUR && now.Minute <= PAIR_END_MIN));
    
    // Günlük veri yükleme (gün değişimi veya ilk çalışma)
    if (lastPairDataLoad.Date != now.Date || pairSpreads.Count == 0) {
        Log("📊 PAIR: Günlük veri yükleniyor...");
        LoadPairData();
    }
    
    // Z-Score güncelle (canlı fiyatlarla)
    UpdatePairZScores();
    
    // ========== ENDEKS DEVRE KESİCİ - TÜM PAIR POZLARI KAPAT ==========
    if (indexCircuitBreaker && pairPos.Count > 0) {
        Log("🚨 PAIR: ENDEKS DEVRE KESİCİ - Tüm pair pozisyonları kapatılıyor!");
        for (int i = 0; i < PAIR_DEFS.Count; i++) {
            var def = PAIR_DEFS[i];
            var pairKey = GetPairKey((string)def[0], (string)def[1]);
            if (pairPos.ContainsKey(pairKey)) {
                ClosePair(i);
            }
        }
        return;  // Bu döngüde başka işlem yapma
    }
    
    // Her çift için sinyal kontrolü
    for (int i = 0; i < PAIR_DEFS.Count; i++) {
        var def = PAIR_DEFS[i];
        var symA = (string)def[0];
        var symB = (string)def[1];
        var beta = (decimal)def[2];
        var pairKey = GetPairKey(symA, symB);
        
        if (!pairZScores.ContainsKey(pairKey)) continue;
        
        var z = pairZScores[pairKey];
        var absZ = Math.Abs(z);
        var hasPos = pairPos.ContainsKey(pairKey);
        var currentTier = hasPos ? (int)pairPos[pairKey][5] : 0;
        
        // ========== DEVRE KESİCİ KONTROLÜ (çift bazlı) ==========
        if (hasPos && IsPairCircuitBreaker(symA, symB)) {
            Log("🚨 PAIR: " + pairKey + " DEVRE KESİCİ - Pozisyon kapatılıyor!");
            ClosePair(i);
            continue;
        }
        
        // ========== ROLLOVER KONTROLÜ (vade son 2 gün) ==========
        if (hasPos) {
            // Mevcut kontratları al (pairContracts'tan veya GetContract(0)'dan)
            var currentContracts = pairContracts.ContainsKey(pairKey) ? pairContracts[pairKey] : new string[] { GetContract(symA, 0), GetContract(symB, 0) };
            var currentNearA = currentContracts[0];
            var currentNearB = currentContracts[1];
            var daysA = GetDays(currentNearA);
            var daysB = GetDays(currentNearB);
            var minDays = Math.Min(daysA, daysB);
            
            if (minDays <= 2) {
                Log("🔄 PAIR ROLLOVER: " + pairKey + " vade son " + minDays + " gün [" + currentNearA + "/" + currentNearB + "]");
                var pos = pairPos[pairKey];
                var openZ = pos[4];
                var tier = (int)pos[5];
                var isLongA = openZ < 0;
                
                // Sonraki vade kontratlarını kontrol et (Far = offset 1)
                var nextNearA = GetContract(symA, 1);
                var nextNearB = GetContract(symB, 1);
                if (string.IsNullOrEmpty(nextNearA) || string.IsNullOrEmpty(nextNearB)) {
                    Log("⚠️ PAIR ROLLOVER: " + pairKey + " sonraki vade kontratı bulunamadı!");
                    continue;
                }
                Log("🔄 PAIR ROLLOVER: " + pairKey + " yeni kontratlar: [" + nextNearA + "/" + nextNearB + "]");
                
                // Önce kapat (mevcut kontratlarla)
                if (ClosePair(i)) {
                    // Sonra yeni vade ile aç (contractOffset=1 ile Far kontrata gir)
                    Log("🔄 PAIR ROLLOVER: " + pairKey + " yeni vade ile açılıyor (Kademe " + tier + ")");
                    for (int t = 0; t < tier; t++) {
                        if (!OpenPair(i, t, isLongA, 1)) break;  // offset=1 ile Far kontrat
                    }
                }
                continue;
            }
        }
        
        // ========== ÇIKIŞ KONTROLÜ ==========
        if (hasPos) {
            var openZ = pairPos[pairKey][4];
            var shouldExit = false;
            
            // Z normale döndü mü?
            if (openZ < 0 && z > -PAIR_Z_EXIT) shouldExit = true;
            else if (openZ > 0 && z < PAIR_Z_EXIT) shouldExit = true;
            
            if (shouldExit) {
                // Çıkışta isLongA'nın tersi gerekiyor (pozisyon kapatma = ters işlem)
                var wasLongA = openZ < 0;
                
                // Taban/tavan kontrolü - çıkış için ters yön
                if (IsPairLimitBlocked(symA, symB, !wasLongA)) {
                    Log("⚠️ PAIR: " + pairKey + " taban/tavan engeli - çıkış ertelendi");
                    continue;
                }
                
                Log("📉 PAIR ÇIKIŞ SİNYALİ: " + pairKey + " Z=" + z.ToString("F2") + " (Giriş:" + openZ.ToString("F2") + ")");
                ClosePair(i);
                continue;
            }
        }
        
        // ========== GİRİŞ KONTROLÜ ==========
        if (!pairTimeOk) continue;
        if (hasPos && currentTier >= PAIR_MAX_TIERS) continue;
        
        // Devre kesicideyse yeni pozisyon açma
        if (IsPairCircuitBreaker(symA, symB)) continue;
        
        // AÇILIŞ VOLATİLİTESİ KORUMASI: 10:05'e kadar yeni giriş yapma
        if (!IsAfterOpeningVolatility()) continue;
        
        // TEMETTÜ GÜNÜ KORUMASI: Anlık fiyatla Z-Score hesabı güvenilmez
        if (IsDividendDay(symA) || IsDividendDay(symB)) {
            if (!hasPos) {  // Sadece yeni giriş için log
                Log("⚠️ PAIR: " + pairKey + " temettü günü - giriş atlandı (Z-Score güvenilmez)");
            }
            continue;
        }
        
        // SERMAYE ARTIRIMI KORUMASI: Bugün veya 7 gün içinde sermaye artırımı varsa atla
        if (IsSermayeArtirimiBlocked(symA) || IsSermayeArtirimiBlocked(symB)) {
            if (!hasPos) Log("⛔ PAIR: " + pairKey + " sermaye artırımı - giriş atlandı");
            continue;
        }
        
        var shouldEnter = false;
        var targetTier = 0;
        var isLongAEntry = false;
        
        // Z < -2: A ucuz, B pahalı → A LONG, B SHORT
        if (z < -PAIR_Z_ENTRY_1) {
            isLongAEntry = true;
            if (z < -PAIR_Z_ENTRY_3 && currentTier < 3) targetTier = 3;
            else if (z < -PAIR_Z_ENTRY_2 && currentTier < 2) targetTier = 2;
            else if (currentTier < 1) targetTier = 1;
            if (targetTier > currentTier) shouldEnter = true;
        }
        // Z > +2: A pahalı, B ucuz → A SHORT, B LONG
        else if (z > PAIR_Z_ENTRY_1) {
            isLongAEntry = false;
            if (z > PAIR_Z_ENTRY_3 && currentTier < 3) targetTier = 3;
            else if (z > PAIR_Z_ENTRY_2 && currentTier < 2) targetTier = 2;
            else if (currentTier < 1) targetTier = 1;
            if (targetTier > currentTier) shouldEnter = true;
        }
        
        if (shouldEnter) {
            // Taban/tavan kontrolü - emir göndermeden önce
            if (IsPairLimitBlocked(symA, symB, isLongAEntry)) {
                Log("⚠️ PAIR: " + pairKey + " taban/tavan engeli - giriş iptal");
                continue;
            }
            
            Log("📈 PAIR GİRİŞ SİNYALİ: " + pairKey + " Z=" + z.ToString("F2") + " | Kademe " + currentTier + " → " + targetTier);
            
            // Eksik kademeleri sırayla aç (offset=0, normal Near kontrat)
            for (int t = currentTier; t < targetTier; t++) {
                if (!OpenPair(i, t, isLongAEntry, 0)) break;
            }
        }
    }
};

// ====================================
// STATS HISTORY - Haftalık/Aylık/Yıllık İstatistikler
// ====================================
var statsHistory = new System.Collections.Generic.Dictionary<string, decimal[]>();
// Her gün için: [snPnl, viopComm, spotComm, closedCount]

Action LoadStatsHistory = () => {
    try {
        if (!System.IO.File.Exists(STATS_HISTORY_FILE)) return;
        var json = System.IO.File.ReadAllText(STATS_HISTORY_FILE);
        var entries = json.Trim('{', '}', ' ', '\n', '\r').Split(new[] { "}," }, StringSplitOptions.RemoveEmptyEntries);
        
        foreach (var entry in entries) {
            try {
                var parts = entry.Split(new[] { ":{" }, StringSplitOptions.None);
                if (parts.Length < 2) continue;
                var date = parts[0].Trim().Trim('"', ' ', '\n', '\r');
                var values = parts[1].Replace("}", "");
                
                var snPnl = 0m; var viopComm = 0m; var spotComm = 0m; var closedCount = 0m;
                foreach (var kv in values.Split(',')) {
                    var pair = kv.Split(':');
                    if (pair.Length != 2) continue;
                    var key = pair[0].Trim().Trim('"');
                    decimal val;
                    if (!decimal.TryParse(pair[1].Trim(), System.Globalization.NumberStyles.Any, 
                        System.Globalization.CultureInfo.InvariantCulture, out val)) continue;
                    if (key == "snPnl") snPnl = val;
                    else if (key == "viopComm") viopComm = val;
                    else if (key == "spotComm") spotComm = val;
                    else if (key == "closedCount") closedCount = val;
                }
                statsHistory[date] = new decimal[] { snPnl, viopComm, spotComm, closedCount };
            } catch { }
        }
        Log("Stats history yüklendi: " + statsHistory.Count + " gün");
    } catch (Exception ex) { Log("Stats history yükleme hata: " + ex.Message); }
};

Action SaveStatsHistory = () => {
    try {
        var sb = new System.Text.StringBuilder();
        sb.Append("{\n");
        var first = true;
        foreach (var kv in statsHistory) {
            if (!first) sb.Append(",\n");
            first = false;
            sb.Append("  \"" + kv.Key + "\": {");
            sb.Append("\"snPnl\":" + kv.Value[0].ToString(System.Globalization.CultureInfo.InvariantCulture));
            sb.Append(",\"viopComm\":" + kv.Value[1].ToString(System.Globalization.CultureInfo.InvariantCulture));
            sb.Append(",\"spotComm\":" + kv.Value[2].ToString(System.Globalization.CultureInfo.InvariantCulture));
            sb.Append(",\"closedCount\":" + ((int)kv.Value[3]).ToString());
            sb.Append("}");
        }
        sb.Append("\n}");
        System.IO.File.WriteAllText(STATS_HISTORY_FILE, sb.ToString());
    } catch (Exception ex) { Log("Stats history kayıt hata: " + ex.Message); }
};

SaveDailyStats = () => {
    var today = DateTime.Now.ToString("yyyy-MM-dd");
    if (lastStatsSaveDate == today) {
        // Bugün zaten kaydedildi, güncelle
        statsHistory[today] = new decimal[] { dailySNPnl, dailyViopCommission, dailySpotCommission, totalClosedSN };
    } else {
        // Yeni gün
        statsHistory[today] = new decimal[] { dailySNPnl, dailyViopCommission, dailySpotCommission, totalClosedSN };
        lastStatsSaveDate = today;
    }
    SaveStatsHistory();
};

// Dönemsel istatistik hesaplama
Func<int, decimal[]> CalcPeriodStats = (days) => {
    // Returns: [totalPnl, totalViopComm, totalSpotComm, totalClosed, tradingDays]
    var result = new decimal[] { 0, 0, 0, 0, 0 };
    var cutoff = DateTime.Now.AddDays(-days);
    
    foreach (var kv in statsHistory) {
        DateTime date;
        if (!DateTime.TryParse(kv.Key, out date)) continue;
        if (date < cutoff) continue;
        
        result[0] += kv.Value[0];  // snPnl
        result[1] += kv.Value[1];  // viopComm
        result[2] += kv.Value[2];  // spotComm
        result[3] += kv.Value[3];  // closedCount
        result[4]++;               // tradingDays
    }
    return result;
};

Func<decimal[]> CalcAllTimeStats = () => {
    var result = new decimal[] { 0, 0, 0, 0, 0 };
    foreach (var kv in statsHistory) {
        result[0] += kv.Value[0];
        result[1] += kv.Value[1];
        result[2] += kv.Value[2];
        result[3] += kv.Value[3];
        result[4]++;
    }
    return result;
};

// Stats JSON oluşturma - tek fonksiyon, fullStats=true ise dönemsel istatistikler ve pozisyonlar dahil
Func<string> BuildStatsJson = () => {
    var ic = System.Globalization.CultureInfo.InvariantCulture;
    var sb = new System.Text.StringBuilder();
    var totalComm = dailySpotCommission + totalTransferredComm + dailyViopCommission;
    
    sb.Append("{\"ts\":\"" + DateTime.Now.ToString("HH:mm:ss") + "\",");
    sb.Append("\"test\":" + (IS_TEST ? "true" : "false") + ",");
    sb.Append("\"running\":" + (isRunning ? "true" : "false") + ",");
    sb.Append("\"market\":" + (isMarketOpen ? "true" : "false") + ",");
    sb.Append("\"paused\":" + (isPaused ? "true" : "false") + ",");
    sb.Append("\"data\":" + (dataConnected ? "true" : "false") + ",");
    sb.Append("\"broker\":" + (brokerConnected ? "true" : "false") + ",");
    sb.Append("\"margin\":" + marginStatus + ",");  // 0=normal, 1=warning, 2=danger, 3=critical
    sb.Append("\"circuit\":" + (indexCircuitBreaker ? "true" : "false") + ",");  // Endeks devre kesici

    // Kritik uyarılar dizisi
    sb.Append("\"alerts\":[");
    var alertList = new System.Collections.Generic.List<string>();
    if (t2CriticalAlert) alertList.Add("\"T2_CRITICAL\"");
    if (indexCircuitBreaker) alertList.Add("\"INDEX_CIRCUIT\"");
    if (marginStatus >= 3) alertList.Add("\"MARGIN_CRITICAL\"");
    sb.Append(string.Join(",", alertList.ToArray()));
    sb.Append("],");

    // VİOP serbest oran hesapla: kullanılabilir / (kullanılabilir + kullanılan)
    var viopToplam = viopBalance + viopUsed;
    var viopFreePct = viopToplam > 0 ? viopBalance / viopToplam : 0m;
    sb.Append("\"viop_free\":" + viopFreePct.ToString("F4", ic) + ",");
    
    sb.Append("\"viop_bal\":" + viopBalance.ToString("F0", ic) + ",\"spot_bal\":" + spotBudgetTotal.ToString("F0", ic) + ",\"t2\":" + t2Balance.ToString("F0", ic) + ",");
    sb.Append("\"viop_used\":" + viopUsed.ToString(ic) + ",\"spot_used\":" + spotUsed.ToString(ic) + ",");
    sb.Append("\"viop_budget\":" + VIOP_BUDGET.ToString("F0", ic) + ",\"spot_budget\":" + SPOT_BUDGET.ToString("F0", ic) + ",");
    sb.Append("\"daily_pnl\":" + dailyRealizedPnl.ToString("F0", ic) + ",\"trades\":" + dailyTrades + ",");
    sb.Append("\"total_comm\":" + totalComm.ToString("F2", ic) + ",");
    sb.Append("\"risk_free\":" + RISK_FREE.ToString("F4", ic) + ",");
    
    // Dönemsel istatistikler
    var weekStats = CalcPeriodStats(7);
    var monthStats = CalcPeriodStats(30);
    var allStats = CalcAllTimeStats();
    
    sb.Append("\"week\":{\"pnl\":" + weekStats[0].ToString("F0", ic) + 
        ",\"comm\":" + (weekStats[1] + weekStats[2]).ToString("F0", ic) + 
        ",\"trades\":" + ((int)weekStats[3]).ToString() + 
        ",\"days\":" + ((int)weekStats[4]).ToString() + "},");
    sb.Append("\"month\":{\"pnl\":" + monthStats[0].ToString("F0", ic) + 
        ",\"comm\":" + (monthStats[1] + monthStats[2]).ToString("F0", ic) + 
        ",\"trades\":" + ((int)monthStats[3]).ToString() + 
        ",\"days\":" + ((int)monthStats[4]).ToString() + "},");
    sb.Append("\"all\":{\"pnl\":" + allStats[0].ToString("F0", ic) + 
        ",\"comm\":" + (allStats[1] + allStats[2]).ToString("F0", ic) + 
        ",\"trades\":" + ((int)allStats[3]).ToString() + 
        ",\"days\":" + ((int)allStats[4]).ToString() + "},");
    
    // Pozisyonlar (her zaman tam detay)
    sb.Append("\"positions\":{");
    var posFirst = true;
    decimal totalPnl = 0;
    foreach (var kv in snPos) {
        if (!posFirst) sb.Append(",");
        posFirst = false;
        var p = kv.Value;
        var sym = kv.Key;
        var spotQty = (int)p[0]; var nearQty = (int)p[1];
        var spotEntry = (decimal)p[2]; var nearEntry = (decimal)p[3];
        var entrySpread = (decimal)p[4];
        var expectedPnl = (decimal)p[5]; var addCount = (int)p[6];
        var entryTicks = p.Length > 7 ? (long)p[7] : 0L;
        
        // Güncel spread ve P&L hesapla (derinlikten)
        var nearC = GetContract(sym, 0);
        var nearS = FUTURES_PREFIX + nearC;
        var spotBidDepthG = ReadDepth("IMKBH'" + sym, "BID", 0, 1, 50);
        var nearAskDepthG = ReadDepth(nearS, "ASK", 0, 1, 50);
        var spotBid = spotBidDepthG.Item1 ? spotBidDepthG.Item4 : 0m;
        var nearAskG = nearAskDepthG.Item1 ? nearAskDepthG.Item4 : 0m;
        
        // dayanakSatAl = nearAsk - spotBid (kapanış spread'i)
        var dayanakSatAl = nearAskG - spotBid;
        var currentSpread = spotBid > 0 ? dayanakSatAl / spotBid : 0m;
        
        // P&L = Spot P&L + Near P&L
        // Spot: (satış fiyatı - giriş) * adet
        // Near: (giriş - şimdiki) * kontrat * çarpan
        var mult = GetMultiplier(sym);
        var currentPnl = (spotBid - spotEntry) * spotQty + (nearEntry - nearAskG) * nearQty * mult;
        totalPnl += currentPnl;
        
        sb.Append("\"" + sym + "\":{");
        sb.Append("\"sq\":" + spotQty + ",\"nq\":" + nearQty + ",");
        sb.Append("\"se\":" + spotEntry.ToString("F2", ic) + ",\"ne\":" + nearEntry.ToString("F2", ic) + ",");
        sb.Append("\"es\":" + entrySpread.ToString("F6", ic) + ",");  // entry spread
        sb.Append("\"et\":" + entryTicks + ",");  // entry ticks
        sb.Append("\"sp\":" + currentSpread.ToString("F4", ic) + ",");
        sb.Append("\"pnl\":" + currentPnl.ToString("F0", ic) + ",");
        sb.Append("\"exp\":" + expectedPnl.ToString("F0", ic) + ",");
        sb.Append("\"d\":" + addCount + "}");
    }
    sb.Append("},");
    
    // NF Pozisyonlar (Near-Far)
    sb.Append("\"nf_positions\":{");
    var nfPosFirst = true;
    decimal totalNfPnl = 0;
    foreach (var kv in nfPos) {
        if (!nfPosFirst) sb.Append(",");
        nfPosFirst = false;
        var p = kv.Value;
        var sym = kv.Key;
        var nearQty = (int)p[0]; var farQty = (int)p[1];
        var nearEntry = p[2]; var farEntry = p[3];
        var entrySpread = p[4]; var expectedPnl = p[5];
        var entryTicks = p.Length > 6 ? (long)p[6] : 0L;
        
        // Güncel fiyatlar ve P&L hesapla
        var nearC = nfContracts.ContainsKey(sym) ? nfContracts[sym][0] : GetContract(sym, 0);
        var farC = nfContracts.ContainsKey(sym) ? nfContracts[sym][1] : GetContract(sym, 1);
        var nearS = FUTURES_PREFIX + nearC;
        var farS = FUTURES_PREFIX + farC;
        
        var nearBidDepthG = ReadDepth(nearS, "BID", 0, 1, 50);
        var farAskDepthG = ReadDepth(farS, "ASK", 0, 1, 50);
        var nearBid = nearBidDepthG.Item1 ? nearBidDepthG.Item4 : nearEntry;
        var farAsk = farAskDepthG.Item1 ? farAskDepthG.Item4 : farEntry;
        
        var mult = GetMultiplier(sym);
        var nearPnl = (nearBid - nearEntry) * nearQty * mult;
        var farPnl = (farEntry - farAsk) * farQty * mult;
        var currentPnl = nearPnl + farPnl;
        totalNfPnl += currentPnl;
        
        // Güncel spread
        var currentSpread = nearBid > 0 ? (farAsk - nearBid) / nearBid : 0m;
        
        sb.Append("\"" + sym + "\":{");
        sb.Append("\"nq\":" + nearQty + ",\"fq\":" + farQty + ",");
        sb.Append("\"ne\":" + nearEntry.ToString("F2", ic) + ",\"fe\":" + farEntry.ToString("F2", ic) + ",");
        sb.Append("\"es\":" + entrySpread.ToString("F6", ic) + ",");
        sb.Append("\"et\":" + entryTicks + ",");
        sb.Append("\"sp\":" + currentSpread.ToString("F4", ic) + ",");
        sb.Append("\"pnl\":" + currentPnl.ToString("F0", ic) + ",");
        sb.Append("\"exp\":" + expectedPnl.ToString("F0", ic) + ",");
        sb.Append("\"d\":" + GetDays(nearC) + "}");
    }
    sb.Append("},");
    sb.Append("\"nf_count\":" + nfPos.Count + ",");
    sb.Append("\"nf_budget\":" + NF_BUDGET.ToString("F0", ic) + ",");
    
    // PAIR Pozisyonlar (Near-Near Pair Trading)
    sb.Append("\"pair_positions\":{");
    var pairPosFirst = true;
    decimal totalPairPnlB = 0;
    foreach (var kv in pairPos) {
        if (!pairPosFirst) sb.Append(",");
        pairPosFirst = false;
        var p = kv.Value;
        var parts = kv.Key.Split('-');
        if (parts.Length == 2) {
            var symA = parts[0];
            var symB = parts[1];
            var currentZ = pairZScores.ContainsKey(kv.Key) ? pairZScores[kv.Key] : 0m;
            var unrealizedPnl = CalcPairUnrealizedPnl(kv.Key, p);
            var expectedPnl = p.Length > 7 ? p[7] : 0m;
            totalPairPnlB += unrealizedPnl;
            
            // Kontratları pairContracts'tan al (yoksa GetContract'tan)
            var pairC = pairContracts.ContainsKey(kv.Key) ? pairContracts[kv.Key] : new string[] { GetContract(symA, 0), GetContract(symB, 0) };
            var nearA = pairC[0];
            var daysToExp = string.IsNullOrEmpty(nearA) ? 0 : GetDays(nearA);
            
            sb.Append("\"" + kv.Key + "\":{");
            sb.Append("\"a\":" + ((int)p[0]).ToString() + ",");
            sb.Append("\"b\":" + ((int)p[1]).ToString() + ",");
            sb.Append("\"avgA\":" + p[2].ToString("F2", ic) + ",");
            sb.Append("\"avgB\":" + p[3].ToString("F2", ic) + ",");
            sb.Append("\"oz\":" + p[4].ToString("F2", ic) + ",");
            sb.Append("\"cz\":" + currentZ.ToString("F2", ic) + ",");
            sb.Append("\"t\":" + ((int)p[5]).ToString() + ",");
            sb.Append("\"pnl\":" + unrealizedPnl.ToString("F0", ic) + ",");
            sb.Append("\"exp\":" + expectedPnl.ToString("F0", ic) + ",");
            sb.Append("\"d\":" + daysToExp + ",");
            sb.Append("\"ca\":\"" + pairC[0] + "\",");
            sb.Append("\"cb\":\"" + pairC[1] + "\"}");
        }
    }
    sb.Append("},");
    sb.Append("\"pair_count\":" + pairPos.Count + ",");
    sb.Append("\"pair_enabled\":" + (PAIR_ENABLED ? "true" : "false") + ",");
    sb.Append("\"pair_budget\":" + PAIR_BUDGET.ToString("F0", ic) + ",");
    sb.Append("\"pair_used\":" + pairUsed.ToString("F0", ic) + ",");
    sb.Append("\"pair_definitions\":\"" + PAIR_DEFINITIONS.Replace("\"", "\\\"") + "\",");
    
    // Pair Z-Score özeti (tüm tanımlı çiftler için)
    sb.Append("\"pair_z\":{");
    var pzFirst = true;
    foreach (var def in PAIR_DEFS) {
        var symA = (string)def[0];
        var symB = (string)def[1];
        var pairKey = GetPairKey(symA, symB);
        if (!pzFirst) sb.Append(",");
        pzFirst = false;
        if (pairZScores.ContainsKey(pairKey)) {
            sb.Append("\"" + pairKey + "\":" + pairZScores[pairKey].ToString("F2", ic));
        } else {
            sb.Append("\"" + pairKey + "\":null");  // Veri yok
        }
    }
    sb.Append("},");
    
    // Bekleyen emirler
    sb.Append("\"pending\":{");
    var pendFirst = true;
    foreach (var pk in pendingOrders) {
        if (!pendFirst) sb.Append(",");
        pendFirst = false;
        var pd = pk.Value;
        var waitMin = (DateTime.Now - (DateTime)pd[3]).TotalMinutes;
        sb.Append("\"" + pk.Key + "\":{");
        sb.Append("\"side\":\"" + pd[0] + "\",");
        sb.Append("\"qty\":" + ((int)pd[1]).ToString() + ",");
        sb.Append("\"price\":" + ((decimal)pd[2]).ToString("F2", ic) + ",");
        sb.Append("\"wait\":" + waitMin.ToString("F0", ic) + ",");
        sb.Append("\"processed\":" + (pd.Length > 11 ? ((int)pd[11]).ToString() : "0") + "}");
    }
    sb.Append("},");
    sb.Append("\"pending_count\":" + pendingOrders.Count + ",");
    
    // Yetim bacaklar
    sb.Append("\"orphans\":{");
    var orphFirst = true;
    foreach (var kv in orphanLegs) {
        if (!orphFirst) sb.Append(",");
        orphFirst = false;
        var o = kv.Value;
        sb.Append("\"" + kv.Key + "\":{");
        sb.Append("\"fl\":\"" + o[0] + "\",");              // filledLeg
        sb.Append("\"fs\":\"" + o[2] + "\",");              // filledSide
        sb.Append("\"fq\":" + ((int)o[3]).ToString() + ","); // filledQty
        sb.Append("\"fp\":" + ((decimal)o[4]).ToString("F2", ic) + ","); // filledPrice
        sb.Append("\"tl\":\"" + o[5] + "\"}");              // targetLeg
    }
    sb.Append("},");
    sb.Append("\"orphan_count\":" + orphanLegs.Count + ",");
    
    sb.Append("\"total_pnl\":" + (totalPnl + totalNfPnl + totalPairPnlB).ToString("F0", ic) + ",\"count\":" + (snPos.Count + nfPos.Count + pairPos.Count) + "}");
    
    return sb.ToString();
};

// 09:20 teminat güncelleme kontrolü
var lastTeminatUpdate = DateTime.MinValue;
Action CheckTeminatUpdate = () => {
    var now = DateTime.Now;
    if (now.Hour == 9 && now.Minute >= 20 && now.Minute < 25) {
        if (lastTeminatUpdate.Date != now.Date) {
            if (!IsTeminatFileCurrentMonth()) {
                Log("📅 Teminat dosyası bu aya ait değil, güncelleniyor...");
                UpdateTeminatFromVIOP();
            }
            lastTeminatUpdate = now;
        }
    }
};

// 09:56 derinlik cache warmup (piyasa açılışından önce)
var lastDepthWarmup = DateTime.MinValue;
Action WarmupDepthCache = () => {
    var now = DateTime.Now;
    // 09:56-09:59 arasında, günde bir kez
    if (now.Hour == 9 && now.Minute >= 56 && now.Minute < 60) {
        if (lastDepthWarmup.Date != now.Date) {
            Log("🔥 Derinlik cache ve tavan/taban uyandırılıyor (" + symbols.Count + " sembol)...");
            var warmupCount = 0;
            var tavanTabanCount = 0;
            foreach (var sym in symbols) {
                try {
                    var nearC = GetContract(sym, 0);
                    var farC = GetContract(sym, 1);
                    
                    var spotSym = SPOT_PREFIX + sym;
                    var nearSym = FUTURES_PREFIX + nearC;
                    
                    // Spot derinlik
                    Sistem.DerinlikVerisiOku(spotSym);
                    // Near derinlik
                    Sistem.DerinlikVerisiOku(nearSym);
                    // Far derinlik
                    if (!string.IsNullOrEmpty(farC)) {
                        Sistem.DerinlikVerisiOku(FUTURES_PREFIX + farC);
                    }
                    warmupCount++;
                    
                    // Tavan/Taban fiyatları (Spot, Near ve Far için)
                    try {
                        var spotTavan = (decimal)Sistem.Tavan(spotSym);
                        var spotTaban = (decimal)Sistem.Taban(spotSym);
                        if (spotTavan > 0) tavanFiyat[spotSym] = spotTavan;
                        if (spotTaban > 0) tabanFiyat[spotSym] = spotTaban;
                        
                        var nearTavan = (decimal)Sistem.Tavan(nearSym);
                        var nearTaban = (decimal)Sistem.Taban(nearSym);
                        if (nearTavan > 0) tavanFiyat[nearSym] = nearTavan;
                        if (nearTaban > 0) tabanFiyat[nearSym] = nearTaban;
                        
                        // Far tavan/taban (NF stratejisi için)
                        if (!string.IsNullOrEmpty(farC)) {
                            var farSym = FUTURES_PREFIX + farC;
                            var farTavan = (decimal)Sistem.Tavan(farSym);
                            var farTaban = (decimal)Sistem.Taban(farSym);
                            if (farTavan > 0) tavanFiyat[farSym] = farTavan;
                            if (farTaban > 0) tabanFiyat[farSym] = farTaban;
                        }
                        
                        tavanTabanCount++;
                    } catch { }
                } catch { }
            }
            Log("✅ Cache uyandırıldı: " + warmupCount + " sembol (derinlik), " + tavanTabanCount + " sembol (tavan/taban)");
            lastDepthWarmup = now;
        }
    }
};

// Robot başlangıcında tavan/taban fiyatlarını yükle (gün içi başlatma için)
Action LoadTavanTaban = () => {
    Log("📊 Tavan/taban fiyatları yükleniyor...");
    var loadedCount = 0;
    foreach (var sym in symbols) {
        try {
            var nearC = GetContract(sym, 0);
            if (string.IsNullOrEmpty(nearC)) continue;
            
            var spotSym = SPOT_PREFIX + sym;
            var nearSym = FUTURES_PREFIX + nearC;
            
            // Spot tavan/taban
            try {
                var spotTavan = (decimal)Sistem.Tavan(spotSym);
                var spotTaban = (decimal)Sistem.Taban(spotSym);
                if (spotTavan > 0) tavanFiyat[spotSym] = spotTavan;
                if (spotTaban > 0) tabanFiyat[spotSym] = spotTaban;
            } catch { }
            
            // Near tavan/taban
            try {
                var nearTavan = (decimal)Sistem.Tavan(nearSym);
                var nearTaban = (decimal)Sistem.Taban(nearSym);
                if (nearTavan > 0) tavanFiyat[nearSym] = nearTavan;
                if (nearTaban > 0) tabanFiyat[nearSym] = nearTaban;
            } catch { }
            
            // Far tavan/taban (NF stratejisi için)
            try {
                var farC = GetContract(sym, 1);
                if (!string.IsNullOrEmpty(farC)) {
                    var farSym = FUTURES_PREFIX + farC;
                    // Far derinlik cache uyandır
                    Sistem.DerinlikVerisiOku(farSym);
                    var farTavan = (decimal)Sistem.Tavan(farSym);
                    var farTaban = (decimal)Sistem.Taban(farSym);
                    if (farTavan > 0) tavanFiyat[farSym] = farTavan;
                    if (farTaban > 0) tabanFiyat[farSym] = farTaban;
                }
            } catch { }
            
            loadedCount++;
        } catch { }
    }
    Log("✅ Tavan/taban yüklendi: " + loadedCount + " sembol (Tavan:" + tavanFiyat.Count + " Taban:" + tabanFiyat.Count + ")");
};

// ====================================
// TEMETTÜ YÖNETİMİ
// ====================================

// Temettü JSON dosyasını yükle
Action LoadDividends = () => {
    try {
        dividends.Clear();
        if (!System.IO.File.Exists(TEMETTU_FILE)) {
            Log("⚠️ Temettü dosyası bulunamadı: " + TEMETTU_FILE);
            return;
        }
        
        var json = System.IO.File.ReadAllText(TEMETTU_FILE);
        var ic = System.Globalization.CultureInfo.InvariantCulture;
        
        // "dividends": { bölümünü bul
        var divIdx = json.IndexOf("\"dividends\"");
        if (divIdx == -1) return;
        
        var divStart = json.IndexOf("{", divIdx + 10);
        if (divStart == -1) return;
        
        // Her sembolü parse et
        var pos = divStart + 1;
        while (pos < json.Length) {
            // Sembol adını bul: "BEGYO": [
            var symStart = json.IndexOf("\"", pos);
            if (symStart == -1) break;
            var symEnd = json.IndexOf("\"", symStart + 1);
            if (symEnd == -1) break;
            
            var sym = json.Substring(symStart + 1, symEnd - symStart - 1);
            
            // Array başlangıcı
            var arrStart = json.IndexOf("[", symEnd);
            if (arrStart == -1) break;
            var arrEnd = json.IndexOf("]", arrStart);
            if (arrEnd == -1) break;
            
            var arrContent = json.Substring(arrStart, arrEnd - arrStart + 1);
            
            // Her temettü kaydını parse et
            var divList = new System.Collections.Generic.List<System.Tuple<DateTime, decimal>>();
            var objPos = 0;
            while (true) {
                var dateIdx = arrContent.IndexOf("\"date\"", objPos);
                if (dateIdx == -1) break;
                
                // Tarih: "16.02.2026"
                var dateStart = arrContent.IndexOf("\"", dateIdx + 6) + 1;
                var dateEnd = arrContent.IndexOf("\"", dateStart);
                if (dateEnd <= dateStart) break;  // Parse hatası - çık
                var dateStr = arrContent.Substring(dateStart, dateEnd - dateStart);
                
                // Tutar: "amount": 0.0215
                var amtIdx = arrContent.IndexOf("\"amount\"", dateEnd);
                if (amtIdx == -1) break;
                var amtStart = arrContent.IndexOf(":", amtIdx) + 1;
                var amtEnd = amtStart;
                while (amtEnd < arrContent.Length && (char.IsDigit(arrContent[amtEnd]) || arrContent[amtEnd] == '.' || arrContent[amtEnd] == ' ')) amtEnd++;
                
                // İlerleme kontrolü - sonsuz döngü önleme
                if (amtEnd <= objPos) break;
                
                DateTime divDate;
                decimal divAmount;
                if (DateTime.TryParseExact(dateStr, "dd.MM.yyyy", ic, System.Globalization.DateTimeStyles.None, out divDate) &&
                    decimal.TryParse(arrContent.Substring(amtStart, amtEnd - amtStart).Trim(), System.Globalization.NumberStyles.Any, ic, out divAmount)) {
                    divList.Add(System.Tuple.Create(divDate, divAmount));
                }
                
                objPos = amtEnd;
            }
            
            if (divList.Count > 0) {
                dividends[sym] = divList;
            }
            
            pos = arrEnd + 1;
            
            // Sonraki sembol veya dividends sonu
            var nextComma = json.IndexOf(",", pos);
            var nextBrace = json.IndexOf("}", pos);
            if (nextBrace != -1 && (nextComma == -1 || nextBrace < nextComma)) break;
        }
        
        var totalDivs = 0;
        foreach (var kv in dividends) totalDivs += kv.Value.Count;
        Log("✅ Temettü yüklendi: " + dividends.Count + " sembol, " + totalDivs + " kayıt");
        
    } catch (Exception ex) {
        Log("❌ Temettü yükleme hatası: " + ex.Message);
    }
};

// Temettü scraper'ı çalıştır ve JSON'u güncelle
Action UpdateDividends = () => {
    try {
        // Dosya var mı ve bugün güncellenmiş mi kontrol et
        var needUpdate = true;
        if (System.IO.File.Exists(TEMETTU_FILE)) {
            var json = System.IO.File.ReadAllText(TEMETTU_FILE);
            var updIdx = json.IndexOf("\"updated\"");
            if (updIdx != -1) {
                var dateStart = json.IndexOf("\"", updIdx + 9) + 1;
                var dateEnd = json.IndexOf("\"", dateStart);
                var updatedStr = json.Substring(dateStart, dateEnd - dateStart);
                DateTime updatedDate;
                if (DateTime.TryParse(updatedStr, out updatedDate)) {
                    if (updatedDate.Date >= DateTime.Now.Date) {
                        needUpdate = false;  // Bugün zaten güncellenmiş
                    }
                }
            }
        }
        
        if (!needUpdate) {
            Log("✅ Temettü verisi güncel (bugün güncellenmiş)");
            LoadDividends();
            return;
        }
        
        // Scraper'ı çalıştır
        if (!System.IO.File.Exists(TEMETTU_SCRAPER)) {
            Log("⚠️ Temettü scraper bulunamadı: " + TEMETTU_SCRAPER);
            LoadDividends();  // Mevcut veriyi yükle
            return;
        }
        
        Log("🔄 Temettü verisi güncelleniyor...");
        
        var psi = new System.Diagnostics.ProcessStartInfo();
        psi.FileName = "python";
        psi.Arguments = "\"" + TEMETTU_SCRAPER + "\"";
        psi.WorkingDirectory = BASE_PATH;
        psi.UseShellExecute = false;
        psi.CreateNoWindow = true;
        psi.RedirectStandardOutput = true;
        psi.RedirectStandardError = true;
        
        var proc = System.Diagnostics.Process.Start(psi);
        proc.WaitForExit(60000);  // 60 saniye timeout
        
        if (proc.ExitCode == 0) {
            Log("✅ Temettü scraper başarılı");
        } else {
            var err = proc.StandardError.ReadToEnd();
            Log("⚠️ Temettü scraper hata: " + (err.Length > 100 ? err.Substring(0, 100) : err));
        }
        
        LoadDividends();
        lastTemettuCheck = DateTime.Now;
        
    } catch (Exception ex) {
        Log("❌ Temettü güncelleme hatası: " + ex.Message);
        LoadDividends();  // Mevcut veriyi yükle
    }
};

// Near-Far arası temettü kontrolü
// Dönüş: (temettüVar, toplamTemettü)
GetDividendsBetween = (sym, nearExpiry, farExpiry) => {
    var totalDiv = 0m;
    var hasDiv = false;
    
    if (!dividends.ContainsKey(sym)) {
        return System.Tuple.Create(false, 0m);
    }
    
    foreach (var div in dividends[sym]) {
        var exDate = div.Item1;
        // Temettü tarihi Near vadesi ile Far vadesi arasında mı?
        if (exDate > nearExpiry && exDate <= farExpiry) {
            hasDiv = true;
            totalDiv += div.Item2;
        }
    }
    
    return System.Tuple.Create(hasDiv, totalDiv);
};

// ====================================
// SERMAYE ARTIRIMI KORUMA SİSTEMİ
// ====================================

// Sermaye artırımı JSON'dan yükle
Action LoadSermayeArtirimi = () => {
    try {
        if (!System.IO.File.Exists(SRM_FILE)) {
            Log("⚠️ srm.json bulunamadı");
            return;
        }
        
        sermayeArtirimlari.Clear();
        var json = System.IO.File.ReadAllText(SRM_FILE);
        
        // data array'ini bul (yeni format: {"meta":{...}, "data":[...]})
        int dataStart = json.IndexOf("\"data\"");
        string dataSection = json;
        
        if (dataStart >= 0) {
            int arrayStart = json.IndexOf('[', dataStart);
            int arrayEnd = json.LastIndexOf(']');
            if (arrayStart >= 0 && arrayEnd > arrayStart) {
                dataSection = json.Substring(arrayStart, arrayEnd - arrayStart + 1);
            }
        }
        
        // Her kayıt için parse et
        int pos = 0;
        while (true) {
            int objStart = dataSection.IndexOf('{', pos);
            if (objStart < 0) break;
            
            int objEnd = dataSection.IndexOf('}', objStart);
            if (objEnd < 0) break;
            
            string obj = dataSection.Substring(objStart, objEnd - objStart + 1);
            pos = objEnd + 1;
            
            // bist_kodu çıkar
            var kodIdx = obj.IndexOf("\"bist_kodu\"");
            if (kodIdx < 0) continue;
            var kodStart = obj.IndexOf("\"", kodIdx + 11) + 1;
            var kodEnd = obj.IndexOf("\"", kodStart);
            if (kodStart <= 0 || kodEnd <= kodStart) continue;
            string bist_kodu = obj.Substring(kodStart, kodEnd - kodStart).ToUpper();
            
            // Önce ISO formatı dene
            string tarihStr = null;
            var isoIdx = obj.IndexOf("\"baslangic_iso\"");
            if (isoIdx >= 0) {
                var isoStart = obj.IndexOf("\"", isoIdx + 15) + 1;
                var isoEnd = obj.IndexOf("\"", isoStart);
                if (isoStart > 0 && isoEnd > isoStart) {
                    var isoVal = obj.Substring(isoStart, isoEnd - isoStart);
                    if (isoVal != "null" && !string.IsNullOrEmpty(isoVal)) {
                        tarihStr = isoVal;
                    }
                }
            }
            
            // ISO yoksa normal formatı dene
            if (string.IsNullOrEmpty(tarihStr)) {
                var basIdx = obj.IndexOf("\"baslangic\"");
                if (basIdx >= 0) {
                    var basStart = obj.IndexOf("\"", basIdx + 11) + 1;
                    var basEnd = obj.IndexOf("\"", basStart);
                    if (basStart > 0 && basEnd > basStart) {
                        tarihStr = obj.Substring(basStart, basEnd - basStart);
                    }
                }
            }
            
            if (string.IsNullOrEmpty(tarihStr)) continue;
            
            // Tarihi parse et
            DateTime tarih;
            bool parsed = false;
            
            // ISO format: 2026-01-20
            if (DateTime.TryParseExact(tarihStr, "yyyy-MM-dd", null, System.Globalization.DateTimeStyles.None, out tarih)) {
                parsed = true;
            }
            // TR format: 20.01.2026
            else if (DateTime.TryParseExact(tarihStr, "dd.MM.yyyy", null, System.Globalization.DateTimeStyles.None, out tarih)) {
                parsed = true;
            }
            
            if (parsed && !sermayeArtirimlari.ContainsKey(bist_kodu)) {
                sermayeArtirimlari[bist_kodu] = tarih;
            }
        }
        
        Log("✅ Sermaye artırımı yüklendi: " + sermayeArtirimlari.Count + " kayıt (tarihi belli)");
        
        // 7 gün içindekileri logla
        foreach (var kv in sermayeArtirimlari) {
            var gunFarki = (kv.Value.Date - DateTime.Today).Days;
            if (gunFarki >= 0 && gunFarki <= 7) {
                Log("  ⚠️ " + kv.Key + ": " + kv.Value.ToString("dd.MM.yyyy") + " (" + gunFarki + " gün sonra)");
            }
        }
        
    } catch (Exception ex) {
        Log("❌ Sermaye artırımı yükleme hatası: " + ex.Message);
    }
};

// Sermaye artırımı scraper çalıştır ve JSON güncelle
Action UpdateSermayeArtirimi = () => {
    try {
        // Dosya var mı ve bugün güncellenmiş mi kontrol et
        var needUpdate = true;
        if (System.IO.File.Exists(SRM_FILE)) {
            var fileInfo = new System.IO.FileInfo(SRM_FILE);
            if (fileInfo.LastWriteTime.Date >= DateTime.Today) {
                needUpdate = false;  // Bugün zaten güncellenmiş
            }
        }
        
        if (!needUpdate) {
            Log("✅ Sermaye artırımı verisi güncel");
            LoadSermayeArtirimi();
            return;
        }
        
        // Scraper'ı çalıştır
        if (!System.IO.File.Exists(SRM_SCRAPER)) {
            Log("⚠️ Sermaye artırımı scraper bulunamadı: " + SRM_SCRAPER);
            LoadSermayeArtirimi();  // Mevcut veriyi yükle
            return;
        }
        
        Log("🔄 Sermaye artırımı verisi güncelleniyor...");
        
        var psi = new System.Diagnostics.ProcessStartInfo();
        psi.FileName = "python";
        psi.Arguments = "\"" + SRM_SCRAPER + "\" --force";
        psi.WorkingDirectory = BASE_PATH;
        psi.UseShellExecute = false;
        psi.CreateNoWindow = true;
        psi.RedirectStandardOutput = true;
        psi.RedirectStandardError = true;
        
        var proc = System.Diagnostics.Process.Start(psi);
        proc.WaitForExit(90000);  // 90 saniye timeout (PDF indirme uzun sürebilir)
        
        if (proc.ExitCode == 0) {
            Log("✅ Sermaye artırımı scraper başarılı");
        } else {
            var err = proc.StandardError.ReadToEnd();
            Log("⚠️ Sermaye artırımı scraper hata: " + (err.Length > 100 ? err.Substring(0, 100) : err));
        }
        
        LoadSermayeArtirimi();
        lastSrmCheck = DateTime.Now;
        
    } catch (Exception ex) {
        Log("❌ Sermaye artırımı güncelleme hatası: " + ex.Message);
        LoadSermayeArtirimi();  // Mevcut veriyi yükle
    }
};

Action LoadSettings = () => {
    try {
        var ic = System.Globalization.CultureInfo.InvariantCulture;
        
        Func<string, string, decimal, decimal> getDecimal = (jsonStr, key, def) => {
            var idx = jsonStr.IndexOf("\"" + key + "\"");
            if (idx == -1) return def;
            var start = jsonStr.IndexOf(":", idx) + 1;
            var end = start;
            while (end < jsonStr.Length && (char.IsDigit(jsonStr[end]) || jsonStr[end] == '.' || jsonStr[end] == '-')) end++;
            decimal val;
            if (decimal.TryParse(jsonStr.Substring(start, end - start).Trim(), System.Globalization.NumberStyles.Any, ic, out val))
                return val;
            return def;
        };
        
        Func<string, string, string, string> getString = (jsonStr, key, def) => {
            var idx = jsonStr.IndexOf("\"" + key + "\"");
            if (idx == -1) return def;
            var start = jsonStr.IndexOf("\"", idx + key.Length + 3) + 1;
            var end = jsonStr.IndexOf("\"", start);
            return start > 0 && end > start ? jsonStr.Substring(start, end - start) : def;
        };
        
        // Gist credentials ayrı dosyadan oku (Gist'e yüklenmiyor)
        if (System.IO.File.Exists(GIST_CREDENTIALS_FILE)) {
            var credJson = System.IO.File.ReadAllText(GIST_CREDENTIALS_FILE);
            GIST_TOKEN = getString(credJson, "gist_token", "");
            GIST_ID = getString(credJson, "gist_id", "");
        }
        
        // Diğer ayarlar
        if (!System.IO.File.Exists(SETTINGS_FILE)) return;
        var json = System.IO.File.ReadAllText(SETTINGS_FILE);
        
        IS_TEST = (int)getDecimal(json, "test_mode", 0) == 1;
        VIOP_BUDGET = getDecimal(json, "viop_budget", VIOP_BUDGET);
        SPOT_BUDGET = getDecimal(json, "spot_budget", SPOT_BUDGET);
        // SN_BB_ENTRY kaldırıldı - günlük BB kontrolü artık kullanılmıyor
        SN_MIN_MARGIN = getDecimal(json, "sn_min_margin", SN_MIN_MARGIN);
        ROLL_MIN_MARGIN = getDecimal(json, "roll_min_margin", ROLL_MIN_MARGIN);
        REPLACEMENT_THRESHOLD = getDecimal(json, "replacement_threshold", REPLACEMENT_THRESHOLD);
        MAX_DAILY_LOSS = getDecimal(json, "max_daily_loss", MAX_DAILY_LOSS);
        EARLY_EXIT_K = getDecimal(json, "early_exit_k", EARLY_EXIT_K);
        BB_EXIT_HELPER = getDecimal(json, "bb_exit_helper", BB_EXIT_HELPER);
        BB_PERIOD = (int)getDecimal(json, "bb_period", BB_PERIOD);
        LOOP_MS = (int)getDecimal(json, "loop_ms", LOOP_MS);
        GIE_DEPTH_LEVELS = (int)getDecimal(json, "gie_depth_levels", GIE_DEPTH_LEVELS);
        
        // Yeni parametreler
        INTRADAY_MIN_PROFIT = getDecimal(json, "intraday_min_profit", INTRADAY_MIN_PROFIT);
        MARGIN_WARNING_PCT = getDecimal(json, "margin_warning_pct", MARGIN_WARNING_PCT);
        MARGIN_DANGER_PCT = getDecimal(json, "margin_danger_pct", MARGIN_DANGER_PCT);
        MARGIN_CRITICAL_PCT = getDecimal(json, "margin_critical_pct", MARGIN_CRITICAL_PCT);
        
        // Cache path (RAMDisk için - stats.json ve loglar)
        var cachePath = getString(json, "cache_path", "");
        if (!string.IsNullOrEmpty(cachePath)) {
            CACHE_PATH = cachePath;
            if (!CACHE_PATH.EndsWith("\\")) CACHE_PATH += "\\";
            // Cache path varsa LOG_PATH ve STATS_FILE'ı güncelle
            LOG_PATH = CACHE_PATH + "logs\\";
            STATS_FILE = CACHE_PATH + "stats.json";
            Log("Cache path: " + CACHE_PATH);
        }
        
        // BB93 parametreleri
        BB93_ENTRY_ENABLED = (int)getDecimal(json, "bb93_enabled", BB93_ENTRY_ENABLED ? 1 : 0) == 1;
        BB93_START_HOUR = (int)getDecimal(json, "bb93_start_hour", BB93_START_HOUR);
        BB93_START_MIN = (int)getDecimal(json, "bb93_start_min", BB93_START_MIN);
        BB93_END_HOUR = (int)getDecimal(json, "bb93_end_hour", BB93_END_HOUR);
        BB93_END_MIN = (int)getDecimal(json, "bb93_end_min", BB93_END_MIN);
        
        // NF parametreleri
        NF_ENABLED = (int)getDecimal(json, "nf_enabled", NF_ENABLED ? 1 : 0) == 1;
        NF_MAX_POSITIONS = (int)getDecimal(json, "nf_max_positions", NF_MAX_POSITIONS);
        NF_ENTRY_BB = getDecimal(json, "nf_entry_bb", NF_ENTRY_BB);
        NF_EXIT_BB = getDecimal(json, "nf_exit_bb", NF_EXIT_BB);
        NF_EXIT_PROFIT = getDecimal(json, "nf_exit_profit", NF_EXIT_PROFIT);
        
        // Pair Trading parametreleri
        PAIR_ENABLED = (int)getDecimal(json, "pair_enabled", PAIR_ENABLED ? 1 : 0) == 1;
        PAIR_BUDGET = getDecimal(json, "pair_budget", PAIR_BUDGET);
        PAIR_Z_ENTRY_1 = getDecimal(json, "pair_z_entry_1", PAIR_Z_ENTRY_1);
        PAIR_Z_ENTRY_2 = getDecimal(json, "pair_z_entry_2", PAIR_Z_ENTRY_2);
        PAIR_Z_ENTRY_3 = getDecimal(json, "pair_z_entry_3", PAIR_Z_ENTRY_3);
        PAIR_Z_EXIT = getDecimal(json, "pair_z_exit", PAIR_Z_EXIT);
        
        // Kademe bütçe dağılımı
        PAIR_ALLOC_1 = (int)getDecimal(json, "pair_alloc_1", PAIR_ALLOC_1);
        PAIR_ALLOC_2 = (int)getDecimal(json, "pair_alloc_2", PAIR_ALLOC_2);
        PAIR_ALLOC_3 = (int)getDecimal(json, "pair_alloc_3", PAIR_ALLOC_3);
        
        // Pair çift tanımları (format: "SYMB_A-SYMB_B:BETA,...")
        var pairDefsIdx = json.IndexOf("\"pair_definitions\"");
        if (pairDefsIdx >= 0) {
            var pairStart = json.IndexOf("\"", pairDefsIdx + 18) + 1;
            var pairEnd = json.IndexOf("\"", pairStart);
            if (pairStart > 0 && pairEnd > pairStart) {
                PAIR_DEFINITIONS = json.Substring(pairStart, pairEnd - pairStart);
            }
        }
        
        // Pair tanımlarını parse et
        ParsePairDefinitions();
        
        if (IS_TEST) {
            Log("Settings yüklendi: Test=True, VIOP=" + VIOP_BUDGET + ", SPOT=" + SPOT_BUDGET);
        } else {
            Log("Settings yüklendi: Test=False (gerçek bütçe kullanılacak)");
        }
    } catch (Exception ex) { Log("Settings hata: " + ex.Message); }
};

Action UpdateRiskFree = () => {
    try {
        var p = Sistem.SonFiyat("DFN'TAHVIL-G");
        if (p > 0) RISK_FREE = (decimal)p / 100m;
    } catch { }
};

// Grafik verisinden spread BB pozisyonu hesapla (5dk bar, son 100 bar)
// snBB artık sadece son BB pozisyonunu tutuyor (0-100 arası)
var lastBBRefresh = DateTime.MinValue;
Action LoadSpreadBBFromChart = () => {
    var loaded = 0;
    
    foreach (var sym in symbols) {
        try {
            // Near kontratı bul
            var nearC = "";
            for (int m = 0; m < 3; m++) {
                var dt = DateTime.Now.AddMonths(m);
                var code = "F_" + sym + dt.ToString("MMyy");
                try {
                    var yuz = Sistem.YuzeyselVeriOku(FUTURES_PREFIX + code);
                    if (yuz != null && yuz.LastPrice > 0) {
                        nearC = code;
                        break;
                    }
                } catch { continue; }
            }
            if (string.IsNullOrEmpty(nearC)) continue;
            
            // 5dk grafik verisi oku
            var spotData = Sistem.GrafikVerileriniOku(SPOT_PREFIX + sym, "5");
            var nearData = Sistem.GrafikVerileriniOku(FUTURES_PREFIX + nearC, "5");
            
            if (spotData == null || nearData == null) continue;
            if (spotData.Count < 20 || nearData.Count < 20) continue;
            
            // Near verilerini dictionary'e at
            var nearDict = new System.Collections.Generic.Dictionary<string, decimal>();
            for (int i = 0; i < nearData.Count; i++) {
                try {
                    var ndt = (DateTime)nearData[i].Date;
                    var key = ndt.ToString("yyyyMMdd_HHmm");
                    nearDict[key] = (decimal)nearData[i].Close;
                } catch { continue; }
            }
            
            // Son 100 bar için spread hesapla
            var spreads = new System.Collections.Generic.List<decimal>();
            var startIdx = Math.Max(0, spotData.Count - 100);
            
            for (int i = startIdx; i < spotData.Count; i++) {
                try {
                    var sdt = (DateTime)spotData[i].Date;
                    var key = sdt.ToString("yyyyMMdd_HHmm");
                    
                    if (!nearDict.ContainsKey(key)) continue;
                    
                    var spotClose = (decimal)spotData[i].Close;
                    var nearClose = nearDict[key];
                    
                    if (spotClose <= 0 || nearClose <= 0) continue;
                    
                    var spread = (nearClose - spotClose) / spotClose * 100;
                    spreads.Add(spread);
                } catch { continue; }
            }
            
            // BB pozisyonunu hesapla ve sakla
            if (spreads.Count >= 20) {
                var bb = CalcBB(spreads);
                var lastSpread = spreads[spreads.Count - 1];
                var bbPos = BBPos(lastSpread, bb.Item1, bb.Item3);
                snBBPos[sym] = bbPos;
                loaded++;
            }
            
        } catch { continue; }
    }
    
    lastBBRefresh = DateTime.Now;
    if (loaded > 0) Log("BB güncellendi: " + loaded + " sembol");
};

// Pozisyon kaydetme (dosyaya)
SavePositions = () => {
    try {
        if (snPos.Count == 0 && nfPos.Count == 0) {
            if (System.IO.File.Exists(POSITIONS_FILE)) System.IO.File.Delete(POSITIONS_FILE);
            return;
        }
        var ic = System.Globalization.CultureInfo.InvariantCulture;
        var sb = new System.Text.StringBuilder();
        sb.Append("{\"timestamp\":\"" + DateTime.Now.ToString("yyyy-MM-ddTHH:mm:ss") + "\",\"positions\":{");
        var first = true;
        foreach (var kv in snPos) {
            if (!first) sb.Append(",");
            first = false;
            var p = kv.Value;
            // [spotQty, nearQty, spotEntry, nearEntry, entrySpread, expectedPnl, addCount, entryTicks]
            sb.Append("\"" + kv.Key + "\":[");
            sb.Append(((int)p[0]).ToString() + ",");           // spotQty
            sb.Append(((int)p[1]).ToString() + ",");           // nearQty
            sb.Append(p[2].ToString("F4", ic) + ",");          // spotEntry
            sb.Append(p[3].ToString("F4", ic) + ",");          // nearEntry
            sb.Append(p[4].ToString("F6", ic) + ",");          // entrySpread (decimal)
            sb.Append(p[5].ToString("F2", ic) + ",");          // expectedPnl
            sb.Append(((int)p[6]).ToString() + ",");           // addCount
            sb.Append((p.Length > 7 ? (long)p[7] : DateTime.Now.Ticks).ToString());  // entryTicks
            sb.Append("]");
        }
        sb.Append("},");
        
        // NF pozisyonları
        sb.Append("\"nf_positions\":{");
        var nfFirst = true;
        foreach (var kv in nfPos) {
            if (!nfFirst) sb.Append(",");
            nfFirst = false;
            var p = kv.Value;
            var nfC = nfContracts.ContainsKey(kv.Key) ? nfContracts[kv.Key] : new string[] { GetContract(kv.Key, 0), GetContract(kv.Key, 1) };
            // [nearQty, farQty, nearEntry, farEntry, entrySpread, expectedPnl, entryTicks, nearC, farC]
            sb.Append("\"" + kv.Key + "\":{");
            sb.Append("\"nq\":" + ((int)p[0]).ToString() + ",");           // nearQty
            sb.Append("\"fq\":" + ((int)p[1]).ToString() + ",");           // farQty
            sb.Append("\"ne\":" + p[2].ToString("F4", ic) + ",");          // nearEntry
            sb.Append("\"fe\":" + p[3].ToString("F4", ic) + ",");          // farEntry
            sb.Append("\"es\":" + p[4].ToString("F6", ic) + ",");          // entrySpread
            sb.Append("\"ep\":" + p[5].ToString("F2", ic) + ",");          // expectedPnl
            sb.Append("\"et\":" + (p.Length > 6 ? (long)p[6] : DateTime.Now.Ticks).ToString() + ",");  // entryTicks
            sb.Append("\"nc\":\"" + nfC[0] + "\",");                        // nearContract
            sb.Append("\"fc\":\"" + nfC[1] + "\"}");                        // farContract
        }
        sb.Append("},");
        
        // Yetim bacaklar
        sb.Append("\"orphan_legs\":{");
        var orphFirst = true;
        foreach (var kv in orphanLegs) {
            if (!orphFirst) sb.Append(",");
            orphFirst = false;
            var o = kv.Value;
            // [filledLeg, filledCode, filledSide, filledQty, filledPrice, targetLeg, targetCode, targetSide, targetQty, timestamp]
            sb.Append("\"" + kv.Key + "\":{");
            sb.Append("\"fl\":\"" + o[0] + "\",");              // filledLeg
            sb.Append("\"fc\":\"" + o[1] + "\",");              // filledCode
            sb.Append("\"fs\":\"" + o[2] + "\",");              // filledSide
            sb.Append("\"fq\":" + ((int)o[3]).ToString() + ","); // filledQty
            sb.Append("\"fp\":" + ((decimal)o[4]).ToString("F4", ic) + ","); // filledPrice
            sb.Append("\"tl\":\"" + o[5] + "\",");              // targetLeg
            sb.Append("\"tc\":\"" + o[6] + "\",");              // targetCode
            sb.Append("\"ts\":\"" + o[7] + "\",");              // targetSide
            sb.Append("\"tq\":" + ((int)o[8]).ToString() + ","); // targetQty
            sb.Append("\"t\":" + ((long)o[9]).ToString() + "}"); // timestamp
        }
        sb.Append("},");
        
        // Pair pozisyonları
        sb.Append("\"pair_positions\":{");
        var pairFirst = true;
        foreach (var kv in pairPos) {
            if (!pairFirst) sb.Append(",");
            pairFirst = false;
            var p = kv.Value;
            var pairC = pairContracts.ContainsKey(kv.Key) ? pairContracts[kv.Key] : new string[] { "", "" };
            sb.Append("\"" + kv.Key + "\":{");
            sb.Append("\"qa\":" + ((int)p[0]).ToString() + ",");    // qtyA
            sb.Append("\"qb\":" + ((int)p[1]).ToString() + ",");    // qtyB
            sb.Append("\"aa\":" + p[2].ToString("F4", ic) + ",");   // avgA
            sb.Append("\"ab\":" + p[3].ToString("F4", ic) + ",");   // avgB
            sb.Append("\"oz\":" + p[4].ToString("F2", ic) + ",");   // openZ
            sb.Append("\"ti\":" + ((int)p[5]).ToString() + ",");    // tier
            sb.Append("\"et\":" + ((long)p[6]).ToString() + ",");   // entryTicks
            sb.Append("\"ep\":" + (p.Length > 7 ? p[7] : 0m).ToString("F0", ic) + ",");   // expectedPnl
            sb.Append("\"ca\":\"" + pairC[0] + "\",");              // contractA
            sb.Append("\"cb\":\"" + pairC[1] + "\"}");              // contractB
        }
        sb.Append("},");
        sb.Append("\"pair_used\":" + pairUsed.ToString("F0", ic) + ",");
        sb.Append("\"pair_definitions\":\"" + PAIR_DEFINITIONS.Replace("\"", "\\\"") + "\"}");
        SafeWrite(POSITIONS_FILE, sb.ToString());
    } catch (Exception ex) { Log("Pozisyon kaydetme hata: " + ex.Message); }
};

// Pozisyon yükleme (dosyadan)
Action LoadPositions = () => {
    try {
        if (!System.IO.File.Exists(POSITIONS_FILE)) return;
        var json = System.IO.File.ReadAllText(POSITIONS_FILE);
        var ic = System.Globalization.CultureInfo.InvariantCulture;
        
        // Önce kullanım değerlerini sıfırla (çift yükleme güvenliği)
        viopUsed = 0m;
        spotUsed = 0m;
        nfViopUsed = 0m;
        
        var posIdx = json.IndexOf("\"positions\"");
        if (posIdx == -1) return;
        var posStart = json.IndexOf("{", posIdx) + 1;
        var posEnd = json.IndexOf("}}", posStart);
        if (posStart <= 0 || posEnd <= posStart) return;
        
        var posContent = json.Substring(posStart, posEnd - posStart);
        var loaded = 0;
        
        // "THYAO":[1500,15,79.55,80.06,0.025,150.5,0,638766123456789]
        var pos = 0;
        while (pos < posContent.Length) {
            var q1 = posContent.IndexOf("\"", pos);
            if (q1 < 0) break;
            var q2 = posContent.IndexOf("\"", q1 + 1);
            if (q2 < 0) break;
            var sym = posContent.Substring(q1 + 1, q2 - q1 - 1);
            
            var arrStart = posContent.IndexOf("[", q2);
            var arrEnd = posContent.IndexOf("]", arrStart);
            if (arrStart < 0 || arrEnd < 0) break;
            
            var arrStr = posContent.Substring(arrStart + 1, arrEnd - arrStart - 1);
            var parts = arrStr.Split(',');
            if (parts.Length >= 7) {
                var p = new decimal[8];
                p[0] = decimal.Parse(parts[0].Trim(), ic);  // spotQty
                p[1] = decimal.Parse(parts[1].Trim(), ic);  // nearQty
                p[2] = decimal.Parse(parts[2].Trim(), ic);  // spotEntry
                p[3] = decimal.Parse(parts[3].Trim(), ic);  // nearEntry
                p[4] = decimal.Parse(parts[4].Trim(), ic);  // entrySpread
                p[5] = decimal.Parse(parts[5].Trim(), ic);  // expectedPnl
                p[6] = decimal.Parse(parts[6].Trim(), ic);  // addCount
                // entryTicks - 8. eleman varsa oku, yoksa şimdi oluştur
                p[7] = parts.Length >= 8 ? decimal.Parse(parts[7].Trim(), ic) : DateTime.Now.Ticks;
                
                // expectedPnl 0 ise yeniden hesapla
                if (p[5] == 0 && p[4] > 0 && p[2] > 0 && p[0] > 0) {
                    // expectedPnl = entrySpread * spotEntry * spotQty
                    p[5] = p[4] * p[2] * p[0];
                    Log("⚠️ " + sym + " expectedPnl yeniden hesaplandı: " + p[5].ToString("N0"));
                }
                
                snPos[sym] = p;
                // Sembolü listeye ekle (recovery için gerekli)
                if (!symbols.Contains(sym)) symbols.Add(sym);
                loaded++;
            }
            pos = arrEnd + 1;
        }
        
        if (loaded > 0) {
            Log("📂 Pozisyonlar yüklendi: " + loaded + " adet");
            // Bütçe kullanımını güncelle
            foreach (var kv in snPos) {
                var p = kv.Value;
                var tem = teminat.ContainsKey(kv.Key) ? teminat[kv.Key] : 0;
                spotUsed += p[2] * p[0];  // spotEntry * spotQty
                viopUsed += tem * p[1];   // teminat * nearQty
            }
            if (IS_TEST) {
                Log("Bütçe: VIOP=" + viopUsed.ToString("N0") + "/" + VIOP_BUDGET.ToString("N0") + 
                    " SPOT=" + spotUsed.ToString("N0") + "/" + SPOT_BUDGET.ToString("N0"));
            } else {
                Log("Pozisyon kullanımı: VIOP=" + viopUsed.ToString("N0") + " SPOT=" + spotUsed.ToString("N0"));
            }
        }
        
        // NF pozisyonları yükle (yeni format: object, eski format: array - backward compatible)
        var nfPosIdx = json.IndexOf("\"nf_positions\"");
        if (nfPosIdx != -1) {
            var nfPosStart = json.IndexOf("{", nfPosIdx) + 1;
            var nfPosEnd = json.IndexOf("}}", nfPosStart);
            if (nfPosStart > 0 && nfPosEnd > nfPosStart) {
                var nfPosContent = json.Substring(nfPosStart, nfPosEnd - nfPosStart);
                var nfLoaded = 0;
                var nfPos2 = 0;
                while (nfPos2 < nfPosContent.Length) {
                    var nfQ1 = nfPosContent.IndexOf("\"", nfPos2);
                    if (nfQ1 < 0) break;
                    var nfQ2 = nfPosContent.IndexOf("\"", nfQ1 + 1);
                    if (nfQ2 < 0) break;
                    var nfSym = nfPosContent.Substring(nfQ1 + 1, nfQ2 - nfQ1 - 1);
                    
                    // Yeni format mı (object) eski format mı (array) kontrol et
                    var nextChar = nfPosContent.IndexOf(":", nfQ2);
                    if (nextChar < 0) break;
                    var formatChar = nfPosContent.Substring(nextChar + 1).TrimStart()[0];
                    
                    if (formatChar == '{') {
                        // YENİ FORMAT: {"THYAO":{"nq":1,"fq":1,"ne":80.5,"fe":81.2,"es":0.005,"ep":50,"et":123456,"nc":"F_THYAO0226","fc":"F_THYAO0326"}}
                        var objStart = nfPosContent.IndexOf("{", nextChar);
                        var objEnd = nfPosContent.IndexOf("}", objStart);
                        if (objStart < 0 || objEnd < 0) break;
                        
                        var objStr = nfPosContent.Substring(objStart, objEnd - objStart + 1);
                        var nfP = new decimal[7];
                        
                        // Manuel parse helper
                        Func<string, string, decimal> parseNfDecimal = (src, key) => {
                            var idx = src.IndexOf("\"" + key + "\":");
                            if (idx < 0) return 0;
                            var start = idx + key.Length + 3;
                            var end = src.IndexOfAny(new[] { ',', '}' }, start);
                            if (end < 0) return 0;
                            decimal val;
                            decimal.TryParse(src.Substring(start, end - start).Trim(), System.Globalization.NumberStyles.Any, ic, out val);
                            return val;
                        };
                        
                        Func<string, string, string, string> parseNfString = (src, key, def) => {
                            var idx = src.IndexOf("\"" + key + "\":\"");
                            if (idx < 0) return def;
                            var start = idx + key.Length + 4;
                            var end = src.IndexOf("\"", start);
                            if (end < 0) return def;
                            return src.Substring(start, end - start);
                        };
                        
                        // Parse fields
                        nfP[0] = parseNfDecimal(objStr, "nq");
                        nfP[1] = parseNfDecimal(objStr, "fq");
                        nfP[2] = parseNfDecimal(objStr, "ne");
                        nfP[3] = parseNfDecimal(objStr, "fe");
                        nfP[4] = parseNfDecimal(objStr, "es");
                        nfP[5] = parseNfDecimal(objStr, "ep");
                        var etVal = parseNfDecimal(objStr, "et");
                        nfP[6] = etVal > 0 ? etVal : DateTime.Now.Ticks;
                        
                        // Kontrat kodları
                        var nearC = parseNfString(objStr, "nc", GetContract(nfSym, 0));
                        var farC = parseNfString(objStr, "fc", GetContract(nfSym, 1));
                        
                        nfPos[nfSym] = nfP;
                        nfContracts[nfSym] = new string[] { nearC, farC };
                        nfLoaded++;
                        
                        // NF VIOP kullanımı
                        var nfTem = teminat.ContainsKey(nfSym) ? teminat[nfSym] : 5000m;
                        nfViopUsed += nfTem * 2;
                        
                        nfPos2 = objEnd + 1;
                    } else {
                        // ESKİ FORMAT (backward compatible): {"THYAO":[1,1,80.5,81.2,0.005,50,123456]}
                        var nfArrStart = nfPosContent.IndexOf("[", nfQ2);
                        var nfArrEnd = nfPosContent.IndexOf("]", nfArrStart);
                        if (nfArrStart < 0 || nfArrEnd < 0) break;
                        
                        var nfArrStr = nfPosContent.Substring(nfArrStart + 1, nfArrEnd - nfArrStart - 1);
                        var nfParts = nfArrStr.Split(',');
                        if (nfParts.Length >= 6) {
                            var nfP = new decimal[7];
                            nfP[0] = decimal.Parse(nfParts[0].Trim(), ic);  // nearQty
                            nfP[1] = decimal.Parse(nfParts[1].Trim(), ic);  // farQty
                            nfP[2] = decimal.Parse(nfParts[2].Trim(), ic);  // nearEntry
                            nfP[3] = decimal.Parse(nfParts[3].Trim(), ic);  // farEntry
                            nfP[4] = decimal.Parse(nfParts[4].Trim(), ic);  // entrySpread
                            nfP[5] = decimal.Parse(nfParts[5].Trim(), ic);  // expectedPnl
                            nfP[6] = nfParts.Length >= 7 ? decimal.Parse(nfParts[6].Trim(), ic) : DateTime.Now.Ticks;
                            
                            nfPos[nfSym] = nfP;
                            // Eski formatta kontrat kodu yok - GetContract kullan (UYARI: vade geçişinde yanlış olabilir!)
                            nfContracts[nfSym] = new string[] { GetContract(nfSym, 0), GetContract(nfSym, 1) };
                            Log("⚠️ NF " + nfSym + " eski formattan yüklendi - kontrat kodları güncel aydan alındı");
                            nfLoaded++;
                            
                            // NF VIOP kullanımı
                            var nfTem = teminat.ContainsKey(nfSym) ? teminat[nfSym] : 5000m;
                            nfViopUsed += nfTem * 2;
                        }
                        nfPos2 = nfArrEnd + 1;
                    }
                }
                if (nfLoaded > 0) {
                    Log("📂 NF Pozisyonlar yüklendi: " + nfLoaded + " adet, VIOP kullanım: " + nfViopUsed.ToString("N0"));
                }
            }
        }
        
        // Yetim bacaklar yükle
        var orphIdx = json.IndexOf("\"orphan_legs\"");
        if (orphIdx != -1) {
            var orphStart = json.IndexOf("{", orphIdx) + 1;
            var orphEnd = json.IndexOf("}}", orphStart);
            if (orphStart > 0 && orphEnd > orphStart) {
                var orphContent = json.Substring(orphStart, orphEnd - orphStart);
                var orphLoaded = 0;
                
                // JSON parse: "THYAO":{"fl":"NEAR","fc":"F_THYAO0126",...}
                var orphPos = 0;
                while (orphPos < orphContent.Length) {
                    var oQ1 = orphContent.IndexOf("\"", orphPos);
                    if (oQ1 < 0) break;
                    var oQ2 = orphContent.IndexOf("\"", oQ1 + 1);
                    if (oQ2 < 0) break;
                    var oSym = orphContent.Substring(oQ1 + 1, oQ2 - oQ1 - 1);
                    
                    var oObjStart = orphContent.IndexOf("{", oQ2);
                    var oObjEnd = orphContent.IndexOf("}", oObjStart);
                    if (oObjStart < 0 || oObjEnd < 0) break;
                    
                    var oObj = orphContent.Substring(oObjStart, oObjEnd - oObjStart + 1);
                    
                    // Parse fields
                    Func<string, string> getStr = (key) => {
                        var ki = oObj.IndexOf("\"" + key + "\":\"");
                        if (ki < 0) return "";
                        var vs = ki + key.Length + 4;
                        var ve = oObj.IndexOf("\"", vs);
                        return ve > vs ? oObj.Substring(vs, ve - vs) : "";
                    };
                    Func<string, decimal> getNum = (key) => {
                        var ki = oObj.IndexOf("\"" + key + "\":");
                        if (ki < 0) return 0;
                        var vs = ki + key.Length + 3;
                        var ve = vs;
                        while (ve < oObj.Length && (char.IsDigit(oObj[ve]) || oObj[ve] == '.' || oObj[ve] == '-')) ve++;
                        return ve > vs ? decimal.Parse(oObj.Substring(vs, ve - vs), ic) : 0;
                    };
                    
                    orphanLegs[oSym] = new object[] {
                        getStr("fl"),   // filledLeg
                        getStr("fc"),   // filledCode
                        getStr("fs"),   // filledSide
                        (int)getNum("fq"), // filledQty
                        getNum("fp"),   // filledPrice
                        getStr("tl"),   // targetLeg
                        getStr("tc"),   // targetCode
                        getStr("ts"),   // targetSide
                        (int)getNum("tq"), // targetQty
                        (long)getNum("t")  // timestamp
                    };
                    orphLoaded++;
                    orphPos = oObjEnd + 1;
                }
                if (orphLoaded > 0) {
                    Log("📂 Yetim bacaklar yüklendi: " + orphLoaded + " adet");
                    foreach (var kv in orphanLegs) {
                        var o = kv.Value;
                        Log("   " + kv.Key + ": " + o[0] + " " + o[1] + " " + o[2] + " x" + o[3] + " @" + ((decimal)o[4]).ToString("F2"));
                    }
                }
            }
        }
        
        // Pair pozisyonları yükle (yeni format: object ile kontrat bilgisi)
        pairUsed = 0m;  // Önce sıfırla, sonra hesapla (çift yükleme güvenliği)
        var pairPosIdx = json.IndexOf("\"pair_positions\"");
        if (pairPosIdx >= 0) {
            var pairPosStart = json.IndexOf("{", pairPosIdx) + 1;
            // pair_positions içeriği için doğru sonlanma noktasını bul
            var braceCount = 1;
            var pairPosEnd = pairPosStart;
            while (pairPosEnd < json.Length && braceCount > 0) {
                if (json[pairPosEnd] == '{') braceCount++;
                else if (json[pairPosEnd] == '}') braceCount--;
                pairPosEnd++;
            }
            pairPosEnd--;  // Son '}'nin pozisyonu
            
            if (pairPosStart > 0 && pairPosEnd > pairPosStart) {
                var pairContent = json.Substring(pairPosStart, pairPosEnd - pairPosStart);
                var pairLoaded = 0;
                
                // Her çift için parse et
                var ppos = 0;
                while (ppos < pairContent.Length) {
                    var pq1 = pairContent.IndexOf("\"", ppos);
                    if (pq1 < 0) break;
                    var pq2 = pairContent.IndexOf("\"", pq1 + 1);
                    if (pq2 < 0) break;
                    var pkey = pairContent.Substring(pq1 + 1, pq2 - pq1 - 1);
                    
                    // Yeni format: object {...} veya eski format: array [...]
                    var nextChar = ':';
                    var colonPos = pairContent.IndexOf(":", pq2);
                    if (colonPos < 0) break;
                    
                    // Object mı array mi?
                    var afterColon = pairContent.Substring(colonPos + 1).TrimStart();
                    if (afterColon.StartsWith("{")) {
                        // Yeni format: object
                        var objStart = pairContent.IndexOf("{", colonPos);
                        var objEnd = pairContent.IndexOf("}", objStart);
                        if (objStart < 0 || objEnd < 0) break;
                        
                        var objStr = pairContent.Substring(objStart + 1, objEnd - objStart - 1);
                        var pp = new decimal[8];
                        string contractA = "", contractB = "";
                        
                        // Parse object fields
                        Func<string, string, string> getField = (content, field) => {
                            var idx = content.IndexOf("\"" + field + "\"");
                            if (idx < 0) return "";
                            var valStart = content.IndexOf(":", idx) + 1;
                            var valEnd = content.IndexOf(",", valStart);
                            if (valEnd < 0) valEnd = content.Length;
                            return content.Substring(valStart, valEnd - valStart).Trim().Trim('"');
                        };
                        
                        decimal.TryParse(getField(objStr, "qa"), System.Globalization.NumberStyles.Any, ic, out pp[0]);
                        decimal.TryParse(getField(objStr, "qb"), System.Globalization.NumberStyles.Any, ic, out pp[1]);
                        decimal.TryParse(getField(objStr, "aa"), System.Globalization.NumberStyles.Any, ic, out pp[2]);
                        decimal.TryParse(getField(objStr, "ab"), System.Globalization.NumberStyles.Any, ic, out pp[3]);
                        decimal.TryParse(getField(objStr, "oz"), System.Globalization.NumberStyles.Any, ic, out pp[4]);
                        decimal.TryParse(getField(objStr, "ti"), System.Globalization.NumberStyles.Any, ic, out pp[5]);
                        decimal.TryParse(getField(objStr, "et"), System.Globalization.NumberStyles.Any, ic, out pp[6]);
                        decimal.TryParse(getField(objStr, "ep"), System.Globalization.NumberStyles.Any, ic, out pp[7]);
                        contractA = getField(objStr, "ca");
                        contractB = getField(objStr, "cb");
                        
                        pairPos[pkey] = pp;
                        
                        // Kontratları yükle (boş değilse)
                        if (!string.IsNullOrEmpty(contractA) && !string.IsNullOrEmpty(contractB)) {
                            pairContracts[pkey] = new string[] { contractA, contractB };
                        }
                        
                        pairLoaded++;
                        ppos = objEnd + 1;
                    } else if (afterColon.StartsWith("[")) {
                        // Eski format: array (backward compatibility)
                        var arrStart = pairContent.IndexOf("[", colonPos);
                        var arrEnd = pairContent.IndexOf("]", arrStart);
                        if (arrStart < 0 || arrEnd < 0) break;
                        
                        var arrStr = pairContent.Substring(arrStart + 1, arrEnd - arrStart - 1);
                        var parts = arrStr.Split(',');
                        if (parts.Length >= 7) {
                            var pp = new decimal[8];
                            for (int pi = 0; pi < Math.Min(parts.Length, 8); pi++) {
                                decimal.TryParse(parts[pi].Trim(), System.Globalization.NumberStyles.Any, ic, out pp[pi]);
                            }
                            pairPos[pkey] = pp;
                            pairLoaded++;
                        }
                        ppos = arrEnd + 1;
                    } else {
                        break;
                    }
                    
                    // Pair VIOP kullanımı hesapla
                    if (pairPos.ContainsKey(pkey)) {
                        var keyParts = pkey.Split('-');
                        if (keyParts.Length == 2) {
                            var temA = teminat.ContainsKey(keyParts[0]) ? teminat[keyParts[0]] : 1000m;
                            var temB = teminat.ContainsKey(keyParts[1]) ? teminat[keyParts[1]] : 1000m;
                            var pp = pairPos[pkey];
                            pairUsed += (int)pp[0] * temA + (int)pp[1] * temB;
                        }
                    }
                }
                if (pairLoaded > 0) {
                    Log("📂 Pair pozisyonları yüklendi: " + pairLoaded + " adet, Teminat: " + pairUsed.ToString("F0"));
                    if (pairContracts.Count > 0) {
                        Log("📂 Pair kontratları yüklendi: " + pairContracts.Count + " adet");
                    }
                }
            }
        }
        
        // pair_definitions yükle (yeni çift tanımları)
        var pairDefsIdx = json.IndexOf("\"pair_definitions\"");
        if (pairDefsIdx >= 0) {
            var pdStart = json.IndexOf("\"", pairDefsIdx + 18) + 1;
            var pdEnd = json.IndexOf("\"", pdStart);
            if (pdStart > 0 && pdEnd > pdStart) {
                PAIR_DEFINITIONS = json.Substring(pdStart, pdEnd - pdStart);
                ParsePairDefinitions();
            }
        }
    } catch (Exception ex) { Log("Pozisyon yükleme hata: " + ex.Message); }
};

// Bakiye güncelleme (test vs gerçek mod)
Action UpdateBalances = () => {
    try {
        if (IS_TEST) {
            // Test modu: Sanal bakiye hesapla (ayarlardan okunan bütçe ile)
            viopBalance = VIOP_BUDGET - viopUsed - VIOP_RESERVE;
            spotBalance = SPOT_BUDGET - spotUsed - dailySpotCommission - totalTransferredComm - SPOT_BUDGET_RESERVE;
            spotBudgetTotal = SPOT_BUDGET - dailySpotCommission - totalTransferredComm;
            if (viopBalance < 0) viopBalance = 0;
            if (spotBalance < 0) spotBalance = 0;
            apiDataOk = true;
        } else {
            // Gerçek mod: API'den al (T+2 RefreshHesaplar içinde hesaplanıyor)
            RefreshHesaplar(false);
            var viopOk = false;
            var spotOk = false;
            
            // VIOP bakiye
            try {
                var viopHesap = GetViopHesap();
                if (viopHesap != null && viopHesap.TeminatKullanilabilir > 0) {
                    viopBalance = (decimal)viopHesap.TeminatKullanilabilir - VIOP_RESERVE;
                    if (viopBalance < 0) viopBalance = 0;
                    viopOk = true;
                }
            } catch { }
            
            // SPOT: T+2 zaten RefreshHesaplar'da hesaplandı
            try {
                var bistHesap = GetBistHesap();
                if (bistHesap != null && bistHesap.Bakiye > 0) {
                    spotOk = true;
                    // spotBalance ve spotBudgetTotal güncelle (SPOT_BUDGET_RESERVE düşülür)
                    spotBalance = t2Balance - SPOT_BUDGET_RESERVE;
                    if (spotBalance < 0) spotBalance = 0;
                    spotBudgetTotal = spotUsed + t2Balance;
                    
                    // T+2 negatif takibi
                    if (t2Balance < 0) {
                        if (!t2NegativeDetected) {
                            t2NegativeDetected = true;
                            t2NegativeTime = DateTime.Now;
                            Log("⚠️ T+2 bakiye negatif: " + t2Balance.ToString("N0") + " - takibe alındı, 16:50'de kontrol edilecek");
                        }
                        // 17:00 sonrası hala negatifse kritik uyarı
                        var t2Hour = DateTime.Now.Hour;
                        if (t2Hour >= 17 && !t2CriticalAlert) {
                            t2CriticalAlert = true;
                            Log("🚨 T+2 KRİTİK: 17:00 sonrası hala negatif: " + t2Balance.ToString("N0") + " TL");
                        }
                    } else {
                        if (t2NegativeDetected) {
                            Log("✅ T+2 bakiye pozitife döndü: " + t2Balance.ToString("N0"));
                            t2NegativeDetected = false;
                        }
                        if (t2CriticalAlert) {
                            Log("✅ T+2 kritik uyarı kaldırıldı - bakiye pozitif: " + t2Balance.ToString("N0"));
                            t2CriticalAlert = false;
                        }
                    }
                }
            } catch { }
            
            // Her iki API de gelmeli
            apiDataOk = viopOk && spotOk;
            
            if (!apiDataOk && isMarketOpen) {
                Log("⚠️ API verisi alınamadı - işlemler duraklatıldı");
            }
            
            // Margin durumu kontrol et
            if (!inMarginCheck && apiDataOk) CheckMarginStatus();
        }
    } catch { }
};

// VİOP komisyonlarını SPOT'a transfer et (15 dakikada bir)
Action TransferViopCommission = () => {
    if (dailyViopCommission > 0) {
        Log("💸 VİOP komisyon transferi: " + dailyViopCommission.ToString("N2") + " TL → SPOT");
        totalTransferredComm += dailyViopCommission;
        dailyViopCommission = 0;
        lastCommissionTransfer = DateTime.Now;
    }
};

// Aracı kurum bağlantı kontrolü (30 saniyede bir)
Action CheckBrokerConnection = () => {
    // brokerConnected artık RefreshHesaplar/Recovery tarafından güncelleniyor
    // Burada sadece cache'in null olup olmadığına bakıyoruz, ekstra API çağrısı yok
    if ((DateTime.Now - lastBrokerCheck).TotalSeconds < 30) return;
    lastBrokerCheck = DateTime.Now;
    
    var wasConnected = brokerConnected;
    
    // Cache'deki son değerlere bak (API çağrısı yapmadan)
    var viopOk = _viopHesap != null;
    var bistOk = _bistHesap != null;
    brokerConnected = viopOk || bistOk;
    
    // Durum değişti mi?
    if (wasConnected && !brokerConnected) {
        Log("⚠️ Aracı kurum bağlantısı kesildi!");
    } else if (!wasConnected && brokerConnected) {
        Log("✅ Aracı kurum bağlantısı kuruldu");
        // Bağlantı geri geldi - recovery tetikle
        if (!IS_TEST) {
            Log("🔄 Bağlantı sonrası pozisyon senkronizasyonu başlatılıyor...");
            SyncAndRecoverPositions();
        }
    }
};

// Kritik margin durumunda pozisyon kapatma (en kötü beklenen getirili pozisyonu kapat)
Action<decimal, decimal> HandleMarginCritical = (kullanilabilir, toplam) => {
    if (IS_TEST) return;
    if (inMarginCheck) return;
    
    inMarginCheck = true;
    try {
        if (snPos.Count == 0) return;
        
        // En kötü beklenen getirili pozisyonu bul
        string worstSym = null;
        decimal worstExpectedPnl = decimal.MaxValue;
        
        foreach (var kv in snPos) {
            var expectedPnl = kv.Value[5];
            if (expectedPnl < worstExpectedPnl) {
                worstExpectedPnl = expectedPnl;
                worstSym = kv.Key;
            }
        }
        
        if (worstSym == null) return;
        
        // En kötü pozisyonu kapat
        var pos = snPos[worstSym];
        var sQty = (int)pos[0];
        var nQty = (int)pos[1];
        var nearC = GetContract(worstSym, 0);
        
        Log("🔴 MARGIN CALL: " + worstSym + " kapatılıyor (Beklenen: " + worstExpectedPnl.ToString("F0") + " TL)");
        CloseSN(worstSym, nearC, sQty, nQty, "MARGIN_CALL");
        
        // Son durumu kontrol et
        System.Threading.Thread.Sleep(500);
        try {
            var viopHesap = Sistem.ViopHesapOku();
            if (viopHesap != null) {
                var teminatToplam = (decimal)viopHesap.TeminatToplam;
                if (teminatToplam <= 0) return;  // Bölme hatası önleme
                var yeniOran = (decimal)viopHesap.TeminatKullanilabilir / teminatToplam;
                if (yeniOran >= MARGIN_WARNING_PCT) marginStatus = 0;
                else if (yeniOran >= MARGIN_DANGER_PCT) marginStatus = 1;
                else if (yeniOran >= MARGIN_CRITICAL_PCT) marginStatus = 2;
                else marginStatus = 3;
                _viopHesap = viopHesap;
                Log("✅ MARGIN: Yeni serbest %" + (yeniOran * 100).ToString("F1"));
            }
        } catch { }
    } finally {
        inMarginCheck = false;
    }
};

// Margin durumu kontrolü (RefreshHesaplar'dan tetiklenir)
CheckMarginStatus = () => {
    try {
        var viopHesap = GetViopHesap();
        if (viopHesap == null) return;
        
        var kullanilabilir = (decimal)viopHesap.TeminatKullanilabilir;
        var toplam = (decimal)viopHesap.TeminatToplam;
        if (toplam <= 0) return;
        
        var serbestOran = kullanilabilir / toplam;
        var oldStatus = marginStatus;
        
        // Durumu belirle
        if (serbestOran < MARGIN_CRITICAL_PCT) {
            marginStatus = 3;  // Kritik (kırmızı)
        } else if (serbestOran < MARGIN_DANGER_PCT) {
            marginStatus = 2;  // Tehlike (turuncu)
        } else if (serbestOran < MARGIN_WARNING_PCT) {
            marginStatus = 1;  // Uyarı (sarı)
        } else {
            marginStatus = 0;  // Normal
        }
        
        // Durum değişti mi? Sadece değişince logla
        if (marginStatus != oldStatus) {
            if (marginStatus == 1) {
                Log("⚠️ MARGIN UYARI: Serbest %" + (serbestOran * 100).ToString("F1"));
            } else if (marginStatus == 2) {
                Log("🟠 MARGIN TEHLİKE: Serbest %" + (serbestOran * 100).ToString("F1"));
            } else if (marginStatus == 3) {
                Log("🔴 MARGIN KRİTİK: Serbest %" + (serbestOran * 100).ToString("F1") + " - Pozisyon kapatılıyor");
                HandleMarginCritical(kullanilabilir, toplam);
            } else if (marginStatus == 0 && oldStatus > 0) {
                Log("✅ MARGIN NORMAL: Serbest %" + (serbestOran * 100).ToString("F1"));
            }
        }
    } catch { }
};

// Endeks devre kesici kontrolü (BIST100)
Action CheckIndexCircuitBreaker = () => {
    try {
        var change = (decimal)Sistem.YuzdeGun("IMKBX'XU100");
        var wasActive = indexCircuitBreaker;
        
        // %5 veya daha fazla düşüş = devre kesici aktif
        if (change <= INDEX_CIRCUIT_PCT) {
            indexCircuitBreaker = true;
            if (!wasActive) {
                Log("🔴 ENDEKS DEVRE KESİCİ AKTİF: BIST100 %" + change.ToString("F2") + " (eşik: %" + INDEX_CIRCUIT_PCT.ToString("F0") + ")");
            }
        } else {
            indexCircuitBreaker = false;
            if (wasActive) {
                Log("✅ ENDEKS DEVRE KESİCİ KALDIRILDI: BIST100 %" + change.ToString("F2"));
            }
        }
    } catch { }
};

// Spot devre kesici kontrolü (bireysel hisse) - %8 düşüş
Func<string, bool> IsSpotCircuitBreaker = (sym) => {
    try {
        var change = (decimal)Sistem.YuzdeGun("IMKBH'" + sym);
        
        // %8 veya daha fazla düşüş = devre kesici
        if (change <= SPOT_CIRCUIT_PCT) {
            if (!spotCircuitBreakers.Contains(sym)) {
                spotCircuitBreakers.Add(sym);
                Log("🔴 SPOT DEVRE KESİCİ: " + sym + " %" + change.ToString("F2") + " (eşik: %" + SPOT_CIRCUIT_PCT.ToString("F0") + ")");
            }
            return true;
        } else {
            if (spotCircuitBreakers.Contains(sym)) {
                spotCircuitBreakers.Remove(sym);
                Log("✅ SPOT DEVRE KESİCİ KALDIRILDI: " + sym + " %" + change.ToString("F2"));
            }
            return false;
        }
    } catch { return false; }
};

// Son recovery zamanı
var lastRecoveryCheck = DateTime.MinValue;
var recoveryTriggered = false;  // Başlangıç recovery'si yapıldı mı
var recoveryRetryNeeded = false;  // Teyit alınamadı, kısa süre sonra tekrar dene
var recoveryRetryTime = DateTime.MinValue;  // Retry zamanı

// Gerçek pozisyonları oku ve senkronize et (sadece normal mod)
SyncAndRecoverPositions = () => {
    if (IS_TEST) return;
    if (inRecovery) {
        Log("⚠️ RECOVERY: Zaten recovery içinde, atlanıyor (sonsuz döngü önleme)");
        return;
    }
    
    inRecovery = true;  // Sonsuz döngü önleme
    try {
        Log("🔍 RECOVERY: Gerçek pozisyonlar okunuyor...");
        
        // Taze veri için cache'i yenile
        RefreshHesaplar(false);  // Bekleme yok, her ikisini taze çek
        
        // 1. Aracı kurumdan gerçek pozisyonları oku
        var realSpotPos = new System.Collections.Generic.Dictionary<string, int>();  // sym -> qty
        var realNearPos = new System.Collections.Generic.Dictionary<string, int>();  // sym -> qty
        var bistOk = false;
        var viopOk = false;
        
        // BIST pozisyonları
        try {
            var bistHesap = GetBistHesap();
            
            if (bistHesap != null && bistHesap.Pozisyonlar != null) {
                bistOk = true;
                var bistPozList = bistHesap.Pozisyonlar;
                Log("🔍 RECOVERY: BIST'te " + bistPozList.Count + " pozisyon bulundu");
                for (int i = 0; i < bistPozList.Count; i++) {
                    var sym = bistPozList[i].Symbol;
                    var lot = (int)bistPozList[i].Lot;
                    Log("🔍 RECOVERY: BIST poz: " + sym + " Lot:" + lot);
                    if (sym != null) {
                        if (sym.Contains("'")) {
                            var idx = sym.IndexOf("'");
                            sym = sym.Substring(idx + 1);
                        } else if (sym.StartsWith("E_")) {
                            sym = sym.Substring(2);
                        }
                        if (symbols.Contains(sym)) {
                            realSpotPos[sym] = Math.Abs(lot);
                            Log("✓ RECOVERY: " + sym + " Spot pozisyon: " + Math.Abs(lot));
                        }
                    }
                }
            } else {
                Log("⚠️ RECOVERY: BIST hesap veya pozisyonlar null - SPOT recovery atlanıyor");
            }
        } catch (Exception ex) { 
            Log("⚠️ BIST pozisyon okuma hata: " + ex.Message); 
        }
        
        // VIOP pozisyonları
        try {
            var viopHesap = GetViopHesap();
            
            if (viopHesap != null && viopHesap.Pozisyonlar != null) {
                viopOk = true;
                var viopPozList = viopHesap.Pozisyonlar;
                Log("🔍 RECOVERY: VIOP'ta " + viopPozList.Count + " pozisyon bulundu");
                
                // NF için Near LONG ve Far SHORT pozisyonlarını da takip et
                // realNfNearPos[sym] = qty (LONG pozitif)
                // realNfFarPos[sym] = qty (SHORT pozitif olarak sakla)
                var realNfNearPos = new System.Collections.Generic.Dictionary<string, int>();
                var realNfFarPos = new System.Collections.Generic.Dictionary<string, int>();
                
                for (int i = 0; i < viopPozList.Count; i++) {
                    var sym = viopPozList[i].Symbol;
                    var lot = (int)viopPozList[i].NetAmount;
                    Log("🔍 RECOVERY: VIOP poz: " + sym + " Lot:" + lot);
                    if (sym != null && (sym.StartsWith("F_") || sym.Contains("'F_"))) {
                        // VIP'F_THYAO0225 veya F_THYAO0225 -> THYAO
                        var idx = sym.IndexOf("F_");
                        if (idx >= 0) {
                            var fullContract = sym.Substring(idx);  // F_THYAO0226
                            var baseSym = fullContract.Substring(2);  // THYAO0226
                            if (baseSym.Length > 4) baseSym = baseSym.Substring(0, baseSym.Length - 4);  // THYAO
                            
                            // PAIR_BLOCKED sembollerini atla (Pair Recovery'de işlenecek)
                            if (PAIR_BLOCKED.Contains(baseSym)) continue;
                            
                            if (symbols.Contains(baseSym)) {
                                // Kontratın Near mı Far mı olduğunu belirle
                                var nearContract = GetContract(baseSym, 0);
                                var farContract = GetContract(baseSym, 1);
                                var isNear = !string.IsNullOrEmpty(nearContract) && fullContract.Contains(nearContract.Replace("F_", ""));
                                var isFar = !string.IsNullOrEmpty(farContract) && fullContract.Contains(farContract.Replace("F_", ""));
                                
                                if (isNear) {
                                    // SN arbitrajda Near her zaman SHORT (negatif) olmalı
                                    if (lot < 0) {
                                        var qty = Math.Abs(lot);
                                        if (!realNearPos.ContainsKey(baseSym)) realNearPos[baseSym] = 0;
                                        realNearPos[baseSym] += qty;
                                        Log("✓ RECOVERY: " + baseSym + " Near SHORT: " + qty + " (SN)");
                                    } else if (lot > 0) {
                                        // NF stratejisinde Near LONG olabilir
                                        if (NF_ENABLED) {
                                            if (!realNfNearPos.ContainsKey(baseSym)) realNfNearPos[baseSym] = 0;
                                            realNfNearPos[baseSym] += lot;
                                            Log("✓ RECOVERY: " + baseSym + " Near LONG: " + lot + " (NF)");
                                        } else {
                                            Log("⚠️ RECOVERY: " + baseSym + " Near LONG: " + lot + " (YETİM - NF kapalı!)");
                                        }
                                    }
                                } else if (isFar) {
                                    // NF stratejisinde Far her zaman SHORT olmalı
                                    if (lot < 0) {
                                        var qty = Math.Abs(lot);
                                        if (!realNfFarPos.ContainsKey(baseSym)) realNfFarPos[baseSym] = 0;
                                        realNfFarPos[baseSym] += qty;
                                        Log("✓ RECOVERY: " + baseSym + " Far SHORT: " + qty + " (NF)");
                                    } else if (lot > 0) {
                                        Log("⚠️ RECOVERY: " + baseSym + " Far LONG: " + lot + " (YETİM!)");
                                    }
                                }
                            }
                        }
                    }
                }
                
                // ========== NF RECOVERY ==========
                if (NF_ENABLED && (realNfNearPos.Count > 0 || realNfFarPos.Count > 0 || nfPos.Count > 0)) {
                    Log("🔍 RECOVERY NF: Başlatılıyor...");
                    
                    // Tüm NF sembollerini topla
                    var nfSymbols = new System.Collections.Generic.HashSet<string>();
                    foreach (var kv in nfPos) nfSymbols.Add(kv.Key);
                    foreach (var kv in realNfNearPos) nfSymbols.Add(kv.Key);
                    foreach (var kv in realNfFarPos) nfSymbols.Add(kv.Key);
                    
                    foreach (var sym in nfSymbols) {
                        var ourNear = nfPos.ContainsKey(sym) ? (int)nfPos[sym][0] : 0;
                        var ourFar = nfPos.ContainsKey(sym) ? (int)nfPos[sym][1] : 0;
                        var brokerNear = realNfNearPos.ContainsKey(sym) ? realNfNearPos[sym] : 0;
                        var brokerFar = realNfFarPos.ContainsKey(sym) ? realNfFarPos[sym] : 0;
                        
                        var mismatch = false;
                        
                        // Durum 1: Broker'da var, bizde yok
                        if ((brokerNear > 0 || brokerFar > 0) && !nfPos.ContainsKey(sym)) {
                            Log("⚠️ RECOVERY NF: " + sym + " broker'da var ama nfPos'ta yok!");
                            Log("   Broker: Near=" + brokerNear + " Far=" + brokerFar);
                            
                            // Orphan durumu: Sadece bir bacak var
                            if (brokerNear > 0 && brokerFar == 0) {
                                // Near LONG var, Far SHORT yok
                                // Önce Far SHORT açmayı dene (spread uygunsa tamamla)
                                var nearContract = GetContract(sym, 0);
                                var farContract = GetContract(sym, 1);
                                var completed = false;
                                
                                if (!string.IsNullOrEmpty(farContract) && !string.IsNullOrEmpty(nearContract)) {
                                    // Spread kontrolü
                                    var nearDepth = Sistem.DerinlikVerisiOku("VIP'F_" + nearContract);
                                    var farDepth = Sistem.DerinlikVerisiOku("VIP'F_" + farContract);
                                    
                                    if (nearDepth != null && farDepth != null) {
                                        var nearBid = nearDepth.Bids != null && nearDepth.Bids.Length > 0 && nearDepth.Bids[0] != null ? (decimal)nearDepth.Bids[0].Price : 0m;
                                        var farAsk = farDepth.Asks != null && farDepth.Asks.Length > 0 && farDepth.Asks[0] != null ? (decimal)farDepth.Asks[0].Price : 0m;
                                        
                                        if (nearBid > 0 && farAsk > 0) {
                                            var spread = (farAsk - nearBid) / nearBid;
                                            var minSpread = 0.005m; // Minimum %0.5 spread
                                            
                                            if (spread >= minSpread) {
                                                Log("🔄 RECOVERY NF: " + sym + " ORPHAN - Far SHORT açılıyor (spread=" + (spread*100).ToString("F2") + "%)");
                                                var res = ExecGuar("F_" + farContract, "SELL", brokerNear);
                                                if (res.Item1 >= brokerNear) {
                                                    // Başarılı - nfPos'a ekle
                                                    var tem = teminat.ContainsKey(sym) ? teminat[sym] : 1000m;
                                                    nfPos[sym] = new decimal[] { brokerNear, res.Item1, nearBid, res.Item2, spread, 0, DateTime.Now.Ticks };
                                                    nfContracts[sym] = new string[] { nearContract, farContract };
                                                    nfViopUsed += (brokerNear + res.Item1) * tem;
                                                    Log("✅ RECOVERY NF: " + sym + " ORPHAN tamamlandı → Near=" + brokerNear + " Far=" + res.Item1);
                                                    completed = true;
                                                } else if (res.Item1 > 0) {
                                                    // Kısmi dolum - geri al
                                                    Log("⚠️ RECOVERY NF: " + sym + " Far kısmi doldu (" + res.Item1 + "/" + brokerNear + ") - geri alınıyor");
                                                    ExecGuar("F_" + farContract, "BUY", res.Item1);
                                                }
                                            } else {
                                                Log("📊 RECOVERY NF: " + sym + " spread yetersiz (" + (spread*100).ToString("F2") + "% < " + (minSpread*100).ToString("F1") + "%)");
                                            }
                                        }
                                    }
                                }
                                
                                // Tamamlanamadıysa Near'ı kapat
                                if (!completed && !string.IsNullOrEmpty(nearContract)) {
                                    Log("🚨 RECOVERY NF: " + sym + " ORPHAN - Near LONG kapatılıyor x" + brokerNear);
                                    var res = ExecGuar("F_" + nearContract, "SELL", brokerNear);
                                    if (res.Item1 > 0) {
                                        Log("✅ RECOVERY NF: " + sym + " Near LONG kapatıldı");
                                    }
                                }
                            } else if (brokerFar > 0 && brokerNear == 0) {
                                // Far SHORT var, Near LONG yok
                                // Önce Near LONG açmayı dene
                                var nearContract = GetContract(sym, 0);
                                var farContract = GetContract(sym, 1);
                                var completed = false;
                                
                                if (!string.IsNullOrEmpty(nearContract) && !string.IsNullOrEmpty(farContract)) {
                                    // Spread kontrolü
                                    var nearDepth = Sistem.DerinlikVerisiOku("VIP'F_" + nearContract);
                                    var farDepth = Sistem.DerinlikVerisiOku("VIP'F_" + farContract);
                                    
                                    if (nearDepth != null && farDepth != null) {
                                        var nearAsk = nearDepth.Asks != null && nearDepth.Asks.Length > 0 && nearDepth.Asks[0] != null ? (decimal)nearDepth.Asks[0].Price : 0m;
                                        var farBid = farDepth.Bids != null && farDepth.Bids.Length > 0 && farDepth.Bids[0] != null ? (decimal)farDepth.Bids[0].Price : 0m;
                                        
                                        if (nearAsk > 0 && farBid > 0) {
                                            var spread = (farBid - nearAsk) / nearAsk;
                                            var minSpread = 0.005m;
                                            
                                            if (spread >= minSpread) {
                                                Log("🔄 RECOVERY NF: " + sym + " ORPHAN - Near LONG açılıyor (spread=" + (spread*100).ToString("F2") + "%)");
                                                var res = ExecGuar("F_" + nearContract, "BUY", brokerFar);
                                                if (res.Item1 >= brokerFar) {
                                                    var tem = teminat.ContainsKey(sym) ? teminat[sym] : 1000m;
                                                    nfPos[sym] = new decimal[] { res.Item1, brokerFar, res.Item2, farBid, spread, 0, DateTime.Now.Ticks };
                                                    nfContracts[sym] = new string[] { nearContract, farContract };
                                                    nfViopUsed += (res.Item1 + brokerFar) * tem;
                                                    Log("✅ RECOVERY NF: " + sym + " ORPHAN tamamlandı → Near=" + res.Item1 + " Far=" + brokerFar);
                                                    completed = true;
                                                } else if (res.Item1 > 0) {
                                                    Log("⚠️ RECOVERY NF: " + sym + " Near kısmi doldu (" + res.Item1 + "/" + brokerFar + ") - geri alınıyor");
                                                    ExecGuar("F_" + nearContract, "SELL", res.Item1);
                                                }
                                            } else {
                                                Log("📊 RECOVERY NF: " + sym + " spread yetersiz (" + (spread*100).ToString("F2") + "%)");
                                            }
                                        }
                                    }
                                }
                                
                                // Tamamlanamadıysa Far'ı kapat
                                if (!completed && !string.IsNullOrEmpty(farContract)) {
                                    Log("🚨 RECOVERY NF: " + sym + " ORPHAN - Far SHORT kapatılıyor x" + brokerFar);
                                    var res = ExecGuar("F_" + farContract, "BUY", brokerFar);
                                    if (res.Item1 > 0) {
                                        Log("✅ RECOVERY NF: " + sym + " Far SHORT kapatıldı");
                                    }
                                }
                            } else if (brokerNear > 0 && brokerFar > 0) {
                                // Her iki bacak da var - nfPos'a ekle
                                Log("📥 RECOVERY NF: " + sym + " nfPos'a ekleniyor");
                                var tem = teminat.ContainsKey(sym) ? teminat[sym] : 1000m;
                                nfPos[sym] = new decimal[] { brokerNear, brokerFar, 0, 0, 0, 0, DateTime.Now.Ticks };
                                var nearC = GetContract(sym, 0);
                                var farC = GetContract(sym, 1);
                                if (!string.IsNullOrEmpty(nearC) && !string.IsNullOrEmpty(farC)) {
                                    nfContracts[sym] = new string[] { nearC, farC };
                                }
                                nfViopUsed += (brokerNear + brokerFar) * tem;
                                Log("✅ RECOVERY NF: " + sym + " eklendi → Near=" + brokerNear + " Far=" + brokerFar);
                            }
                            mismatch = true;
                        }
                        // Durum 2: Bizde var, broker'da yok
                        else if (nfPos.ContainsKey(sym) && brokerNear == 0 && brokerFar == 0) {
                            Log("🗑️ RECOVERY NF: " + sym + " nfPos'ta var ama broker'da yok - siliniyor");
                            Log("   nfPos: Near=" + ourNear + " Far=" + ourFar);
                            
                            var tem = teminat.ContainsKey(sym) ? teminat[sym] : 1000m;
                            nfViopUsed -= (ourNear + ourFar) * tem;
                            if (nfViopUsed < 0) nfViopUsed = 0;
                            
                            nfPos.Remove(sym);
                            if (nfContracts.ContainsKey(sym)) nfContracts.Remove(sym);
                            mismatch = true;
                        }
                        // Durum 3: Miktar uyumsuzluğu
                        else if (nfPos.ContainsKey(sym) && (ourNear != brokerNear || ourFar != brokerFar)) {
                            Log("⚠️ RECOVERY NF: " + sym + " miktar uyumsuzluğu!");
                            Log("   nfPos:  Near=" + ourNear + " Far=" + ourFar);
                            Log("   Broker: Near=" + brokerNear + " Far=" + brokerFar);
                            
                            if (brokerNear > 0 && brokerFar > 0) {
                                // Her iki taraf da var - güncelle
                                var p = nfPos[sym];
                                var tem = teminat.ContainsKey(sym) ? teminat[sym] : 1000m;
                                var oldTem = (ourNear + ourFar) * tem;
                                var newTem = (brokerNear + brokerFar) * tem;
                                
                                nfPos[sym] = new decimal[] { brokerNear, brokerFar, p[2], p[3], p[4], p[5], p[6] };
                                nfViopUsed = nfViopUsed - oldTem + newTem;
                                if (nfViopUsed < 0) nfViopUsed = 0;
                                
                                Log("✅ RECOVERY NF: " + sym + " güncellendi → Near=" + brokerNear + " Far=" + brokerFar);
                            } else if (brokerNear == 0 && brokerFar == 0) {
                                var tem = teminat.ContainsKey(sym) ? teminat[sym] : 1000m;
                                nfViopUsed -= (ourNear + ourFar) * tem;
                                if (nfViopUsed < 0) nfViopUsed = 0;
                                
                                nfPos.Remove(sym);
                                if (nfContracts.ContainsKey(sym)) nfContracts.Remove(sym);
                                Log("🗑️ RECOVERY NF: " + sym + " silindi");
                            } else {
                                // Tek taraf var - ORPHAN! Önce tamamlamayı dene, olmazsa kapat
                                Log("🚨 RECOVERY NF: " + sym + " ORPHAN! Broker: Near=" + brokerNear + " Far=" + brokerFar);
                                var completed = false;
                                
                                if (brokerNear > 0 && brokerFar == 0) {
                                    // Near LONG var, Far yok - önce Far açmayı dene
                                    var nearContract = GetContract(sym, 0);
                                    var farContract = GetContract(sym, 1);
                                    
                                    if (!string.IsNullOrEmpty(farContract) && !string.IsNullOrEmpty(nearContract)) {
                                        var nearDepth = Sistem.DerinlikVerisiOku("VIP'F_" + nearContract);
                                        var farDepth = Sistem.DerinlikVerisiOku("VIP'F_" + farContract);
                                        
                                        if (nearDepth != null && farDepth != null) {
                                            var nearBid = nearDepth.Bids != null && nearDepth.Bids.Length > 0 && nearDepth.Bids[0] != null ? (decimal)nearDepth.Bids[0].Price : 0m;
                                            var farAsk = farDepth.Asks != null && farDepth.Asks.Length > 0 && farDepth.Asks[0] != null ? (decimal)farDepth.Asks[0].Price : 0m;
                                            
                                            if (nearBid > 0 && farAsk > 0) {
                                                var spread = (farAsk - nearBid) / nearBid;
                                                if (spread >= 0.005m) {
                                                    Log("   Far SHORT açılıyor (spread=" + (spread*100).ToString("F2") + "%)");
                                                    var res = ExecGuar("F_" + farContract, "SELL", brokerNear);
                                                    if (res.Item1 >= brokerNear) {
                                                        var p = nfPos[sym];
                                                        nfPos[sym] = new decimal[] { brokerNear, res.Item1, p[2], res.Item2, spread, p[5], p[6] };
                                                        var tem3 = teminat.ContainsKey(sym) ? teminat[sym] : 1000m;
                                                        nfViopUsed += res.Item1 * tem3;
                                                        Log("   ✅ ORPHAN tamamlandı → Near=" + brokerNear + " Far=" + res.Item1);
                                                        completed = true;
                                                    } else if (res.Item1 > 0) {
                                                        ExecGuar("F_" + farContract, "BUY", res.Item1);
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    
                                    if (!completed && !string.IsNullOrEmpty(nearContract)) {
                                        Log("   Near LONG kapatılıyor x" + brokerNear);
                                        var res = ExecGuar("F_" + nearContract, "SELL", brokerNear);
                                        if (res.Item1 > 0) Log("   ✅ Near kapatıldı");
                                    }
                                } else if (brokerFar > 0 && brokerNear == 0) {
                                    // Far SHORT var, Near yok - önce Near açmayı dene
                                    var nearContract = GetContract(sym, 0);
                                    var farContract = GetContract(sym, 1);
                                    
                                    if (!string.IsNullOrEmpty(nearContract) && !string.IsNullOrEmpty(farContract)) {
                                        var nearDepth = Sistem.DerinlikVerisiOku("VIP'F_" + nearContract);
                                        var farDepth = Sistem.DerinlikVerisiOku("VIP'F_" + farContract);
                                        
                                        if (nearDepth != null && farDepth != null) {
                                            var nearAsk = nearDepth.Asks != null && nearDepth.Asks.Length > 0 && nearDepth.Asks[0] != null ? (decimal)nearDepth.Asks[0].Price : 0m;
                                            var farBid = farDepth.Bids != null && farDepth.Bids.Length > 0 && farDepth.Bids[0] != null ? (decimal)farDepth.Bids[0].Price : 0m;
                                            
                                            if (nearAsk > 0 && farBid > 0) {
                                                var spread = (farBid - nearAsk) / nearAsk;
                                                if (spread >= 0.005m) {
                                                    Log("   Near LONG açılıyor (spread=" + (spread*100).ToString("F2") + "%)");
                                                    var res = ExecGuar("F_" + nearContract, "BUY", brokerFar);
                                                    if (res.Item1 >= brokerFar) {
                                                        var p = nfPos[sym];
                                                        nfPos[sym] = new decimal[] { res.Item1, brokerFar, res.Item2, p[3], spread, p[5], p[6] };
                                                        var tem3 = teminat.ContainsKey(sym) ? teminat[sym] : 1000m;
                                                        nfViopUsed += res.Item1 * tem3;
                                                        Log("   ✅ ORPHAN tamamlandı → Near=" + res.Item1 + " Far=" + brokerFar);
                                                        completed = true;
                                                    } else if (res.Item1 > 0) {
                                                        ExecGuar("F_" + nearContract, "SELL", res.Item1);
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    
                                    if (!completed && !string.IsNullOrEmpty(farContract)) {
                                        Log("   Far SHORT kapatılıyor x" + brokerFar);
                                        var res = ExecGuar("F_" + farContract, "BUY", brokerFar);
                                        if (res.Item1 > 0) Log("   ✅ Far kapatıldı");
                                    }
                                }
                                
                                // Tamamlanamadıysa nfPos'u sil
                                if (!completed) {
                                    var tem2 = teminat.ContainsKey(sym) ? teminat[sym] : 1000m;
                                    nfViopUsed -= (ourNear + ourFar) * tem2;
                                    if (nfViopUsed < 0) nfViopUsed = 0;
                                    nfPos.Remove(sym);
                                    if (nfContracts.ContainsKey(sym)) nfContracts.Remove(sym);
                                }
                            }
                            mismatch = true;
                        }
                        
                        if (!mismatch && nfPos.ContainsKey(sym)) {
                            Log("✓ RECOVERY NF: " + sym + " OK (Near=" + ourNear + " Far=" + ourFar + ")");
                        }
                    }
                    
                    Log("✅ RECOVERY NF: Tamamlandı. Pozisyon:" + nfPos.Count + " Kullanılan:" + nfViopUsed.ToString("N0"));
                }
                
            } else {
                Log("⚠️ RECOVERY: VIOP hesap veya pozisyonlar null - NEAR recovery atlanıyor");
            }
        } catch (Exception ex) { Log("⚠️ VIOP pozisyon okuma hata: " + ex.Message); }
        
        // Her iki hesap da okunamadıysa recovery'yi tamamen atla ve bağlantı yok say
        if (!bistOk && !viopOk) {
            Log("⚠️ RECOVERY: Her iki hesap da okunamadı - recovery iptal, bağlantı yok");
            brokerConnected = false;
            inRecovery = false;
            return;
        }
        
        // En az biri okunduysa bağlantı var
        brokerConnected = true;
        
        Log("📊 RECOVERY: Gerçek pozisyonlar - SPOT:" + realSpotPos.Count + " NEAR:" + realNearPos.Count);
        
        // ========== PAIR TRADING RECOVERY ==========
        if (PAIR_ENABLED && viopOk && PAIR_DEFS.Count > 0) {
            try {
                Log("🔍 RECOVERY PAIR: Başlatılıyor...");
                
                // Broker'daki VIOP pozisyonlarından Pair sembollerini ayıkla
                // realPairPos[sym] = { kontrat, lot, yön (1=LONG, -1=SHORT) }
                var realPairPos = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.Dictionary<string, int>>();
                
                var viopHesapPair = GetViopHesap();
                if (viopHesapPair != null && viopHesapPair.Pozisyonlar != null) {
                    for (int i = 0; i < viopHesapPair.Pozisyonlar.Count; i++) {
                        var sym = (string)viopHesapPair.Pozisyonlar[i].Symbol;
                        var lot = (int)viopHesapPair.Pozisyonlar[i].NetAmount;
                        
                        if (sym != null && (sym.StartsWith("F_") || sym.Contains("'F_"))) {
                            var idx = sym.IndexOf("F_");
                            if (idx >= 0) {
                                var fullContract = sym.Substring(idx);  // F_TCELL0226
                                var baseSym = fullContract.Substring(2);  // TCELL0226
                                if (baseSym.Length > 4) baseSym = baseSym.Substring(0, baseSym.Length - 4);  // TCELL
                                
                                // Bu sembol PAIR_BLOCKED'da mı? (Pair Trading sembolleri)
                                if (PAIR_BLOCKED.Contains(baseSym)) {
                                    if (!realPairPos.ContainsKey(baseSym)) {
                                        realPairPos[baseSym] = new System.Collections.Generic.Dictionary<string, int>();
                                    }
                                    realPairPos[baseSym][fullContract] = lot;
                                    Log("🔍 RECOVERY PAIR: " + baseSym + " [" + fullContract + "] Lot:" + lot);
                                }
                            }
                        }
                    }
                }
                
                // Her Pair tanımı için karşılaştır
                foreach (var def in PAIR_DEFS) {
                    var symA = (string)def[0];
                    var symB = (string)def[1];
                    var beta = (decimal)def[2];
                    var pairKey = GetPairKey(symA, symB);
                    
                    // Bizim pozisyonumuz
                    var ourQtyA = pairPos.ContainsKey(pairKey) ? (int)pairPos[pairKey][0] : 0;
                    var ourQtyB = pairPos.ContainsKey(pairKey) ? (int)pairPos[pairKey][1] : 0;
                    
                    // Broker'daki pozisyon (tüm kontratların toplamı)
                    var brokerQtyA = 0;
                    var brokerQtyB = 0;
                    
                    if (realPairPos.ContainsKey(symA)) {
                        foreach (var kv in realPairPos[symA]) {
                            brokerQtyA += Math.Abs(kv.Value);  // Mutlak değer (yön pairPos'tan belirlenir)
                        }
                    }
                    if (realPairPos.ContainsKey(symB)) {
                        foreach (var kv in realPairPos[symB]) {
                            brokerQtyB += Math.Abs(kv.Value);
                        }
                    }
                    
                    // Kontratları al
                    var pairNearA = GetContract(symA, 0);
                    var pairNearB = GetContract(symB, 0);
                    
                    // Uyumsuzluk kontrolü
                    var mismatch = false;
                    
                    // Yardımcı: Beta'ya göre doğru lot hesapla
                    // A'dan B hesapla: B = A × beta
                    // B'den A hesapla: A = B / beta
                    Func<int, int> calcBfromA = (qA) => (int)Math.Round(qA * beta);
                    Func<int, int> calcAfromB = (qB) => (int)Math.Round(qB / beta);
                    
                    // Durum 1: Broker'da var, bizde yok → pairPos'a ekle ve oran düzelt
                    if ((brokerQtyA > 0 || brokerQtyB > 0) && !pairPos.ContainsKey(pairKey)) {
                        Log("⚠️ RECOVERY PAIR: " + pairKey + " broker'da var ama pairPos'ta yok!");
                        Log("   Broker: A=" + brokerQtyA + " B=" + brokerQtyB);
                        
                        // Pozisyon yönünü tahmin et (hangi taraf daha büyük?)
                        // Normalde Z<0 ise A LONG, Z>0 ise A SHORT
                        // Broker'dan yön bilgisi alalım
                        var brokerDirA = 0;  // 1=LONG, -1=SHORT
                        if (realPairPos.ContainsKey(symA)) {
                            foreach (var kv in realPairPos[symA]) {
                                brokerDirA = kv.Value > 0 ? 1 : -1;
                                break;
                            }
                        }
                        var estimatedZ = brokerDirA > 0 ? -2m : 2m;  // A LONG ise Z negatif tahmin
                        
                        // Beta oranına göre düzeltme gerekiyor mu?
                        var expectedB = calcBfromA(brokerQtyA);
                        var expectedA = calcAfromB(brokerQtyB);
                        
                        var finalQtyA = brokerQtyA;
                        var finalQtyB = brokerQtyB;
                        
                        if (brokerQtyA > 0 && brokerQtyB > 0) {
                            var actualRatio = (decimal)brokerQtyB / brokerQtyA;
                            var ratioDeviation = Math.Abs(actualRatio - beta) / beta;
                            
                            if (ratioDeviation > PAIR_RATIO_TOLERANCE) {
                                Log("   Oran düzeltme gerekiyor: β=" + beta.ToString("F2") + " Gerçek=" + actualRatio.ToString("F2"));
                                
                                // Hangisini düzeltmek daha az işlem gerektirir?
                                var diffFixB = Math.Abs(expectedB - brokerQtyB);
                                var diffFixA = Math.Abs(expectedA - brokerQtyA);
                                
                                if (diffFixB <= diffFixA && !string.IsNullOrEmpty(pairNearB)) {
                                    // B'yi düzelt
                                    var delta = expectedB - brokerQtyB;
                                    if (delta != 0) {
                                        var side = delta > 0 ? (brokerDirA > 0 ? "SELL" : "BUY") : (brokerDirA > 0 ? "BUY" : "SELL");
                                        Log("   B düzeltiliyor: " + symB + " " + side + " x" + Math.Abs(delta));
                                        var res = ExecGuar("F_" + pairNearB, side, Math.Abs(delta));
                                        if (res.Item1 > 0) {
                                            finalQtyB = brokerQtyB + delta;
                                            Log("   ✅ B düzeltildi: " + brokerQtyB + " → " + finalQtyB);
                                        }
                                    }
                                } else if (!string.IsNullOrEmpty(pairNearA)) {
                                    // A'yı düzelt
                                    var delta = expectedA - brokerQtyA;
                                    if (delta != 0) {
                                        var side = delta > 0 ? (brokerDirA > 0 ? "BUY" : "SELL") : (brokerDirA > 0 ? "SELL" : "BUY");
                                        Log("   A düzeltiliyor: " + symA + " " + side + " x" + Math.Abs(delta));
                                        var res = ExecGuar("F_" + pairNearA, side, Math.Abs(delta));
                                        if (res.Item1 > 0) {
                                            finalQtyA = brokerQtyA + delta;
                                            Log("   ✅ A düzeltildi: " + brokerQtyA + " → " + finalQtyA);
                                        }
                                    }
                                }
                            }
                        } else if (brokerQtyA > 0 && brokerQtyB == 0 && !string.IsNullOrEmpty(pairNearB)) {
                            // Sadece A var, B'yi aç
                            var side = brokerDirA > 0 ? "SELL" : "BUY";
                            Log("   B eksik, açılıyor: " + symB + " " + side + " x" + expectedB);
                            var res = ExecGuar("F_" + pairNearB, side, expectedB);
                            if (res.Item1 > 0) {
                                finalQtyB = res.Item1;
                                Log("   ✅ B açıldı: " + finalQtyB);
                            }
                        } else if (brokerQtyB > 0 && brokerQtyA == 0 && !string.IsNullOrEmpty(pairNearA)) {
                            // Sadece B var, A'yı aç
                            var brokerDirB = 0;
                            if (realPairPos.ContainsKey(symB)) {
                                foreach (var kv in realPairPos[symB]) {
                                    brokerDirB = kv.Value > 0 ? 1 : -1;
                                    break;
                                }
                            }
                            var side = brokerDirB > 0 ? "SELL" : "BUY";
                            Log("   A eksik, açılıyor: " + symA + " " + side + " x" + expectedA);
                            var res = ExecGuar("F_" + pairNearA, side, expectedA);
                            if (res.Item1 > 0) {
                                finalQtyA = res.Item1;
                                Log("   ✅ A açıldı: " + finalQtyA);
                            }
                        }
                        
                        // pairPos'a ekle
                        if (finalQtyA > 0 && finalQtyB > 0) {
                            var temA = teminat.ContainsKey(symA) ? teminat[symA] : 1000m;
                            var temB = teminat.ContainsKey(symB) ? teminat[symB] : 1000m;
                            pairPos[pairKey] = new decimal[] { finalQtyA, finalQtyB, 0, 0, estimatedZ, 1, DateTime.Now.Ticks, 0 };
                            if (!string.IsNullOrEmpty(pairNearA) && !string.IsNullOrEmpty(pairNearB)) {
                                pairContracts[pairKey] = new string[] { pairNearA, pairNearB };
                            }
                            pairUsed += (finalQtyA * temA) + (finalQtyB * temB);
                            Log("✅ RECOVERY PAIR: " + pairKey + " pairPos'a eklendi A=" + finalQtyA + " B=" + finalQtyB);
                        }
                        mismatch = true;
                    }
                    // Durum 2: Bizde var, broker'da yok → pairPos'tan sil
                    else if (pairPos.ContainsKey(pairKey) && brokerQtyA == 0 && brokerQtyB == 0) {
                        Log("🗑️ RECOVERY PAIR: " + pairKey + " pairPos'ta var ama broker'da yok - siliniyor");
                        Log("   pairPos: A=" + ourQtyA + " B=" + ourQtyB);
                        
                        // Teminatı serbest bırak
                        var temA = teminat.ContainsKey(symA) ? teminat[symA] : 1000m;
                        var temB = teminat.ContainsKey(symB) ? teminat[symB] : 1000m;
                        pairUsed -= (ourQtyA * temA) + (ourQtyB * temB);
                        if (pairUsed < 0) pairUsed = 0;
                        
                        pairPos.Remove(pairKey);
                        if (pairContracts.ContainsKey(pairKey)) pairContracts.Remove(pairKey);
                        mismatch = true;
                    }
                    // Durum 3: Tek taraf ORPHAN → Eksik tarafı tamamla
                    else if (pairPos.ContainsKey(pairKey) && ((brokerQtyA > 0 && brokerQtyB == 0) || (brokerQtyA == 0 && brokerQtyB > 0))) {
                        var p = pairPos[pairKey];
                        var openZ = p[4];
                        var isLongA = openZ < 0;
                        
                        if (brokerQtyA > 0 && brokerQtyB == 0 && !string.IsNullOrEmpty(pairNearB)) {
                            // A var, B eksik
                            var expectedB = calcBfromA(brokerQtyA);
                            var side = isLongA ? "SELL" : "BUY";
                            Log("🚨 RECOVERY PAIR: " + pairKey + " ORPHAN - B eksik, tamamlanıyor");
                            Log("   A=" + brokerQtyA + " B=0 → B " + side + " x" + expectedB);
                            
                            var res = ExecGuar("F_" + pairNearB, side, expectedB);
                            if (res.Item1 > 0) {
                                var temA = teminat.ContainsKey(symA) ? teminat[symA] : 1000m;
                                var temB = teminat.ContainsKey(symB) ? teminat[symB] : 1000m;
                                var oldTem = (ourQtyA * temA) + (ourQtyB * temB);
                                var newTem = (brokerQtyA * temA) + (res.Item1 * temB);
                                
                                pairPos[pairKey] = new decimal[] { brokerQtyA, res.Item1, p[2], res.Item2, p[4], p[5], p[6], p.Length > 7 ? p[7] : 0m };
                                pairUsed = pairUsed - oldTem + newTem;
                                Log("✅ RECOVERY PAIR: " + pairKey + " ORPHAN düzeltildi A=" + brokerQtyA + " B=" + res.Item1);
                            }
                        } else if (brokerQtyB > 0 && brokerQtyA == 0 && !string.IsNullOrEmpty(pairNearA)) {
                            // B var, A eksik
                            var expectedA = calcAfromB(brokerQtyB);
                            var side = isLongA ? "BUY" : "SELL";
                            Log("🚨 RECOVERY PAIR: " + pairKey + " ORPHAN - A eksik, tamamlanıyor");
                            Log("   A=0 B=" + brokerQtyB + " → A " + side + " x" + expectedA);
                            
                            var res = ExecGuar("F_" + pairNearA, side, expectedA);
                            if (res.Item1 > 0) {
                                var temA = teminat.ContainsKey(symA) ? teminat[symA] : 1000m;
                                var temB = teminat.ContainsKey(symB) ? teminat[symB] : 1000m;
                                var oldTem = (ourQtyA * temA) + (ourQtyB * temB);
                                var newTem = (res.Item1 * temA) + (brokerQtyB * temB);
                                
                                pairPos[pairKey] = new decimal[] { res.Item1, brokerQtyB, res.Item2, p[3], p[4], p[5], p[6], p.Length > 7 ? p[7] : 0m };
                                pairUsed = pairUsed - oldTem + newTem;
                                Log("✅ RECOVERY PAIR: " + pairKey + " ORPHAN düzeltildi A=" + res.Item1 + " B=" + brokerQtyB);
                            }
                        }
                        mismatch = true;
                    }
                    // Durum 4: Her iki tarafta da pozisyon var ama uyumsuzluk
                    else if (pairPos.ContainsKey(pairKey) && brokerQtyA > 0 && brokerQtyB > 0) {
                        var p = pairPos[pairKey];
                        var openZ = p[4];
                        var isLongA = openZ < 0;
                        
                        // Bizim beklediğimiz doğru oranlar
                        var ourExpectedB = calcBfromA(ourQtyA);
                        var brokerActualRatio = (decimal)brokerQtyB / brokerQtyA;
                        var ourRatio = ourQtyA > 0 ? (decimal)ourQtyB / ourQtyA : beta;
                        var brokerRatioDeviation = Math.Abs(brokerActualRatio - beta) / beta;
                        var ourRatioDeviation = Math.Abs(ourRatio - beta) / beta;
                        
                        // Miktar uyumsuzluğu
                        if (ourQtyA != brokerQtyA || ourQtyB != brokerQtyB) {
                            Log("⚠️ RECOVERY PAIR: " + pairKey + " miktar uyumsuzluğu!");
                            Log("   pairPos: A=" + ourQtyA + " B=" + ourQtyB + " (oran=" + ourRatio.ToString("F2") + ")");
                            Log("   Broker:  A=" + brokerQtyA + " B=" + brokerQtyB + " (oran=" + brokerActualRatio.ToString("F2") + ")");
                            Log("   Hedef β=" + beta.ToString("F2"));
                            
                            // Broker oranı yanlış mı?
                            if (brokerRatioDeviation > PAIR_RATIO_TOLERANCE) {
                                Log("   Broker oranı yanlış, düzeltiliyor...");
                                
                                // Bizdeki oran doğruysa, bizim miktarlarımıza göre düzelt
                                // Değilse, mevcut A'ya göre B'yi düzelt
                                var targetA = ourRatioDeviation <= PAIR_RATIO_TOLERANCE ? ourQtyA : brokerQtyA;
                                var targetB = calcBfromA(targetA);
                                
                                // A düzeltmesi
                                if (brokerQtyA != targetA && !string.IsNullOrEmpty(pairNearA)) {
                                    var deltaA = targetA - brokerQtyA;
                                    var sideA = deltaA > 0 ? (isLongA ? "BUY" : "SELL") : (isLongA ? "SELL" : "BUY");
                                    Log("   A düzeltiliyor: " + sideA + " x" + Math.Abs(deltaA));
                                    var resA = ExecGuar("F_" + pairNearA, sideA, Math.Abs(deltaA));
                                    if (resA.Item1 > 0) {
                                        brokerQtyA = targetA;
                                    }
                                }
                                
                                // B düzeltmesi
                                if (brokerQtyB != targetB && !string.IsNullOrEmpty(pairNearB)) {
                                    var deltaB = targetB - brokerQtyB;
                                    var sideB = deltaB > 0 ? (isLongA ? "SELL" : "BUY") : (isLongA ? "BUY" : "SELL");
                                    Log("   B düzeltiliyor: " + sideB + " x" + Math.Abs(deltaB));
                                    var resB = ExecGuar("F_" + pairNearB, sideB, Math.Abs(deltaB));
                                    if (resB.Item1 > 0) {
                                        brokerQtyB = targetB;
                                    }
                                }
                            }
                            
                            // pairPos'u güncelle
                            var temA = teminat.ContainsKey(symA) ? teminat[symA] : 1000m;
                            var temB = teminat.ContainsKey(symB) ? teminat[symB] : 1000m;
                            var oldTem = (ourQtyA * temA) + (ourQtyB * temB);
                            var newTem = (brokerQtyA * temA) + (brokerQtyB * temB);
                            
                            pairPos[pairKey] = new decimal[] { brokerQtyA, brokerQtyB, p[2], p[3], p[4], p[5], p[6], p.Length > 7 ? p[7] : 0m };
                            pairUsed = pairUsed - oldTem + newTem;
                            if (pairUsed < 0) pairUsed = 0;
                            
                            Log("✅ RECOVERY PAIR: " + pairKey + " güncellendi → A=" + brokerQtyA + " B=" + brokerQtyB);
                            mismatch = true;
                        }
                        // Miktar eşit ama oran kontrolü
                        else if (brokerRatioDeviation > PAIR_RATIO_TOLERANCE) {
                            Log("⚠️ RECOVERY PAIR: " + pairKey + " oran uyumsuz!");
                            Log("   Mevcut: A=" + brokerQtyA + " B=" + brokerQtyB + " (oran=" + brokerActualRatio.ToString("F2") + ")");
                            Log("   Hedef β=" + beta.ToString("F2"));
                            
                            // B'yi düzelt (A sabit kalsın)
                            var targetB = calcBfromA(brokerQtyA);
                            var deltaB = targetB - brokerQtyB;
                            
                            if (deltaB != 0 && !string.IsNullOrEmpty(pairNearB)) {
                                var sideB = deltaB > 0 ? (isLongA ? "SELL" : "BUY") : (isLongA ? "BUY" : "SELL");
                                Log("   B düzeltiliyor: " + sideB + " x" + Math.Abs(deltaB));
                                var resB = ExecGuar("F_" + pairNearB, sideB, Math.Abs(deltaB));
                                if (resB.Item1 > 0) {
                                    var temB = teminat.ContainsKey(symB) ? teminat[symB] : 1000m;
                                    pairPos[pairKey] = new decimal[] { brokerQtyA, targetB, p[2], p[3], p[4], p[5], p[6], p.Length > 7 ? p[7] : 0m };
                                    pairUsed += deltaB * temB;
                                    Log("✅ RECOVERY PAIR: " + pairKey + " oran düzeltildi → A=" + brokerQtyA + " B=" + targetB);
                                }
                            }
                            mismatch = true;
                        }
                    }
                    
                    if (!mismatch && pairPos.ContainsKey(pairKey)) {
                        Log("✓ RECOVERY PAIR: " + pairKey + " OK (A=" + ourQtyA + " B=" + ourQtyB + " β=" + beta.ToString("F2") + ")");
                    }
                }
                
                Log("✅ RECOVERY PAIR: Tamamlandı. Pozisyon:" + pairPos.Count + " Kullanılan:" + pairUsed.ToString("N0"));
                
            } catch (Exception ex) {
                Log("❌ RECOVERY PAIR HATA: " + ex.Message);
            }
        }
        
        // 2. Kendi pozisyonlarımızla karşılaştır ve eksik bacakları bul (SN)
        var allSymbols = new System.Collections.Generic.HashSet<string>();
        foreach (var kv in snPos) allSymbols.Add(kv.Key);
        if (bistOk) foreach (var kv in realSpotPos) allSymbols.Add(kv.Key);
        if (viopOk) foreach (var kv in realNearPos) allSymbols.Add(kv.Key);
        
        foreach (var sym in allSymbols) {
            // Bekleyen emir varsa bu sembol için recovery atla
            var hasPendingOrder = false;
            foreach (var pk in pendingOrders.Keys) {
                // pk = "THYAO_BUY" veya "F_THYAO0126_SELL"
                // sym = "THYAO"
                if (pk.StartsWith(sym + "_") || pk.Contains("_" + sym) || pk.Contains(sym)) {
                    hasPendingOrder = true;
                    Log("⏭️ RECOVERY: " + sym + " için bekleyen emir var (" + pk + "), atlanıyor");
                    break;
                }
            }
            if (hasPendingOrder) continue;
            
            var ourSpot = snPos.ContainsKey(sym) ? (int)snPos[sym][0] : 0;
            var ourNear = snPos.ContainsKey(sym) ? (int)snPos[sym][1] : 0;
            
            // Sadece başarılı okunan hesaplardan gerçek pozisyon al
            // Okunamayan taraf için bizim değerimizi koru
            var realSpot = bistOk ? (realSpotPos.ContainsKey(sym) ? realSpotPos[sym] : 0) : ourSpot;
            var realNear = viopOk ? (realNearPos.ContainsKey(sym) ? realNearPos[sym] : 0) : ourNear;
            
            // Fark var mı?
            if (ourSpot != realSpot || ourNear != realNear) {
                Log("⚠️ RECOVERY: " + sym + " uyumsuz! Bizde S:" + ourSpot + " N:" + ourNear + " Gerçek S:" + realSpot + " N:" + realNear);
                
                // Durum 4: Bizde var ama aracı kurumda yok - sadece her iki okuma da başarılıysa sil
                // ÖNCELİKLİ KONTROL: Bu durumu ilk kontrol et!
                if (realSpot == 0 && realNear == 0 && snPos.ContainsKey(sym) && bistOk && viopOk) {
                    Log("🗑️ RECOVERY: " + sym + " aracı kurumda yok, pozisyon siliniyor");
                    snPos.Remove(sym);
                }
                // Durum 1: Sadece Spot var, Near yok (Near eksik) - sadece VIOP okuma başarılıysa
                else if (realSpot > 0 && realNear == 0 && viopOk) {
                    RecoverMissingLeg(sym, "NEAR", realSpot, 0);
                }
                // Durum 2: Sadece Near var, Spot yok (Spot eksik) - sadece BIST okuma başarılıysa
                else if (realNear > 0 && realSpot == 0 && bistOk) {
                    RecoverMissingLeg(sym, "SPOT", 0, realNear);
                }
                // Durum 3: İkisi de var ama miktarlar uyumsuz
                else if (realSpot > 0 && realNear > 0) {
                    // Pozisyonumuzu gerçeğe göre güncelle
                    if (snPos.ContainsKey(sym)) {
                        var p = snPos[sym];
                        if (bistOk) p[0] = realSpot;
                        if (viopOk) p[1] = realNear;
                        Log("✅ RECOVERY: " + sym + " pozisyon güncellendi S:" + realSpot + " N:" + realNear);
                    }
                }
            }
            // Uyumsuzluk olmasa bile yetim pozisyon kontrolü (positions.json'da Near=0 kaydedilmiş olabilir)
            else if (realSpot > 0 && realNear == 0 && viopOk && snPos.ContainsKey(sym)) {
                Log("⚠️ RECOVERY: " + sym + " yetim pozisyon! Spot:" + realSpot + " Near:0");
                RecoverMissingLeg(sym, "NEAR", realSpot, 0);
            }
            else if (realNear > 0 && realSpot == 0 && bistOk && snPos.ContainsKey(sym)) {
                Log("⚠️ RECOVERY: " + sym + " yetim pozisyon! Spot:0 Near:" + realNear);
                RecoverMissingLeg(sym, "SPOT", 0, realNear);
            }
        }
        
        // orphanLegs kontrolü: Manuel tamamlanmış mı?
        // Broker'da pozisyon yok ama orphanLegs'te kayıt var → Manuel kapatılmış
        var orphansToRemove = new System.Collections.Generic.List<string>();
        foreach (var kv in orphanLegs) {
            var sym = kv.Key;
            var orph = kv.Value;
            var filledLeg = (string)orph[0];  // "NEAR" veya "SPOT"
            var filledSide = (string)orph[2]; // "SELL" veya "BUY"
            var filledQty = (int)orph[3];
            var filledPrice = (decimal)orph[4];
            
            // Near SHORT açıldı, Spot alınamadı durumu
            if (filledLeg == "NEAR" && filledSide == "SELL") {
                // VİOP'ta bu sembol için SHORT var mı?
                var hasNearShort = realNearPos.ContainsKey(sym) && realNearPos[sym] > 0;
                
                if (!hasNearShort && viopOk) {
                    // VİOP'ta Near SHORT yok → Manuel kapatılmış!
                    Log("🗑️ RECOVERY: " + sym + " orphanLegs manuel tamamlanmış (VİOP'ta pozisyon yok)");
                    Log("   Açılış: NEAR SELL x" + filledQty + " @" + filledPrice.ToString("F2"));
                    orphansToRemove.Add(sym);
                }
            }
            // Spot alındı, Near satılamadı durumu (tersi)
            else if (filledLeg == "SPOT" && filledSide == "BUY") {
                // BIST'te bu sembol için Spot var mı?
                var hasSpot = realSpotPos.ContainsKey(sym) && realSpotPos[sym] > 0;
                
                if (!hasSpot && bistOk) {
                    // BIST'te Spot yok → Manuel kapatılmış!
                    Log("🗑️ RECOVERY: " + sym + " orphanLegs manuel tamamlanmış (BIST'te pozisyon yok)");
                    Log("   Açılış: SPOT BUY x" + filledQty + " @" + filledPrice.ToString("F2"));
                    orphansToRemove.Add(sym);
                }
            }
        }
        foreach (var sym in orphansToRemove) {
            orphanLegs.Remove(sym);
        }
        if (orphansToRemove.Count > 0) {
            Log("📋 RECOVERY: " + orphansToRemove.Count + " orphanLegs kaydı temizlendi (manuel tamamlama)");
        }
        
        // 3. Pozisyonları kaydet ve IdealData güncelle
        SavePositions();
        foreach (var kv in snPos) {
            try {
                var p = kv.Value;
                Sistem.PozisyonKontrolGuncelle(ROBOT_NAME + "_SPOT," + kv.Key, (int)p[0], (double)p[2], "SPOT");
                Sistem.PozisyonKontrolGuncelle(ROBOT_NAME + "_NEAR," + GetContract(kv.Key, 0), (int)p[1], (double)p[3], "NEAR");
            } catch { }
        }
        
        // Bütçe kullanımını yeniden hesapla
        spotUsed = 0;
        viopUsed = 0;
        foreach (var kv in snPos) {
            var p = kv.Value;
            var tem = teminat.ContainsKey(kv.Key) ? teminat[kv.Key] : 0;
            spotUsed += p[2] * p[0];
            viopUsed += tem * p[1];
        }
        
        Log("✅ RECOVERY: Senkronizasyon tamamlandı. Pozisyon:" + snPos.Count + " SPOT:" + spotUsed.ToString("N0") + " VIOP:" + viopUsed.ToString("N0"));
        lastRecoveryCheck = DateTime.Now;
        
        // Bütçeleri güncelle (gerçek bakiyeleri oku)
        UpdateBalances();
        if (IS_TEST) {
            Log("💰 RECOVERY: Bütçe SPOT:" + spotBudgetTotal.ToString("N0") + " (kalan:" + spotBalance.ToString("N0") + ") VIOP:" + viopBalance.ToString("N0"));
        } else {
            Log("💰 RECOVERY: Bütçe SPOT:" + spotBudgetTotal.ToString("N0") + " (T+2:" + t2Balance.ToString("N0") + ") VIOP:" + viopBalance.ToString("N0"));
        }
        
    } catch (Exception ex) {
        Log("❌ RECOVERY HATA: " + ex.Message);
    } finally {
        inRecovery = false;  // Her durumda flag'i resetle
    }
};

// Eksik bacak recovery
RecoverMissingLeg = (sym, missingLeg, realSpot, realNear) => {
    try {
        // AÇILIŞ VOLATİLİTESİ KORUMASI: 10:05'e kadar beklet
        var recNow = DateTime.Now;
        var recMinutes = recNow.Hour * 60 + recNow.Minute;
        var recStartMinutes = MARKET_OPEN_HOUR * 60 + MARKET_OPEN_MINUTE + 5;  // 10:05
        var bistOpenMinutes = MARKET_OPEN_HOUR * 60 + MARKET_OPEN_MINUTE;  // 10:00
        
        // Piyasa açık değilse veya 10:05'ten önceyse beklet
        if (recMinutes < recStartMinutes) {
            // orphanLegs'e kaydet ve 10:05'te işlenecek
            if (!orphanLegs.ContainsKey(sym)) {
                // snPos'tan giriş fiyatını al (varsa)
                var spotEntry = snPos.ContainsKey(sym) ? snPos[sym][2] : 0m;
                var nearEntry = snPos.ContainsKey(sym) ? snPos[sym][3] : 0m;
                
                if (missingLeg == "NEAR") {
                    // Spot var, Near yok → Near açılacak veya Spot kapatılacak
                    orphanLegs[sym] = new object[] {
                        "SPOT", SPOT_PREFIX + sym, "HOLD", realSpot, spotEntry,
                        "NEAR", GetContract(sym, 0), "PENDING", realSpot / 100, DateTime.Now.Ticks
                    };
                } else {
                    // Near var, Spot yok → Spot açılacak veya Near kapatılacak
                    orphanLegs[sym] = new object[] {
                        "NEAR", GetContract(sym, 0), "SELL", realNear, nearEntry,
                        "SPOT", sym, "BUY", realNear * 100, DateTime.Now.Ticks
                    };
                }
                Log("⏳ RECOVERY BEKLETMESİ: " + sym + " eksik bacak: " + missingLeg + " - 10:05'te işlenecek");
                SavePositions();
            }
            return;
        }
        
        Log("🔧 RECOVERY: " + sym + " eksik bacak: " + missingLeg);
        
        var spotS = SPOT_PREFIX + sym;
        var nearC = GetContract(sym, 0);
        var nearS = FUTURES_PREFIX + nearC;
        
        // Derinlikten fiyat al (yüzeysel veri 26ms gecikmeli olabilir)
        var spotDepthRec = ReadDepth(spotS, "ASK", 0, 1, 50);  // Spot Ask (alım için)
        var spotBidDepthRec = ReadDepth(spotS, "BID", 0, 1, 50);  // Spot Bid (satım için)
        var nearDepthRec = ReadDepth(nearS, "BID", 0, 1, 50);  // Near Bid (satım için)
        
        var spotBid = spotBidDepthRec.Item1 ? spotBidDepthRec.Item4 : 0m;
        var spotAsk = spotDepthRec.Item1 ? spotDepthRec.Item4 : 0m;
        var nearBid = nearDepthRec.Item1 ? nearDepthRec.Item4 : 0m;
        var nearAsk = 0m;  // Gerekirse ayrı oku
        
        if (missingLeg == "NEAR") {
            // Spot var, Near yok
            // Seçenek 1: Near aç (tamamla)
            // Seçenek 2: Spot kapat
            
            var nQty = realSpot / 100;  // Near kontrat sayısı
            var tem = teminat.ContainsKey(sym) ? teminat[sym] : 0;
            var nearCost = tem * nQty;
            
            // Spread kontrolü - tamamlama mantıklı mı?
            var currentSpread = spotAsk > 0 ? (nearBid - spotAsk) / spotAsk : 0;
            var spreadAttractive = currentSpread >= SN_MIN_MARGIN;
            
            Log("📊 RECOVERY: " + sym + " Spread:" + (currentSpread * 100).ToString("F3") + "% Min:" + (SN_MIN_MARGIN * 100).ToString("F2") + "% Cazip:" + (spreadAttractive ? "EVET" : "HAYIR"));
            
            // Bütçe yeterli VE spread cazip mi?
            if (nearCost <= viopBalance && nearBid > 0 && spreadAttractive) {
                // Near aç (tamamla)
                Log("🔧 RECOVERY: " + sym + " Near açılıyor (tamamlama) x" + nQty);
                var result = ExecGuar(nearC, "SELL", nQty);
                if (result.Item1 > 0) {
                    var nearPrice = result.Item2;
                    var spread = spotAsk > 0 ? (nearPrice - spotAsk) / spotAsk : 0;
                    var expPnl = spread * spotAsk * realSpot;
                    // Komisyon düş (giriş + çıkış)
                    var spotCommRec = CalcSpotCommission(spotAsk, realSpot);
                    var nearCommRec = CalcCommission(sym, nearPrice, result.Item1);
                    expPnl -= (spotCommRec + nearCommRec) * 2;
                    
                    snPos[sym] = new decimal[] { realSpot, result.Item1, spotAsk, nearPrice, spread, expPnl, 0, DateTime.Now.Ticks };
                    viopUsed += nearCost;
                    Log("✅ RECOVERY: " + sym + " Near tamamlandı @" + nearPrice.ToString("F2") + " Spread:" + (spread * 100).ToString("F3") + "%");
                } else {
                    // Near teyit alınamadı - emir gerçekleşmiş olabilir, 30sn sonra tekrar kontrol edilecek
                    Log("⚠️ RECOVERY: " + sym + " Near teyit alınamadı, 30sn sonra tekrar kontrol edilecek");
                    recoveryRetryNeeded = true;
                    recoveryRetryTime = DateTime.Now.AddSeconds(30);
                    // Spot'u KAPATMA - emir gerçekleşmiş olabilir!
                }
            } else {
                // Bütçe yok VEYA spread cazip değil → Spot kapat
                var reason = !spreadAttractive ? "spread cazip değil" : "bütçe yok";
                Log("⚠️ RECOVERY: " + sym + " " + reason + ", Spot kapatılıyor");
                var spotResult = ExecGuar(sym, "SELL", realSpot);
                if (spotResult.Item1 > 0) {
                    Log("✅ RECOVERY: " + sym + " Spot kapatıldı @" + spotResult.Item2.ToString("F2"));
                    snPos.Remove(sym);
                    SavePositions();
                }
            }
        }
        else if (missingLeg == "SPOT") {
            // Near var, Spot yok
            // Seçenek 1: Spot al (tamamla)
            // Seçenek 2: Near kapat
            
            var sQty = realNear * 100;  // Spot adet
            var spotCost = spotAsk * sQty;
            
            // orphanLegs'te bu sembol var mı? Varsa açılış fiyatını kullan
            decimal nearEntryPrice = 0m;
            if (orphanLegs.ContainsKey(sym)) {
                var orph = orphanLegs[sym];
                if ((string)orph[0] == "NEAR" && (string)orph[2] == "SELL") {
                    nearEntryPrice = (decimal)orph[4];
                    Log("📋 RECOVERY: " + sym + " orphanLegs'ten Near açılış fiyatı: " + nearEntryPrice.ToString("F2"));
                }
            }
            
            // Spread kontrolü - tamamlama mantıklı mı?
            // Eğer orphanLegs'te açılış fiyatı varsa, ona göre değerlendir
            decimal currentSpread;
            bool spreadAttractive;
            
            if (nearEntryPrice > 0) {
                // Near açılış fiyatına göre spread hesapla
                // Near SELL yapıldı nearEntryPrice'tan, şimdi Spot alınacak spotAsk'tan
                // Kârlılık: (nearEntryPrice - spotAsk) / spotAsk
                currentSpread = spotAsk > 0 ? (nearEntryPrice - spotAsk) / spotAsk : 0;
                spreadAttractive = currentSpread >= SN_MIN_MARGIN;
                Log("📊 RECOVERY: " + sym + " Spread (açılış fiyatıyla):" + (currentSpread * 100).ToString("F3") + 
                    "% (NearEntry:" + nearEntryPrice.ToString("F2") + " SpotAsk:" + spotAsk.ToString("F2") + ")");
            } else {
                // Açılış fiyatı yok, o anki fiyatlarla değerlendir
                currentSpread = spotAsk > 0 ? (nearBid - spotAsk) / spotAsk : 0;
                spreadAttractive = currentSpread >= SN_MIN_MARGIN;
                Log("📊 RECOVERY: " + sym + " Spread:" + (currentSpread * 100).ToString("F3") + "% Min:" + (SN_MIN_MARGIN * 100).ToString("F2") + "% Cazip:" + (spreadAttractive ? "EVET" : "HAYIR"));
            }
            
            // Bütçe yeterli VE spread cazip mi?
            if (spotCost <= spotBalance && spotAsk > 0 && spreadAttractive) {
                // Spot al (tamamla)
                Log("🔧 RECOVERY: " + sym + " Spot alınıyor (tamamlama) x" + sQty);
                var result = ExecGuar(sym, "BUY", sQty);
                if (result.Item1 > 0) {
                    var spotPrice = result.Item2;
                    // Spread hesabında açılış fiyatı varsa onu kullan
                    var nearPriceForSpread = nearEntryPrice > 0 ? nearEntryPrice : nearBid;
                    var spread = spotPrice > 0 ? (nearPriceForSpread - spotPrice) / spotPrice : 0;
                    var expPnl = spread * spotPrice * result.Item1;
                    // Komisyon düş (giriş + çıkış)
                    var spotCommRec2 = CalcSpotCommission(spotPrice, result.Item1);
                    var nearCommRec2 = CalcCommission(sym, nearPriceForSpread, realNear);
                    expPnl -= (spotCommRec2 + nearCommRec2) * 2;
                    
                    snPos[sym] = new decimal[] { result.Item1, realNear, spotPrice, nearPriceForSpread, spread, expPnl, 0, DateTime.Now.Ticks };
                    spotUsed += spotCost;
                    var spotCommAdj = CalcSpotCommission(spotPrice, result.Item1);
                    AdjustT2Balance(spotCost, spotCommAdj);  // Alış
                    
                    // orphanLegs'ten sil
                    if (orphanLegs.ContainsKey(sym)) {
                        orphanLegs.Remove(sym);
                        Log("🗑️ RECOVERY: " + sym + " orphanLegs'ten silindi");
                    }
                    
                    Log("✅ RECOVERY: " + sym + " Spot tamamlandı @" + spotPrice.ToString("F2") + " Spread:" + (spread * 100).ToString("F3") + "%");
                    SavePositions();
                } else {
                    // Spot teyit alınamadı - emir gerçekleşmiş olabilir, 30sn sonra tekrar kontrol edilecek
                    Log("⚠️ RECOVERY: " + sym + " Spot teyit alınamadı, 30sn sonra tekrar kontrol edilecek");
                    recoveryRetryNeeded = true;
                    recoveryRetryTime = DateTime.Now.AddSeconds(30);
                    // Near'ı KAPATMA - emir gerçekleşmiş olabilir!
                }
            } else {
                // Bütçe yok VEYA spread cazip değil → Near kapat
                var reason = !spreadAttractive ? "spread cazip değil" : "bütçe yok";
                Log("⚠️ RECOVERY: " + sym + " " + reason + ", Near kapatılıyor");
                var nearResult = ExecGuar(nearC, "BUY", realNear);
                if (nearResult.Item1 > 0) {
                    Log("✅ RECOVERY: " + sym + " Near kapatıldı @" + nearResult.Item2.ToString("F2"));
                    snPos.Remove(sym);
                    
                    // orphanLegs'ten sil
                    if (orphanLegs.ContainsKey(sym)) {
                        orphanLegs.Remove(sym);
                        Log("🗑️ RECOVERY: " + sym + " orphanLegs'ten silindi");
                    }
                    
                    SavePositions();
                }
            }
        }
        
    } catch (Exception ex) {
        Log("❌ RECOVERY LEG HATA: " + sym + " - " + ex.Message);
    }
};

// Periyodik recovery kontrolü (11:50, 17:35) ve T+2 negatif kontrolü (16:50)
Action CheckScheduledRecovery = () => {
    if (IS_TEST) return;
    
    var now = DateTime.Now;
    var time = now.Hour * 100 + now.Minute;
    
    // 11:50 veya 17:35 - pozisyon senkronizasyonu
    if ((time == 1150 || time == 1735) && (now - lastRecoveryCheck).TotalMinutes > 5) {
        Log("⏰ Zamanlanmış pozisyon senkronizasyonu");
        SyncAndRecoverPositions();
    }
    
    // 16:50 - T+2 negatif kontrolü
    if (time == 1650 && t2NegativeDetected && (now - lastRecoveryCheck).TotalMinutes > 5) {
        Log("⏰ 16:50 T+2 negatif kontrolü başlatılıyor...");

        // Önce bakiyeleri tazele
        UpdateBalances();

        // Hala negatifse pozisyon kapat
        if (t2Balance < 0) {
            Log("🚨 T+2 hala negatif: " + t2Balance.ToString("N0") + " - pozisyon kapatma başlatılıyor");

            // BIST açık mı kontrol et (yarım gün olabilir)
            var t2Now = DateTime.Now;
            var t2CurrentMinutes = t2Now.Hour * 60 + t2Now.Minute;
            var t2BistCloseMinutes = BIST_CLOSE_HOUR * 60 + BIST_CLOSE_MINUTE;
            var t2IsBistOpen = t2CurrentMinutes >= (MARKET_OPEN_HOUR * 60 + MARKET_OPEN_MINUTE) && t2CurrentMinutes < t2BistCloseMinutes;

            if (!t2IsBistOpen) {
                Log("🚨 T+2 UYARI: BIST KAPALI! Pozisyon kapatılamıyor. T+2 negatif: " + t2Balance.ToString("N0") + " TL - Yarın manuel müdahale gerekebilir!");
                lastRecoveryCheck = DateTime.Now;
                return;
            }

            var needToFree = Math.Abs(t2Balance);
            var freedSpot = 0m;
            var closedCount = 0;

            // En düşük expectedPnl olan pozisyonları bul ve kapat
            while (freedSpot < needToFree && snPos.Count > 0 && closedCount < 5) {
                string worstSym = null;
                var worstPnl = decimal.MaxValue;

                foreach (var kv in snPos) {
                    var expPnl = kv.Value[5];
                    if (expPnl < worstPnl) {
                        worstPnl = expPnl;
                        worstSym = kv.Key;
                    }
                }

                if (worstSym == null) break;

                var worstPos = snPos[worstSym];
                var posSpotValue = worstPos[2] * worstPos[0];  // spotEntry * spotQty

                Log("📊 T+2 KAPATMA: " + worstSym + " ExpPnl:" + worstPnl.ToString("N0") + " SpotDeğer:" + posSpotValue.ToString("N0"));

                // Sıfır kontrolü
                if (posSpotValue <= 0) {
                    Log("⚠️ T+2: posSpotValue sıfır, atlanıyor: " + worstSym);
                    break;
                }

                // Ne kadar kapatmalı?
                var neededRatio = (needToFree - freedSpot) / posSpotValue;
                neededRatio = Math.Min(1m, neededRatio);  // En fazla %100

                if (neededRatio >= 0.9m || worstPos[1] <= 2) {
                    // Tam kapat
                    var nearC = GetContract(worstSym, 0);
                    CloseSN(worstSym, nearC, (int)worstPos[0], (int)worstPos[1], "T2_NEGATIVE");
                    freedSpot += posSpotValue;
                } else {
                    // Kısmi kapat - spot/near oranını koru
                    var closeNQty = (int)Math.Ceiling((double)worstPos[1] * (double)neededRatio);
                    closeNQty = Math.Max(1, closeNQty);
                    var closeSQty = (int)(closeNQty * GetMultiplier(worstSym));
                    closeSQty = Math.Max(100, closeSQty);
                    closeSQty = ((closeSQty + 99) / 100) * 100;  // 100'e yuvarla

                    var nearC = GetContract(worstSym, 0);
                    PartialCloseSN(worstSym, nearC, closeSQty, closeNQty, "T2_NEGATIVE_PARTIAL");
                    freedSpot += posSpotValue * neededRatio;
                }

                closedCount++;

                if (freedSpot >= needToFree) break;
            }

            // Yeterli kapatılamadıysa uyar
            if (freedSpot < needToFree) {
                Log("🚨 T+2 UYARI: Yeterli pozisyon kapatılamadı! Gereken: " + needToFree.ToString("N0") + " Serbest: " + freedSpot.ToString("N0") + " TL");
            }

            // İşlemler sonrası T+2 bakiyesini tekrar kontrol et
            System.Threading.Thread.Sleep(2000);  // Emirlerin işlenmesi için bekle
            UpdateBalances();

            if (t2Balance < 0) {
                Log("🚨 T+2 UYARI: İşlemler sonrası hala negatif: " + t2Balance.ToString("N0") + " TL - Yarın manuel müdahale gerekebilir!");
                // t2NegativeDetected = true olarak kalır, ertesi gün tekrar denenir
            } else {
                Log("✅ T+2 düzeltme başarılı: " + closedCount + " pozisyon kapatıldı, yeni bakiye: " + t2Balance.ToString("N0") + " TL");
                t2NegativeDetected = false;
            }
        } else {
            Log("✅ T+2 pozitife döndü, kapatma gerekmiyor: " + t2Balance.ToString("N0"));
            t2NegativeDetected = false;
        }

        lastRecoveryCheck = DateTime.Now;
    }
};

// Dashboard güncelleme - tek fonksiyon
// fullStats=true: lokal stats.json'u yükle (tam veriler zaten orada)
// resetCommand=true: Gist komutu NONE'a sıfırla
// includeLogs=true: Log ve settings dosyalarını da yükle
// NOT: Pozisyon detayları her zaman gönderilir (fullStats daima true)
// Gist upload işleminin kendisi (sync - thread içinde çalışır)
Action<bool, bool, string, string, string> DoGistUpload = (resetCommand, includeLogs, statsJson, settingsContent, logContent) => {
    try {
        var escaped = statsJson.Replace("\\", "\\\\").Replace("\"", "\\\"").Replace("\n", "\\n").Replace("\r", "");
        
        var body = "{\"files\":{\"arb_stats.json\":{\"content\":\"" + escaped + "\"}";
        
        if (includeLogs) {
            var settingsEscaped = settingsContent.Replace("\\", "\\\\").Replace("\"", "\\\"").Replace("\n", "\\n").Replace("\r", "");
            var logEscaped = logContent.Replace("\\", "\\\\").Replace("\"", "\\\"").Replace("\n", "\\n").Replace("\r", "");
            body += ",\"arb_settings.json\":{\"content\":\"" + settingsEscaped + "\"}";
            body += ",\"arb_logs.txt\":{\"content\":\"" + logEscaped + "\"}";
        }
        
        if (resetCommand) {
            body += ",\"arb_command.json\":{\"content\":\"{\\\"command\\\":\\\"NONE\\\",\\\"ts\\\":\\\"" + DateTime.Now.ToString("HH:mm:ss") + "\\\"}\"}";
        }
        body += "}}";
        
        var req = (System.Net.HttpWebRequest)System.Net.WebRequest.Create("https://api.github.com/gists/" + GIST_ID);
        req.Method = "PATCH";
        req.ContentType = "application/json";
        var authPrefix = GIST_TOKEN.StartsWith("github_pat_") ? "Bearer " : "token ";
        req.Headers.Add("Authorization", authPrefix + GIST_TOKEN);
        req.UserAgent = "ArbBot";
        req.Timeout = 10000;
        req.ReadWriteTimeout = 10000;
        var bytes = System.Text.Encoding.UTF8.GetBytes(body);
        req.ContentLength = bytes.Length;
        using (var s = req.GetRequestStream()) s.Write(bytes, 0, bytes.Length);
        
        using (var resp = req.GetResponse())
        using (var sr = new System.IO.StreamReader(resp.GetResponseStream())) {
            var respJson = sr.ReadToEnd();
            
            // arb_command.json içeriğini parse et
            var cmdContent = "";
            try {
                var cmdIdx = respJson.IndexOf("arb_command.json");
                if (cmdIdx > 0) {
                    var contentIdx = respJson.IndexOf("\"content\":", cmdIdx);
                    if (contentIdx > 0) {
                        var startQuote = respJson.IndexOf("\"", contentIdx + 10) + 1;
                        var endQuote = startQuote;
                        while (endQuote < respJson.Length) {
                            endQuote = respJson.IndexOf("\"", endQuote);
                            if (endQuote <= 0) break;
                            if (endQuote > 0 && respJson[endQuote - 1] != '\\') break;
                            endQuote++;
                        }
                        if (startQuote > 0 && endQuote > startQuote) {
                            cmdContent = respJson.Substring(startQuote, endQuote - startQuote)
                                .Replace("\\\"", "\"").Replace("\\n", "").Replace("\\r", "");
                        }
                    }
                }
                
                // STOP kontrolü
                if (cmdContent.Contains("\"command\":\"STOP\"") || cmdContent.Contains("\"command\": \"STOP\"")) {
                    Log("🛑 Gist'ten STOP komutu alındı!");
                    stopRequested = true;
                    try { System.IO.File.WriteAllText(BASE_PATH + "STOP.txt", "GIST_STOP:" + DateTime.Now.ToString()); } catch { }
                    try { mainForm.BeginInvoke(new Action(() => mainForm.Close())); } catch { }
                }
                // PAUSE kontrolü
                else if (cmdContent.Contains("\"command\":\"PAUSE\"") || cmdContent.Contains("\"command\": \"PAUSE\"")) {
                    if (!isPaused) {
                        Log("⏸️ Gist'ten PAUSE komutu alındı!");
                        isPaused = true;
                        try {
                            mainForm.BeginInvoke(new Action(() => {
                                btnPause.Text = "Başlat";
                                btnPause.BackColor = System.Drawing.Color.FromArgb(40, 167, 69);
                                lblStatus.Text = "⏸️ UZAKTAN DURAKLADI";
                                lblStatus.ForeColor = System.Drawing.Color.Orange;
                            }));
                        } catch { }
                    }
                }
                // RESUME kontrolü
                else if (cmdContent.Contains("\"command\":\"RESUME\"") || cmdContent.Contains("\"command\": \"RESUME\"")) {
                    if (isPaused) {
                        Log("▶️ Gist'ten RESUME komutu alındı!");
                        isPaused = false;
                        if (settingsNeedReload) { LoadSettings(); settingsNeedReload = false; }
                        try {
                            mainForm.BeginInvoke(new Action(() => {
                                btnPause.Text = "Duraklat";
                                btnPause.BackColor = System.Drawing.Color.FromArgb(255, 193, 7);
                                lblStatus.Text = "▶️ ÇALIŞIYOR";
                                lblStatus.ForeColor = System.Drawing.Color.Green;
                            }));
                        } catch { }
                        lastGistUpload = DateTime.MinValue;
                    }
                }
            } catch (Exception cmdEx) {
                Log("📤 Gist cmd okuma hata: " + cmdEx.Message);
            }
        }
        lastGistUpload = DateTime.Now;
    } catch (Exception gistEx) {
        Log("❌ Gist upload hata: " + gistEx.Message);
    } finally {
        gistUploadInProgress = false;
    }
};

// ASYNC Wrapper - MainLoop'u bloklamaz
Action<bool, bool> UpdateDashboard = (resetCommand, includeLogs) => {
    if (string.IsNullOrEmpty(GIST_TOKEN) || string.IsNullOrEmpty(GIST_ID)) return;
    
    // Zaten upload devam ediyorsa atla (queue yapma)
    if (gistUploadInProgress) return;
    
    try {
        // Verileri MAIN THREAD'de hazırla (thread-safe)
        var statsJson = BuildStatsJson();
        
        var settingsContent = "{}";
        var logContent = "Log yok";
        
        if (includeLogs) {
            try {
                if (System.IO.File.Exists(SETTINGS_FILE)) {
                    settingsContent = System.IO.File.ReadAllText(SETTINGS_FILE);
                }
            } catch { }
            
            try {
                var logFilePath = LOG_PATH + "arb.log";
                if (System.IO.File.Exists(logFilePath)) {
                    using (var fs = new System.IO.FileStream(logFilePath, System.IO.FileMode.Open, System.IO.FileAccess.Read, System.IO.FileShare.ReadWrite))
                    using (var sr = new System.IO.StreamReader(fs, System.Text.Encoding.UTF8)) {
                        var allText = sr.ReadToEnd();
                        var allLines = allText.Split(new[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
                        var startIdx = Math.Max(0, allLines.Length - 50);
                        var count = Math.Min(50, allLines.Length);
                        var lastLines = new string[count];
                        Array.Copy(allLines, startIdx, lastLines, 0, count);
                        logContent = string.Join("\n", lastLines);
                    }
                }
            } catch { }
        }
        
        // Upload'ı ayrı thread'de yap
        gistUploadInProgress = true;
        var rc = resetCommand;
        var il = includeLogs;
        var sj = statsJson;
        var sc = settingsContent;
        var lc = logContent;
        
        gistUploadThread = new System.Threading.Thread(() => {
            DoGistUpload(rc, il, sj, sc, lc);
        });
        gistUploadThread.IsBackground = true;  // Ana thread bitince bu da bitsin
        gistUploadThread.Start();
        
    } catch (Exception ex) {
        Log("❌ Gist async hata: " + ex.Message);
        gistUploadInProgress = false;
    }
};

// Gist komutunu kontrol et (duraklama döngüsünde kullanılır)
Action CheckGistCommand = () => {
    if (string.IsNullOrEmpty(GIST_TOKEN) || string.IsNullOrEmpty(GIST_ID)) return;
    try {
        var req = (System.Net.HttpWebRequest)System.Net.WebRequest.Create("https://api.github.com/gists/" + GIST_ID);
        req.Method = "GET";
        var authPrefix = GIST_TOKEN.StartsWith("github_pat_") ? "Bearer " : "token ";
        req.Headers.Add("Authorization", authPrefix + GIST_TOKEN);
        req.UserAgent = "ArbBot";
        req.Timeout = 10000;
        
        using (var resp = req.GetResponse())
        using (var sr = new System.IO.StreamReader(resp.GetResponseStream())) {
            var respJson = sr.ReadToEnd();
            
            // arb_command.json içeriğini parse et
            var cmdContent = "";
            var cmdIdx = respJson.IndexOf("arb_command.json");
            if (cmdIdx > 0) {
                var contentIdx = respJson.IndexOf("\"content\":", cmdIdx);
                if (contentIdx > 0) {
                    var startQuote = respJson.IndexOf("\"", contentIdx + 10) + 1;
                    var endQuote = startQuote;
                    while (endQuote < respJson.Length) {
                        endQuote = respJson.IndexOf("\"", endQuote);
                        if (endQuote <= 0) break;
                        if (endQuote > 0 && respJson[endQuote - 1] != '\\') break;
                        endQuote++;
                    }
                    if (startQuote > 0 && endQuote > startQuote) {
                        cmdContent = respJson.Substring(startQuote, endQuote - startQuote)
                            .Replace("\\\"", "\"").Replace("\\n", "").Replace("\\r", "");
                    }
                }
            }
            
            // STOP kontrolü
            if (cmdContent.Contains("\"command\":\"STOP\"")) {
                Log("🛑 Gist'ten STOP komutu alındı!");
                stopRequested = true;
                try { System.IO.File.WriteAllText(BASE_PATH + "STOP.txt", "GIST_STOP:" + DateTime.Now.ToString()); } catch { }
                try { mainForm.BeginInvoke(new Action(() => mainForm.Close())); } catch { }
            }
            // RESUME kontrolü
            else if (cmdContent.Contains("\"command\":\"RESUME\"")) {
                Log("▶️ Gist'ten RESUME komutu alındı!");
                isPaused = false;
                if (settingsNeedReload) { LoadSettings(); settingsNeedReload = false; }
                try {
                    mainForm.BeginInvoke(new Action(() => {
                        btnPause.Text = "Duraklat";
                        btnPause.BackColor = System.Drawing.Color.FromArgb(255, 193, 7);
                        lblStatus.Text = "▶️ ÇALIŞIYOR";
                        lblStatus.ForeColor = System.Drawing.Color.Green;
                    }));
                } catch { }
                // RESUME sonrası hemen tam stats gönder
                lastGistUpload = DateTime.MinValue;
            }
        }
    } catch { }
};

// Gist komutunu NONE olarak sıfırla (formdan devam edildiğinde)
Action ResetGistToNone = () => {
    if (string.IsNullOrEmpty(GIST_TOKEN) || string.IsNullOrEmpty(GIST_ID)) return;
    try {
        var authPrefix = GIST_TOKEN.StartsWith("github_pat_") ? "Bearer " : "token ";
        var body = "{\"files\":{\"arb_command.json\":{\"content\":\"{\\\"command\\\":\\\"NONE\\\",\\\"ts\\\":\\\"" + DateTime.Now.ToString("HH:mm:ss") + "\\\"}\"}}}";
        var req = (System.Net.HttpWebRequest)System.Net.WebRequest.Create("https://api.github.com/gists/" + GIST_ID);
        req.Method = "PATCH";
        req.ContentType = "application/json";
        req.Headers.Add("Authorization", authPrefix + GIST_TOKEN);
        req.UserAgent = "ArbBot";
        req.Timeout = 10000;
        var bytes = System.Text.Encoding.UTF8.GetBytes(body);
        req.ContentLength = bytes.Length;
        using (var s = req.GetRequestStream()) s.Write(bytes, 0, bytes.Length);
        using (var resp = req.GetResponse()) { }
        Log("✅ Gist komut sıfırlandı (NONE)");
    } catch (Exception ex) {
        Log("⚠️ Gist komut sıfırlama hata: " + ex.Message);
    }
};

// ====================================
// ANA DÖNGÜ
// ====================================
Action MainLoop = () => {
    // Canlı modda API verisi yoksa hiç işlem yapma
    if (!IS_TEST && !apiDataOk) {
        return;  // Sessizce çık, log zaten UpdateBalances'da yazıldı
    }
    
    var now = DateTime.Now.Ticks;
    var ic = System.Globalization.CultureInfo.InvariantCulture;
    decimal totalSnPnl = 0;
    var snStats = new System.Text.StringBuilder();
    var firstSn = true;
    
    // BIST açık mı? (SN açılış/kapanış için gerekli)
    var nowTime = DateTime.Now;
    var bistCloseMinutes = BIST_CLOSE_HOUR * 60 + BIST_CLOSE_MINUTE;
    var currentMinutesNow = nowTime.Hour * 60 + nowTime.Minute;
    var isBistOpen = currentMinutesNow >= (MARKET_OPEN_HOUR * 60 + MARKET_OPEN_MINUTE) && currentMinutesNow < bistCloseMinutes;
    
    // ============ ORPHAN LEGS İŞLEME (10:05 sonrası) ============
    // Açılış volatilitesi bekleten orphan'ları işle
    // İki tip orphan var:
    // 1. Near SELL var, Spot yok → Spot BUY veya Near geri al
    // 2. Spot var, Near yok → Near SELL veya Spot kapat
    var orphanRecoveryStart = MARKET_OPEN_HOUR * 60 + MARKET_OPEN_MINUTE + 5;  // 10:05
    if (isBistOpen && currentMinutesNow >= orphanRecoveryStart && orphanLegs.Count > 0) {
        var orphansToProcess = new System.Collections.Generic.List<string>();
        foreach (var kv in orphanLegs) {
            orphansToProcess.Add(kv.Key);
        }
        
        foreach (var oSym in orphansToProcess) {
            try {
                var oData = orphanLegs[oSym];
                var filledLeg = (string)oData[0];
                var filledSide = (string)oData[2];
                var mult = GetMultiplier(oSym);
                
                // Güncel fiyatları al
                var spotS = SPOT_PREFIX + oSym;
                var nearC = GetContract(oSym, 0);
                var nearS = FUTURES_PREFIX + nearC;
                
                var spotAskD = ReadDepth(spotS, "ASK", 0, 1, 50);
                var spotBidD = ReadDepth(spotS, "BID", 0, 1, 50);
                var nearAskD = ReadDepth(nearS, "ASK", 0, 1, 50);
                var nearBidD = ReadDepth(nearS, "BID", 0, 1, 50);
                
                var spotAskNow = spotAskD.Item1 ? spotAskD.Item4 : 0m;
                var spotBidNow = spotBidD.Item1 ? spotBidD.Item4 : 0m;
                var nearAskNow = nearAskD.Item1 ? nearAskD.Item4 : 0m;
                var nearBidNow = nearBidD.Item1 ? nearBidD.Item4 : 0m;
                
                if (spotAskNow <= 0 || nearAskNow <= 0 || spotBidNow <= 0 || nearBidNow <= 0) {
                    Log("⚠️ ORPHAN RECOVERY: " + oSym + " fiyat alınamadı, tekrar denenecek");
                    continue;
                }
                
                // ========== TİP 1: Near SELL var, Spot yok ==========
                if (filledLeg == "NEAR" && filledSide == "SELL") {
                    var nearQty = (int)oData[3];
                    var nearEntryPrice = (decimal)oData[4];  // Near SELL fiyatı (0 ise bilinmiyor)
                    var spotQty = (int)oData[8];
                    
                    // Eğer Near giriş fiyatı bilinmiyorsa (eski recovery), şimdiki fiyatı kullan
                    if (nearEntryPrice == 0) nearEntryPrice = nearBidNow;
                    
                    // SEÇİM 1: Spot BUY - Pozisyonu tamamla
                    var spotComm = CalcSpotCommission(spotAskNow, spotQty);
                    var expectedSpread = (nearEntryPrice - spotAskNow) / spotAskNow;
                    var expectedPnlIfComplete = expectedSpread * spotAskNow * spotQty;
                    expectedPnlIfComplete -= spotComm * 2;  // Alış + ileride satış komisyonu
                    
                    // SEÇİM 2: Near BUY - Pozisyonu geri al (iptal)
                    var nearComm = CalcCommission(oSym, nearAskNow, nearQty);
                    var nearPnlIfClose = (nearEntryPrice - nearAskNow) * nearQty * mult;
                    nearPnlIfClose -= nearComm * 2;
                    
                    Log("📊 ORPHAN KARAR: " + oSym + " (Near var, Spot yok)" +
                        " | Spot BUY @" + spotAskNow.ToString("F2") + " → Beklenen:" + expectedPnlIfComplete.ToString("F0") + " TL" +
                        " | Near GERİ AL @" + nearAskNow.ToString("F2") + " → Kâr/Zarar:" + nearPnlIfClose.ToString("F0") + " TL");
                    
                    if (expectedPnlIfComplete >= nearPnlIfClose) {
                        // SPOT BUY daha karlı - Pozisyonu tamamla
                        Log("🔄 ORPHAN: " + oSym + " Spot BUY seçildi (daha karlı)");
                        
                        var sr = ExecGuar(oSym, "BUY", spotQty);
                        if (sr.Item1 > 0) {
                            var spotFilledQty = sr.Item1;
                            var spotAvgP = sr.Item2;
                            
                            if (spotAvgP > 0) {
                                var openSpread = (nearEntryPrice - spotAvgP) / spotAvgP;
                                var expPnl = openSpread * spotAvgP * spotFilledQty;
                                var sComm = CalcSpotCommission(spotAvgP, spotFilledQty);
                                var nComm = CalcCommission(oSym, nearEntryPrice, nearQty);
                                expPnl -= (sComm + nComm) * 2;
                                
                                snPos[oSym] = new decimal[] { spotFilledQty, nearQty, spotAvgP, nearEntryPrice, openSpread, expPnl, 0, DateTime.Now.Ticks };
                                dailySpotCommission += sComm;
                                dailyViopCommission += nComm;
                                spotUsed += spotAvgP * spotFilledQty;
                                var viopTeminat = teminat.ContainsKey(oSym) ? teminat[oSym] * nearQty : 0;
                                viopUsed += viopTeminat;
                                
                                orphanLegs.Remove(oSym);
                                Log("✅ ORPHAN TAMAMLANDI: " + oSym + " Spot:" + spotFilledQty + " @" + spotAvgP.ToString("F2") + 
                                    " Spread:" + (openSpread * 100).ToString("F3") + "% Beklenen:" + expPnl.ToString("F0"));
                                SavePositions();
                                if (SaveDailyStats != null) SaveDailyStats();
                            }
                        } else {
                            Log("⚠️ ORPHAN: " + oSym + " Spot BUY başarısız, tekrar denenecek");
                        }
                    } else {
                        // NEAR BUY daha karlı - Pozisyonu geri al
                        Log("🔄 ORPHAN: " + oSym + " Near GERİ ALIM seçildi (daha karlı/az zararlı)");
                        
                        var nearOrderId = IS_TEST ? "TEST_ORPHAN_CLOSE_" + DateTime.Now.Ticks :
                            Sistem.EmirGonder(nearS, "BUY", nearQty, 0, "VIOP", "Piyasa");
                        
                        if (!string.IsNullOrEmpty(nearOrderId)) {
                            var closePnl = (nearEntryPrice - nearAskNow) * nearQty * mult;
                            var closeComm = CalcCommission(oSym, nearAskNow, nearQty) + CalcCommission(oSym, nearEntryPrice, nearQty);
                            closePnl -= closeComm;
                            dailyRealizedPnl += closePnl;
                            dailyViopCommission += closeComm;
                            
                            orphanLegs.Remove(oSym);
                            Log("✅ ORPHAN GERİ ALINDI: " + oSym + " Near BUY x" + nearQty + " @" + nearAskNow.ToString("F2") + 
                                " P&L:" + closePnl.ToString("F0") + " TL");
                            SavePositions();
                            if (SaveDailyStats != null) SaveDailyStats();
                        } else {
                            Log("⚠️ ORPHAN: " + oSym + " Near BUY emri başarısız, tekrar denenecek");
                        }
                    }
                }
                // ========== TİP 2: Spot var, Near yok ==========
                else if (filledLeg == "SPOT" && filledSide == "HOLD") {
                    var spotQty = (int)oData[3];
                    var spotEntryPrice = (decimal)oData[4];  // Spot giriş fiyatı
                    var nearQty = spotQty / 100;
                    
                    // SEÇİM 1: Near SELL - Pozisyonu tamamla
                    var nearComm = CalcCommission(oSym, nearBidNow, nearQty);
                    var expectedSpread = (nearBidNow - spotAskNow) / spotAskNow;
                    var expectedPnlIfComplete = expectedSpread * spotAskNow * spotQty;
                    expectedPnlIfComplete -= nearComm * 2;  // Near açılış + kapanış
                    
                    // SEÇİM 2: Spot SELL - Pozisyonu kapat
                    var spotComm = CalcSpotCommission(spotBidNow, spotQty);
                    var spotPnlIfClose = 0m;
                    if (spotEntryPrice > 0) {
                        spotPnlIfClose = (spotBidNow - spotEntryPrice) * spotQty;  // Gerçek P&L
                    }
                    spotPnlIfClose -= spotComm;  // Satış komisyonu
                    
                    Log("📊 ORPHAN KARAR: " + oSym + " (Spot var, Near yok)" +
                        " | Near SELL @" + nearBidNow.ToString("F2") + " → Beklenen:" + expectedPnlIfComplete.ToString("F0") + " TL" +
                        " | Spot KAPAT @" + spotBidNow.ToString("F2") + " → Komisyon:" + spotPnlIfClose.ToString("F0") + " TL");
                    
                    // Spread cazip mi? (min marj + komisyon)
                    var minRequired = SN_MIN_MARGIN;
                    
                    if (expectedSpread >= minRequired && expectedPnlIfComplete > spotPnlIfClose) {
                        // NEAR SELL daha karlı - Pozisyonu tamamla
                        Log("🔄 ORPHAN: " + oSym + " Near SELL seçildi (spread cazip)");
                        
                        var nr = ExecGuar(nearC, "SELL", nearQty);
                        if (nr.Item1 > 0) {
                            var nearFilledQty = nr.Item1;
                            var nearAvgP = nr.Item2;
                            
                            var openSpread = (nearAvgP - spotAskNow) / spotAskNow;
                            var expPnl = openSpread * spotAskNow * spotQty;
                            var sComm = CalcSpotCommission(spotAskNow, spotQty);
                            var nComm = CalcCommission(oSym, nearAvgP, nearFilledQty);
                            expPnl -= (sComm + nComm) * 2;
                            
                            snPos[oSym] = new decimal[] { spotQty, nearFilledQty, spotAskNow, nearAvgP, openSpread, expPnl, 0, DateTime.Now.Ticks };
                            dailyViopCommission += nComm;
                            var viopTeminat = teminat.ContainsKey(oSym) ? teminat[oSym] * nearFilledQty : 0;
                            viopUsed += viopTeminat;
                            
                            orphanLegs.Remove(oSym);
                            Log("✅ ORPHAN TAMAMLANDI: " + oSym + " Near:" + nearFilledQty + " @" + nearAvgP.ToString("F2") + 
                                " Spread:" + (openSpread * 100).ToString("F3") + "% Beklenen:" + expPnl.ToString("F0"));
                            SavePositions();
                            if (SaveDailyStats != null) SaveDailyStats();
                        } else {
                            Log("⚠️ ORPHAN: " + oSym + " Near SELL başarısız, tekrar denenecek");
                        }
                    } else {
                        // SPOT SELL - Pozisyonu kapat
                        Log("🔄 ORPHAN: " + oSym + " Spot KAPAT seçildi (spread cazip değil)");
                        
                        var sr = ExecGuar(oSym, "SELL", spotQty);
                        if (sr.Item1 > 0) {
                            dailySpotCommission += CalcSpotCommission(sr.Item2, sr.Item1);
                            
                            orphanLegs.Remove(oSym);
                            Log("✅ ORPHAN KAPATILDI: " + oSym + " Spot SELL x" + sr.Item1 + " @" + sr.Item2.ToString("F2"));
                            SavePositions();
                            if (SaveDailyStats != null) SaveDailyStats();
                        } else {
                            Log("⚠️ ORPHAN: " + oSym + " Spot SELL başarısız, tekrar denenecek");
                        }
                    }
                }
            } catch (Exception ex) {
                Log("❌ ORPHAN RECOVERY: " + oSym + " hata: " + ex.Message);
            }
        }
    }
    
    foreach (var sym in symbols) {
        try {
            if (IsBlocked(sym)) continue;
            
            var spotS = SPOT_PREFIX + sym;
            var nearC = GetContract(sym, 0);
            var farC = GetContract(sym, 1);
            var nearS = FUTURES_PREFIX + nearC;
            
            // Derinlikten fiyat al (yüzeysel veri 26ms gecikmeli olabilir)
            var spotAskDepth = ReadDepth(spotS, "ASK", 0, 1, 50);  // Spot Ask
            var spotBidDepth = ReadDepth(spotS, "BID", 0, 1, 50);  // Spot Bid
            var nearBidDepth = ReadDepth(nearS, "BID", 0, 1, 50);  // Near Bid
            var nearAskDepth = ReadDepth(nearS, "ASK", 0, 1, 50);  // Near Ask
            
            var spotAsk = spotAskDepth.Item1 ? spotAskDepth.Item4 : 0m;
            var spotBid = spotBidDepth.Item1 ? spotBidDepth.Item4 : 0m;
            var nearBid = nearBidDepth.Item1 ? nearBidDepth.Item4 : 0m;
            var nearAsk = nearAskDepth.Item1 ? nearAskDepth.Item4 : 0m;
            
            if (spotAsk == 0 && nearAsk == 0) continue;
            
            // Spread hesabı: derinlikten (yüzeysel veri 26ms gecikmeli)
            // dayanakAlSat = nearBid - spotAsk (açılış spread'i)
            // dayanakSatAl = nearAsk - spotBid (kapanış spread'i)
            var dayanakAlSat = nearBid - spotAsk;
            var dayanakSatAl = nearAsk - spotBid;
            
            var daysN = GetDays(nearC);
            var daysF = GetDays(farC);
            var tem = teminat.ContainsKey(sym) ? teminat[sym] : 0;
            var xlbnkT = teminat.ContainsKey("XLBNK") ? teminat["XLBNK"] : 20000m;
            var qty = tem > 0 ? (int)Math.Max(1, xlbnkT / tem) : 1;
            
            var snSp = spotAsk > 0 ? (dayanakAlSat / spotAsk) * 100 : 0;
            
            // BB pozisyonu (5dk'da bir grafikten güncelleniyor)
            var sBBPos = snBBPos.ContainsKey(sym) ? snBBPos[sym] : 50m;
            
            // P&L hesapla (piyasa kapalıyken de hesaplanır - sadece görüntüleme)
            if (snPos.ContainsKey(sym)) {
                var snP = snPos[sym];
                var snPnl = (spotBid - snP[2]) * snP[0] + (snP[3] - nearAsk) * snP[1] * GetMultiplier(sym);
                totalSnPnl += snPnl;
                if (!firstSn) snStats.Append(",");
                firstSn = false;
                snStats.Append("\"" + sym + "\":{\"sq\":" + ((int)snP[0]).ToString() + 
                    ",\"nq\":" + ((int)snP[1]).ToString() +
                    ",\"pnl\":" + snPnl.ToString("F0", ic) + 
                    ",\"exp\":" + snP[5].ToString("F0", ic) +
                    ",\"d\":" + ((int)snP[6]).ToString() + "}");
            }
            
            // === PİYASA KAPALI İSE SADECE SPREAD KAYDI YAP ===
            if (!isMarketOpen) continue;
            
            // === BROKER BAĞLANTISI YOKSA EMİR GÖNDERME (Test modu hariç) ===
            if (!brokerConnected && !IS_TEST) continue;
            
            // === DEVRE KESİCİ KONTROLÜ ===
            var spotCircuit = IsSpotCircuitBreaker(sym);
            var hasPosition = snPos.ContainsKey(sym);
            
            // ENDEKS DEVRE KESİCİ: Tüm işlemler engellenir (vade günü hariç - o zaman kapat)
            if (indexCircuitBreaker && hasPosition) {
                if (daysN == 0) {
                    // Vade günü - pozisyonu hemen kapat
                    Log("🔴 ENDEKS DEVRE KESİCİ + VADE GÜNÜ: " + sym + " kapatılıyor");
                    CloseSN(sym, nearC, (int)snPos[sym][0], (int)snPos[sym][1], "Endeks devre kesici + Vade günü");
                }
                // Vade günü değilse: rollover, kapanış ve tüm işlemler engelli - sadece bekle
                continue;
            }
            
            // SPOT DEVRE KESİCİ: O hisse için tüm işlemler engellenir (vade günü hariç - o zaman kapat)
            if (spotCircuit && hasPosition) {
                if (daysN == 0) {
                    // Vade günü - pozisyonu hemen kapat
                    Log("🔴 SPOT DEVRE KESİCİ + VADE GÜNÜ: " + sym + " kapatılıyor");
                    CloseSN(sym, nearC, (int)snPos[sym][0], (int)snPos[sym][1], "Spot devre kesici + Vade günü");
                }
                // Vade günü değilse: rollover, kapanış ve tüm işlemler engelli - sadece bekle
                continue;
            }
            
            // Devre kesici yoksa normal işlem akışına devam et
            
            // Kapanış kontrolü (sadece BIST açıkken - Spot satılmalı)
            if (isBistOpen) {
                var snCloseReason = CheckSNClose(sym, nearC, spotBid, nearAsk, daysN, sBBPos);
                if (snCloseReason != null) {
                    CloseSN(sym, nearC, (int)snPos[sym][0], (int)snPos[sym][1], snCloseReason);
                    continue;  // Pozisyon kapandı, bu sembol için devam etme
                }
            }
            
            // Rollover kontrolü (vadeye 1 gün veya vade günü, sadece BIST açıkken, vade günü 12:00 sonrası)
            var rolloverTimeOk = daysN > 0 || (DateTime.Now.Hour * 60 + DateTime.Now.Minute >= 12 * 60);
            if (isBistOpen && snPos.ContainsKey(sym) && daysN <= 1 && daysN >= 0 && spotAsk > 0 && rolloverTimeOk) {
                var farBidDepth = ReadDepth(FUTURES_PREFIX + farC, "BID", 0, 1, 50);
                var farBid = farBidDepth.Item1 ? farBidDepth.Item4 : 0m;
                var farSpread = (farBid - spotAsk) / spotAsk;
                
                // Rollover karlılık kontrolü: Far spread >= dinamik eşik + min kar marjı + x2 komisyon
                var farThreshold = SNThreshold(daysF);
                var rolloverCommCost = (CalcCommission(sym, spotAsk, 1) * 2) / (spotAsk * 1);  // x2 komisyon oranı
                var minRequired = farThreshold + ROLL_MIN_MARGIN + rolloverCommCost;
                
                if (farSpread >= minRequired) {
                    Log("🔄 Rollover uygun: Far spread " + (farSpread * 100).ToString("F3") + "% >= " + (minRequired * 100).ToString("F3") + "%");
                    RolloverSN(sym, nearC, farC, (int)snPos[sym][1]);
                } else if (daysN == 0) {
                    // Vade günü ve rollover karlı değil - pozisyonu kapat
                    Log("⚠️ Vade günü, rollover karlı değil - pozisyon kapatılıyor");
                    CloseSN(sym, nearC, (int)snPos[sym][0], (int)snPos[sym][1], "Vade sonu (rollover uygun değil)");
                }
            }
            
            // === YENİ POZİSYON / BÜYÜTME İÇİN DEVRE KESİCİ KONTROLÜ ===
            // Endeks veya spot devre kesici aktifse yeni pozisyon açma/büyütme
            if (indexCircuitBreaker || spotCircuit) continue;
            
            // Fırsat tarama (sadece piyasa açıkken)
            if (rejected.ContainsKey(sym) && now - rejected[sym] < COOLDOWN) continue;
            
            // Pozisyon yoksa veya varsa işlem kontrolü
            
            if (!snPos.ContainsKey(sym)) {
                // Near vade son günü yeni pozisyon açma
                if (daysN <= 0) continue;
                
                var snThresh = SNThreshold(daysN);
                var snSpPct = snSp / 100m;
                
                // BB93 saat kontrolü (10:00-12:55 arası)
                var bb93Now = DateTime.Now;
                var bb93TimeOk = (bb93Now.Hour > BB93_START_HOUR || (bb93Now.Hour == BB93_START_HOUR && bb93Now.Minute >= BB93_START_MIN)) &&
                                 (bb93Now.Hour < BB93_END_HOUR || (bb93Now.Hour == BB93_END_HOUR && bb93Now.Minute <= BB93_END_MIN));
                
                // BB 93+ ise margin kontrolü yapma, direkt gir (5dk BB - gün içi strateji)
                var isBB93Entry = BB93_ENTRY_ENABLED && bb93TimeOk && sBBPos >= BB93_ENTRY_THRESHOLD;
                
                // Spread uygun mu? (BB93+ ise threshold kontrolü atlanır)
                if ((isBB93Entry || snSpPct >= snThresh) && spotAsk > 0) {
                    // Günlük BB kontrolü kaldırıldı - analiz sonucu işe yaramıyor
                    // Sadece BB93+ (5dk intraday) stratejisi aktif
                    
                    // BIST KAPALI İSE YENİ POZİSYON AÇMA (Spot alınamaz!)
                    if (!isBistOpen) continue;
                    
                    // AÇILIŞ VOLATİLİTESİ KORUMASI: 10:05'e kadar yeni giriş yapma
                    // Temettü gap'i ve açılış volatilitesi riski
                    if (!IsAfterOpeningVolatility()) {
                        continue;  // Sessizce atla
                    }
                    
                    // TEMETTÜ GÜNÜ KORUMASI: Ex-dividend günü o sembole giriş yapma
                    // Spot fiyat temettü kadar düşer, Near henüz düzelmemiş olabilir
                    if (IsDividendDay(sym)) {
                        Log("⚠️ SN: " + sym + " temettü günü - giriş atlandı");
                        continue;
                    }
                    
                    // SERMAYE ARTIRIMI KORUMASI: Bugün veya 7 gün içinde sermaye artırımı varsa atla
                    if (IsSermayeArtirimiBlocked(sym)) {
                        Log("⛔ SN: " + sym + " sermaye artırımı - giriş atlandı");
                        continue;
                    }
                    
                    // Not: Devre kesici kontrolü döngü başında yapıldı
                    
                    // TAVAN/TABAN KONTROLÜ - Pozisyon açma
                    // Pozisyon açarken: Spot ALIYORUZ + Near SATIYORUZ
                    var spotSym = SPOT_PREFIX + sym;
                    var nearSym = FUTURES_PREFIX + nearC;
                    
                    // Spot TAVAN ise → ALINAMAZ (satıcı yok)
                    var spotTavanFiyat = tavanFiyat.ContainsKey(spotSym) ? tavanFiyat[spotSym] : 0;
                    if (spotTavanFiyat > 0 && spotAsk >= spotTavanFiyat) {
                        // Spot tavanda - alınamaz, pozisyon açılamaz
                        continue;
                    }
                    
                    // Near TABAN ise → SATILAMAZ (alıcı yok)
                    var nearTabanFiyat = tabanFiyat.ContainsKey(nearSym) ? tabanFiyat[nearSym] : 0;
                    if (nearTabanFiyat > 0 && nearBid <= nearTabanFiyat) {
                        // Near tabanda - satılamaz, pozisyon açılamaz
                        continue;
                    }
                    
                    var snSQty = qty * 100;
                    var reqS = spotAsk * snSQty;
                    var reqV = tem * qty;
                    
                    // Bütçe sınır kontrolü: Pozisyon değerinin 2 katı boşluk yoksa
                    // replacement riski var, ekstra komisyon eşiği iste
                    // BB93+ girişlerinde bu kontrol atlanır
                    var spotBosluk = spotBalance - reqS;
                    var viopBosluk = viopBalance - reqV;
                    var budgetTight = !isBB93Entry && ((spotBosluk < reqS * 2) || (viopBosluk < reqV * 2));
                    
                    if (budgetTight) {
                        // Bütçe sınırda - threshold'a ekstra komisyon ekle
                        var tightThresh = snThresh + SN_TOTAL_COST;
                        if (snSpPct < tightThresh) {
                            // Bütçe sınırda ve spread yetersiz - sessizce atla
                            continue;
                        }
                    }
                    
                    if (reqS <= spotBalance && reqV <= viopBalance) {
                        var filterInfo = "";
                        if (budgetTight) filterInfo += " [BÜTÇE SINIRDA]";
                        if (isBB93Entry) filterInfo += " [BB93+]";
                        Log("🎯 SN: " + sym + " BB:" + sBBPos.ToString("F0") + " Sp:" + snSp.ToString("F3") + "%" + filterInfo);
                        
                        // BB93+ girişi ise flag'i kaydet (p[6] = 1)
                        var bb93Flag = isBB93Entry ? 1 : 0;
                        if (OpenSN(sym, nearC, snSQty, qty, snThresh, bb93Flag)) {
                            UpdateBalances();
                        }
                        else rejected[sym] = DateTime.Now.Ticks;
                    } else {
                            // Bütçe yetersiz - replacement değerlendir
                            var eksikS = reqS - spotBalance;
                            var eksikV = reqV - viopBalance;
                            
                            // Near derinlik kontrolü - önce yüzeysel veri (hızlı), yetmezse derinlik
                            // nearSym zaten yukarıda tanımlı (tavan/taban kontrolünde)
                            var nearDepthQty = (int)Sistem.SatisLot(nearSym);  // Near satıyoruz, Bid tarafı
                            if (nearDepthQty < qty) {
                                // 1. kademe yetmiyor, 2. kademeye de bak
                                System.Threading.Thread.Sleep(200);
                                dynamic nearDepthCheck = Sistem.DerinlikVerisiOku(nearSym);
                                if (nearDepthCheck != null && nearDepthCheck.Bids != null && nearDepthCheck.Bids.Count > 1) {
                                    nearDepthQty += (int)nearDepthCheck.Bids[1].Size;
                                }
                                if (nearDepthQty < qty) {
                                    // Near derinlik yetersiz - sessizce atla
                                    continue;
                                }
                            }
                            
                            // Yeni pozisyonun beklenen karı (açılış + kapanış komisyonu dahil)
                            var newOpenComm = CalcSpotCommission(spotAsk, snSQty) + CalcCommission(sym, nearBid, qty);
                            var newExpectedPnl = snSpPct * spotAsk * snSQty - newOpenComm * 2;  // x2: açılış + kapanış
                            
                            // Bütçe sınırda kontrolü - replacement sonrası yeni pozisyon için de geçerli
                            // Replacement yapılacaksa yeni pozisyon da bütçe sınırda threshold'u geçmeli
                            var tightThreshForReplacement = snThresh + SN_TOTAL_COST;
                            if (snSpPct < tightThreshForReplacement) {
                                // Spread yetersiz - sessizce atla
                                continue;
                            }
                            
                            // ============ ÖNCE AÇ SONRA KAPAT MODU (v17) ============
                            // VIOP ve/veya SPOT rezervi kullanarak önce yeni pozisyonu aç
                            // Koşullar: eksikler rezerv limitlerini aşmamalı
                            var useReserveMode = false;
                            var reserveNeededV = 0m;
                            var reserveNeededS = 0m;
                            
                            // VIOP eksik mi ve rezerv yeterli mi?
                            var viopOk = eksikV <= 0 || (eksikV > 0 && eksikV <= VIOP_RESERVE);
                            // SPOT eksik mi ve rezerv (kredi) yeterli mi?
                            var spotOk = eksikS <= 0 || (eksikS > 0 && eksikS <= SPOT_RESERVE);
                            
                            if (viopOk && spotOk && (eksikV > 0 || eksikS > 0)) {
                                // === ÖNEMLİ: Kapatılabilir pozisyon var mı kontrol et ===
                                // Rezerv moduna girmeden önce en az bir pozisyonun threshold geçtiğinden emin ol
                                var hasCloseablePosition = false;
                                var tempExclude = new System.Collections.Generic.HashSet<string>();
                                tempExclude.Add(sym);  // Yeni açılacak sembolü hariç tut
                                
                                var checkResult = FindWorstSNPosition(sym, tempExclude);
                                if (checkResult.Item1 != null) {
                                    var checkSym = checkResult.Item1;
                                    var checkEntrySpread = checkResult.Item2;
                                    var checkPos = snPos[checkSym];
                                    var checkSQty = (int)checkPos[0];
                                    var checkNQty = (int)checkPos[1];
                                    
                                    // Threshold hesapla
                                    var checkCloseSpotComm = CalcSpotCommission(checkPos[2], checkSQty);
                                    var checkCloseNearComm = CalcCommission(checkSym, checkPos[3], checkNQty);
                                    var checkCloseComm = checkCloseSpotComm + checkCloseNearComm;
                                    var checkCloseCommRate = (checkPos[2] * checkSQty) > 0 ? checkCloseComm / (checkPos[2] * checkSQty) : 0;
                                    var checkNewSpreadNet = snSpPct - (newOpenComm / (spotAsk * snSQty)) - checkCloseCommRate;
                                    var checkMinRequired = checkEntrySpread * (1 + REPLACEMENT_THRESHOLD);
                                    
                                    if (checkNewSpreadNet > checkMinRequired) {
                                        hasCloseablePosition = true;
                                    }
                                }
                                
                                if (!hasCloseablePosition) {
                                    // Kapatılabilir pozisyon yok - rezerv moduna girme!
                                    continue;
                                }
                                
                                // En az biri eksik ve her ikisi de rezerv limitleri içinde
                                useReserveMode = true;
                                reserveNeededV = eksikV > 0 ? eksikV : 0;
                                reserveNeededS = eksikS > 0 ? eksikS : 0;
                                var reserveInfo = "";
                                if (reserveNeededV > 0) reserveInfo += "VIOP:" + reserveNeededV.ToString("N0");
                                if (reserveNeededS > 0) reserveInfo += (reserveInfo.Length > 0 ? " + " : "") + "SPOT(kredi):" + reserveNeededS.ToString("N0");
                                Log("🔄 REZERV MODU: " + sym + " için rezerv kullanılacak (" + reserveInfo + " TL)");
                            }
                            
                            if (useReserveMode) {
                                // ÖNCE YENİ POZİSYONU AÇ (rezerv kullanarak)
                                
                                // === Near VE Spot derinlik kontrolü + miktar ayarlama (3 deneme) ===
                                var nearFullSym = FUTURES_PREFIX + nearC;
                                var spotFullSym = SPOT_PREFIX + sym;
                                var mult = GetMultiplier(sym);
                                
                                var reserveDepthOK = false;
                                var nearTotalDepth = 0;
                                var nearBid1Size = 0;
                                var nearBid2Size = 0;
                                var nearBidPrice = 0m;
                                var spotTotalDepth = 0;
                                var spotAsk1Size = 0;
                                var spotAsk2Size = 0;
                                var spotAskPrice = 0m;
                                var actualSQty = 0;
                                var actualNQty = 0;
                                
                                for (int depthAttempt = 1; depthAttempt <= 3; depthAttempt++) {
                                    // 1. Near derinliği kontrol et (3 deneme ile)
                                    nearBid1Size = 0;
                                    nearBid2Size = 0;
                                    nearBidPrice = 0m;
                                    
                                    for (int depthTry = 1; depthTry <= 3; depthTry++) {
                                        dynamic nearDepthData = Sistem.DerinlikVerisiOku(nearFullSym);
                                        if (nearDepthData != null && nearDepthData.Bids != null && nearDepthData.Bids.Count > 0) {
                                            nearBid1Size = (int)nearDepthData.Bids[0].Size;
                                            nearBid2Size = nearDepthData.Bids.Count > 1 ? (int)nearDepthData.Bids[1].Size : 0;
                                            nearBidPrice = (decimal)nearDepthData.Bids[0].Price;
                                            if (nearBid1Size > 0 || nearBid2Size > 0) break;
                                        }
                                        if (depthTry < 3) System.Threading.Thread.Sleep(100);
                                    }
                                    nearTotalDepth = nearBid1Size + nearBid2Size;
                                    
                                    if (nearTotalDepth < 1 || nearBidPrice <= 0) {
                                        if (depthAttempt < 3) {
                                            Log("⏳ REZERV AÇILIŞ: " + sym + " Near derinlik bekleniyor (deneme " + depthAttempt + "/3)");
                                            System.Threading.Thread.Sleep(300);
                                            continue;
                                        }
                                        Log("❌ REZERV AÇILIŞ: " + sym + " Near derinlik/fiyat yok");
                                        break;
                                    }
                                    
                                    // 2. Spot derinliği kontrol et (3 deneme ile)
                                    var snSQtyNeeded = qty * mult;
                                    spotAsk1Size = 0;
                                    spotAsk2Size = 0;
                                    spotAskPrice = 0m;
                                    
                                    for (int depthTry = 1; depthTry <= 3; depthTry++) {
                                        dynamic spotDepthData = Sistem.DerinlikVerisiOku(spotFullSym);
                                        if (spotDepthData != null && spotDepthData.Asks != null && spotDepthData.Asks.Count > 0) {
                                            spotAsk1Size = (int)spotDepthData.Asks[0].Size;
                                            spotAsk2Size = spotDepthData.Asks.Count > 1 ? (int)spotDepthData.Asks[1].Size : 0;
                                            spotAskPrice = (decimal)spotDepthData.Asks[0].Price;
                                            if (spotAsk1Size > 0 || spotAsk2Size > 0) break;
                                        }
                                        if (depthTry < 3) System.Threading.Thread.Sleep(100);
                                    }
                                    spotTotalDepth = spotAsk1Size + spotAsk2Size;
                                    
                                    if (spotTotalDepth < mult || spotAskPrice <= 0) {
                                        if (depthAttempt < 3) {
                                            Log("⏳ REZERV AÇILIŞ: " + sym + " Spot derinlik bekleniyor (deneme " + depthAttempt + "/3)");
                                            System.Threading.Thread.Sleep(300);
                                            continue;
                                        }
                                        Log("❌ REZERV AÇILIŞ: " + sym + " Spot derinlik/fiyat yok");
                                        break;
                                    }
                                    
                                    // 3. Gerçek işlem miktarını belirle
                                    var spotFromNear = nearTotalDepth * mult;
                                    var maxSpotFromDepth = Math.Min(spotTotalDepth, spotFromNear);
                                    
                                    if (maxSpotFromDepth < mult) {
                                        if (depthAttempt < 3) {
                                            Log("⏳ REZERV AÇILIŞ: " + sym + " derinlik düşük, bekleniyor (deneme " + depthAttempt + "/3)");
                                            System.Threading.Thread.Sleep(300);
                                            continue;
                                        }
                                        Log("❌ REZERV AÇILIŞ: " + sym + " derinlik çok düşük (Near:" + nearTotalDepth + " Spot:" + spotTotalDepth + ")");
                                        break;
                                    }
                                    
                                    // İstenen miktarla kıyasla
                                    actualSQty = Math.Min(snSQty, maxSpotFromDepth);
                                    actualNQty = (int)Math.Ceiling((decimal)actualSQty / mult);
                                    actualNQty = Math.Min(actualNQty, nearTotalDepth);
                                    actualSQty = actualNQty * mult;
                                    
                                    if (actualNQty < 1 || actualSQty < mult) {
                                        if (depthAttempt < 3) {
                                            System.Threading.Thread.Sleep(300);
                                            continue;
                                        }
                                        Log("❌ REZERV AÇILIŞ: " + sym + " miktar yetersiz (N:" + actualNQty + " S:" + actualSQty + ")");
                                        break;
                                    }
                                    
                                    reserveDepthOK = true;
                                    break;
                                }
                                
                                if (!reserveDepthOK) continue;
                                
                                // Miktar değiştiyse logla
                                if (actualNQty != qty || actualSQty != snSQty) {
                                    Log("📊 REZERV AÇILIŞ: " + sym + " miktar ayarlandı - Orijinal S:" + snSQty + " N:" + qty + " → Yeni S:" + actualSQty + " N:" + actualNQty);
                                }
                                
                                Log("📊 REZERV AÇILIŞ: " + sym + " S:" + actualSQty + " N:" + actualNQty + " (Derinlik N:" + nearTotalDepth + " S:" + spotTotalDepth + ")");
                                
                                // Near bacağını GİE ile aç
                                var giePriceRes = nearBidPrice;  // Yüzeysel veya derinlikten alınan fiyat
                                var gieResult = SendGIE(nearC, "SELL", actualNQty, giePriceRes);
                                if (!gieResult) {
                                    Log("❌ REZERV AÇILIŞ: " + sym + " Near GİE başarısız");
                                    continue;
                                }
                                
                                // Near doldu mu kontrol et
                                System.Threading.Thread.Sleep(500);
                                var nearFilledQty = CheckFilledQty(nearC, "SELL", actualNQty);
                                if (nearFilledQty < actualNQty) {
                                    Log("❌ REZERV AÇILIŞ: " + sym + " Near dolmadı (" + nearFilledQty + "/" + actualNQty + ")");
                                    // Near kısmen dolmuşsa geri al
                                    if (nearFilledQty > 0) {
                                        ExecGuar(nearC, "BUY", nearFilledQty);
                                    }
                                    continue;
                                }
                                
                                // Near doldu - Spot al (miktarı Near'a göre ayarla)
                                // === YENİ v17.5: Derinlik yoksa 3 deneme ===
                                var finalSQty = nearFilledQty * mult;
                                var spotResult = new System.Tuple<int, decimal>(0, 0m);
                                
                                for (int spotAttempt = 1; spotAttempt <= 3; spotAttempt++) {
                                    // Önce derinlik var mı kontrol et
                                    var spotCheckSym = SPOT_PREFIX + sym;
                                    var spotCheckDepth = Sistem.DerinlikVerisiOku(spotCheckSym);
                                    var hasDepth = spotCheckDepth != null && spotCheckDepth.Asks != null && spotCheckDepth.Asks.Count > 0;
                                    
                                    if (!hasDepth) {
                                        if (spotAttempt < 3) {
                                            Log("⚠️ REZERV AÇILIŞ: " + sym + " Spot derinlik yok, deneme " + spotAttempt + "/3...");
                                            System.Threading.Thread.Sleep(500);
                                            continue;  // Tekrar dene
                                        } else {
                                            Log("❌ REZERV AÇILIŞ: " + sym + " Spot derinlik 3 denemede bulunamadı");
                                            break;  // Vazgeç
                                        }
                                    }
                                    
                                    // Derinlik var - emir gönder (KIE olduğu için tek seferde)
                                    spotResult = ExecGuar(sym, "BUY", finalSQty);
                                    break;  // Emir gönderildi, döngüden çık (kısmi dolum olabilir)
                                }
                                
                                if (spotResult.Item1 < finalSQty * 0.5m) {  // En az yarısı dolmalı
                                    Log("❌ REZERV AÇILIŞ: " + sym + " Spot alınamadı (" + spotResult.Item1 + "/" + finalSQty + ") - Near geri alınıyor");
                                    ExecGuar(nearC, "BUY", nearFilledQty);
                                    continue;
                                }
                                
                                // Spot kısmi dolduysa, fazla Near'ı geri al
                                var actualSpotFilled = spotResult.Item1;
                                var neededNear = (int)Math.Ceiling((decimal)actualSpotFilled / mult);
                                var excessNear = nearFilledQty - neededNear;
                                
                                if (excessNear > 0) {
                                    Log("⚠️ REZERV AÇILIŞ: " + sym + " Spot kısmi doldu (" + actualSpotFilled + "/" + finalSQty + ") - Fazla Near geri alınıyor: " + excessNear);
                                    ExecGuar(nearC, "BUY", excessNear);
                                    nearFilledQty = neededNear;
                                }
                                
                                // Pozisyon açıldı - kaydet
                                // Near fiyatı yüzeysel veya derinlikten alındı
                                var nearPrice = nearBidPrice;
                                var spotPrice = spotResult.Item2;
                                var spread = spotPrice > 0 ? (nearPrice - spotPrice) / spotPrice : 0;
                                var actualOpenComm = CalcSpotCommission(spotPrice, actualSpotFilled) + CalcCommission(sym, nearPrice, nearFilledQty);
                                var expPnl = spread * spotPrice * actualSpotFilled - actualOpenComm * 2;
                                
                                snPos[sym] = new decimal[] { actualSpotFilled, nearFilledQty, spotPrice, nearPrice, spread, expPnl, 0, DateTime.Now.Ticks };
                                spotUsed += spotPrice * actualSpotFilled;
                                viopUsed += teminat.ContainsKey(sym) ? teminat[sym] * nearFilledQty : 0;
                                
                                Log("✅ REZERV AÇILDI: " + sym + " S:" + actualSpotFilled + "@" + spotPrice.ToString("F2") + " N:" + nearFilledQty + "@" + nearPrice.ToString("F2") + " Spread:" + (spread * 100).ToString("F3") + "%");
                                
                                // Şimdi rezerv kadar bütçe açmak için en kötü pozisyonları kapat
                                // Bu görevi pendingReserveClose listesine ekle
                                var reserveCloseNeeded = reserveNeededV;
                                var closedForReserve = new System.Collections.Generic.List<string>();
                                
                                while (reserveCloseNeeded > 0) {
                                    var worstResult = FindWorstSNPosition(sym, new System.Collections.Generic.HashSet<string>(closedForReserve));
                                    var worstSym = worstResult.Item1;
                                    
                                    if (worstSym == null) {
                                        Log("⚠️ REZERV KAPANIŞ: Kapatılacak pozisyon kalmadı, rezerv:" + reserveCloseNeeded.ToString("N0") + " TL açık");
                                        break;
                                    }
                                    
                                    var oldPos = snPos[worstSym];
                                    var oldSQty = (int)oldPos[0];
                                    var oldNQty = (int)oldPos[1];
                                    var oldViopValue = teminat.ContainsKey(worstSym) ? teminat[worstSym] * oldNQty : 0;
                                    
                                    // Threshold kontrolü
                                    var worstEntrySpread = worstResult.Item2;
                                    var closeSpotComm = CalcSpotCommission(oldPos[2], oldSQty);
                                    var closeNearComm = CalcCommission(worstSym, oldPos[3], oldNQty);
                                    var thisCloseComm = closeSpotComm + closeNearComm;
                                    var closeCommRate = (oldPos[2] * oldSQty) > 0 ? thisCloseComm / (oldPos[2] * oldSQty) : 0;
                                    var newSpreadNet = snSpPct - (newOpenComm / (spotAsk * snSQty)) - closeCommRate;
                                    var minRequiredSpread = worstEntrySpread * (1 + REPLACEMENT_THRESHOLD);
                                    
                                    if (newSpreadNet <= minRequiredSpread) {
                                        Log("⚠️ REZERV KAPANIŞ: " + worstSym + " threshold geçmedi, atlanıyor");
                                        closedForReserve.Add(worstSym);
                                        continue;
                                    }
                                    
                                    // Anlık P&L kontrolü: Pozisyon zararda ise yeni pozisyon bu zararı karşılamalı
                                    var worstNearC = GetContract(worstSym, 0);
                                    var worstSpotBidDepth = ReadDepth(SPOT_PREFIX + worstSym, "BID", 0, 1, 50);
                                    var worstNearAskDepth = ReadDepth(FUTURES_PREFIX + worstNearC, "ASK", 0, 1, 50);
                                    var worstSpotBid = worstSpotBidDepth.Item1 ? worstSpotBidDepth.Item4 : 0m;
                                    var worstNearAsk = worstNearAskDepth.Item1 ? worstNearAskDepth.Item4 : 0m;
                                    var worstMult = GetMultiplier(worstSym);
                                    var worstCurrentPnl = (worstSpotBid - oldPos[2]) * oldSQty + (oldPos[3] - worstNearAsk) * oldNQty * worstMult;
                                    worstCurrentPnl -= thisCloseComm;  // Kapatma komisyonu
                                    
                                    if (worstCurrentPnl < 0) {
                                        // Pozisyon zararda - yeni pozisyon bu zararı + threshold kadar karşılamalı
                                        var minRequiredPnl = Math.Abs(worstCurrentPnl) * (1 + REPLACEMENT_THRESHOLD);
                                        if (newExpectedPnl < minRequiredPnl) {
                                            Log("⏭️ REZERV: " + worstSym + " zararı çok yüksek: " + worstCurrentPnl.ToString("F0") + " TL, beklenen: " + newExpectedPnl.ToString("F0") + " < gerekli: " + minRequiredPnl.ToString("F0"));
                                            closedForReserve.Add(worstSym);
                                            continue;
                                        }
                                    }
                                    
                                    // Kapat
                                    Log("🔄 REZERV KAPANIŞ: " + worstSym + " kapatılıyor (rezerv için)");
                                    CloseSN(worstSym, GetContract(worstSym, 0), oldSQty, oldNQty, "RESERVE_REPLACEMENT");
                                    
                                    if (!snPos.ContainsKey(worstSym)) {
                                        closedForReserve.Add(worstSym);
                                        reserveCloseNeeded -= oldViopValue;
                                        Log("✅ REZERV KAPANIŞ: " + worstSym + " kapatıldı, kalan rezerv:" + Math.Max(0, reserveCloseNeeded).ToString("N0") + " TL");
                                    } else {
                                        Log("❌ REZERV KAPANIŞ: " + worstSym + " kapanış başarısız");
                                        closedForReserve.Add(worstSym);
                                    }
                                }
                                
                                UpdateBalances();
                                continue;  // Bu sembol için işlem tamamlandı
                            }
                            // ============ ÖNCE AÇ SONRA KAPAT MODU SONU ============
                            
                            // v17.2: Rezerv modu başarısız olduysa pas geç
                            // Eski "önce kapat sonra aç" modu kaldırıldı - spread kaçırma riski yüksek
                            // Rezervler yetmiyorsa zaten sistem düzgün çalışmıyor demektir
                            // Log("⏭️ " + sym + " rezerv yetersiz, replacement atlanıyor");
                            continue;
                    }
                }
            } else if (snPos.ContainsKey(sym) && (int)snPos[sym][6] < 2) {
                // Near vade son günü büyütme/replacement yapma
                if (daysN <= 0) continue;
                
                // Büyütme
                var snThresh = SNThreshold(daysN);
                var snSpPct = snSp / 100m;
                var entrySpread = snPos[sym][4];  // Mevcut pozisyonun giriş spread'i
                
                // Büyütme için: yeni spread >= giriş spread * (1 + threshold) VE yeni spread >= dinamik threshold
                var minSpreadForAdd = entrySpread * (1 + REPLACEMENT_THRESHOLD);
                if (snSpPct >= snThresh && snSpPct >= minSpreadForAdd) {
                    // Günlük BB kontrolü kaldırıldı - analiz sonucu işe yaramıyor
                    // Not: Devre kesici kontrolü döngü başında yapıldı
                    
                    var snSQty = qty * 100;
                    var reqS = spotAsk * snSQty;
                    var reqV = tem * qty;
                    if (reqS <= spotBalance && reqV <= viopBalance) {
                        Log("🎯 SN Büyütme: " + sym + " BB:" + sBBPos.ToString("F0") + " Sp:" + snSp.ToString("F3") + "% (giriş:" + (entrySpread * 100).ToString("F3") + "%)");
                        if (AddToSN(sym, nearC, snSQty, qty, snThresh)) {
                            UpdateBalances();
                        }
                    } else {
                            // Bütçe yetersiz - büyütme için replacement değerlendir
                            var eksikS = reqS - spotBalance;
                            var eksikV = reqV - viopBalance;
                            
                            // Near derinlik kontrolü (büyütme) - önce yüzeysel veri, yetmezse derinlik
                            var nearSym = FUTURES_PREFIX + nearC;
                            var nearDepthQty = (int)Sistem.SatisLot(nearSym);  // Near satıyoruz, Bid tarafı
                            if (nearDepthQty < qty) {
                                // 1. kademe yetmiyor, 2. kademeye de bak
                                System.Threading.Thread.Sleep(200);
                                dynamic nearDepthCheck = Sistem.DerinlikVerisiOku(nearSym);
                                if (nearDepthCheck != null && nearDepthCheck.Bids != null && nearDepthCheck.Bids.Count > 1) {
                                    nearDepthQty += (int)nearDepthCheck.Bids[1].Size;
                                }
                                if (nearDepthQty < qty) {
                                    // Near derinlik yetersiz - sessizce atla
                                    continue;
                                }
                            }
                            
                            // Büyütmenin beklenen karı (açılış komisyonu dahil)
                            var addOpenComm = CalcSpotCommission(spotAsk, snSQty) + CalcCommission(sym, nearBid, qty);
                            var addExpectedPnl = snSpPct * spotAsk * snSQty - addOpenComm * 2;  // x2: açılış + kapanış
                            
                            // Bütçe sınırda kontrolü - büyütme için replacement yapılacaksa da threshold geçmeli
                            var tightThreshForAdd = snThresh + SN_TOTAL_COST;
                            if (snSpPct < tightThreshForAdd) {
                                // Spread yetersiz - sessizce atla
                                continue;
                            }
                            
                            // ============ BÜYÜTME İÇİN ÖNCE AÇ SONRA KAPAT MODU (v17) ============
                            var useReserveModeAdd = false;
                            var reserveNeededAddV = 0m;
                            var reserveNeededAddS = 0m;
                            
                            // VIOP eksik mi ve rezerv yeterli mi?
                            var viopOkAdd = eksikV <= 0 || (eksikV > 0 && eksikV <= VIOP_RESERVE);
                            // SPOT eksik mi ve rezerv (kredi) yeterli mi?
                            var spotOkAdd = eksikS <= 0 || (eksikS > 0 && eksikS <= SPOT_RESERVE);
                            
                            if (viopOkAdd && spotOkAdd && (eksikV > 0 || eksikS > 0)) {
                                // === ÖNEMLİ: Kapatılabilir pozisyon var mı kontrol et ===
                                var hasCloseablePositionAdd = false;
                                var tempExcludeAdd = new System.Collections.Generic.HashSet<string>();
                                tempExcludeAdd.Add(sym);  // Büyütülen sembolü hariç tut
                                
                                var checkResultAdd = FindWorstSNPosition(sym, tempExcludeAdd);
                                if (checkResultAdd.Item1 != null) {
                                    var checkSymAdd = checkResultAdd.Item1;
                                    var checkEntrySpreadAdd = checkResultAdd.Item2;
                                    var checkPosAdd = snPos[checkSymAdd];
                                    var checkSQtyAdd = (int)checkPosAdd[0];
                                    var checkNQtyAdd = (int)checkPosAdd[1];
                                    
                                    // Threshold hesapla
                                    var checkCloseSpotCommAdd = CalcSpotCommission(checkPosAdd[2], checkSQtyAdd);
                                    var checkCloseNearCommAdd = CalcCommission(checkSymAdd, checkPosAdd[3], checkNQtyAdd);
                                    var checkCloseCommAdd = checkCloseSpotCommAdd + checkCloseNearCommAdd;
                                    var checkCloseCommRateAdd = (checkPosAdd[2] * checkSQtyAdd) > 0 ? checkCloseCommAdd / (checkPosAdd[2] * checkSQtyAdd) : 0;
                                    var checkNewSpreadNetAdd = snSpPct - (addOpenComm / (spotAsk * snSQty)) - checkCloseCommRateAdd;
                                    var checkMinRequiredAdd = checkEntrySpreadAdd * (1 + REPLACEMENT_THRESHOLD);
                                    
                                    if (checkNewSpreadNetAdd > checkMinRequiredAdd) {
                                        hasCloseablePositionAdd = true;
                                    }
                                }
                                
                                if (!hasCloseablePositionAdd) {
                                    // Kapatılabilir pozisyon yok - büyütme rezerv moduna girme!
                                    continue;
                                }
                                
                                // En az biri eksik ve her ikisi de rezerv limitleri içinde
                                useReserveModeAdd = true;
                                reserveNeededAddV = eksikV > 0 ? eksikV : 0;
                                reserveNeededAddS = eksikS > 0 ? eksikS : 0;
                                var reserveInfoAdd = "";
                                if (reserveNeededAddV > 0) reserveInfoAdd += "VIOP:" + reserveNeededAddV.ToString("N0");
                                if (reserveNeededAddS > 0) reserveInfoAdd += (reserveInfoAdd.Length > 0 ? " + " : "") + "SPOT(kredi):" + reserveNeededAddS.ToString("N0");
                                Log("🔄 BÜYÜTME REZERV MODU: " + sym + " için rezerv kullanılacak (" + reserveInfoAdd + " TL)");
                            }
                            
                            if (useReserveModeAdd) {
                                // ÖNCE BÜYÜTME YAP (rezerv kullanarak)
                                
                                // === Near VE Spot derinlik kontrolü + miktar ayarlama (3 deneme) ===
                                var nearFullSymAdd = FUTURES_PREFIX + nearC;
                                var spotFullSymAdd = SPOT_PREFIX + sym;
                                var multAdd = GetMultiplier(sym);
                                
                                var reserveDepthOKAdd = false;
                                var nearTotalDepthAdd = 0;
                                var nearBid1SizeAdd = 0;
                                var nearBid2SizeAdd = 0;
                                var nearBidPriceAdd = 0m;
                                var spotTotalDepthAdd = 0;
                                var spotAsk1SizeAdd = 0;
                                var spotAsk2SizeAdd = 0;
                                var spotAskPriceAdd = 0m;
                                var actualSQtyAdd = 0;
                                var actualNQtyAdd = 0;
                                
                                for (int depthAttemptAdd = 1; depthAttemptAdd <= 3; depthAttemptAdd++) {
                                    // 1. Near derinliği kontrol et (3 deneme ile)
                                    nearBid1SizeAdd = 0;
                                    nearBid2SizeAdd = 0;
                                    nearBidPriceAdd = 0m;
                                    
                                    for (int depthTry = 1; depthTry <= 3; depthTry++) {
                                        dynamic nearDepthDataAdd = Sistem.DerinlikVerisiOku(nearFullSymAdd);
                                        if (nearDepthDataAdd != null && nearDepthDataAdd.Bids != null && nearDepthDataAdd.Bids.Count > 0) {
                                            nearBid1SizeAdd = (int)nearDepthDataAdd.Bids[0].Size;
                                            nearBid2SizeAdd = nearDepthDataAdd.Bids.Count > 1 ? (int)nearDepthDataAdd.Bids[1].Size : 0;
                                            nearBidPriceAdd = (decimal)nearDepthDataAdd.Bids[0].Price;
                                            if (nearBid1SizeAdd > 0 || nearBid2SizeAdd > 0) break;
                                        }
                                        if (depthTry < 3) System.Threading.Thread.Sleep(100);
                                    }
                                    nearTotalDepthAdd = nearBid1SizeAdd + nearBid2SizeAdd;
                                    
                                    if (nearTotalDepthAdd < 1 || nearBidPriceAdd <= 0) {
                                        if (depthAttemptAdd < 3) {
                                            Log("⏳ REZERV BÜYÜTME: " + sym + " Near derinlik bekleniyor (deneme " + depthAttemptAdd + "/3)");
                                            System.Threading.Thread.Sleep(300);
                                            continue;
                                        }
                                        Log("❌ REZERV BÜYÜTME: " + sym + " Near derinlik/fiyat yok");
                                        break;
                                    }
                                    
                                    // 2. Spot derinliği kontrol et (3 deneme ile)
                                    var snSQtyNeededAdd = qty * multAdd;
                                    spotAsk1SizeAdd = 0;
                                    spotAsk2SizeAdd = 0;
                                    spotAskPriceAdd = 0m;
                                    
                                    for (int depthTry = 1; depthTry <= 3; depthTry++) {
                                        dynamic spotDepthDataAdd = Sistem.DerinlikVerisiOku(spotFullSymAdd);
                                        if (spotDepthDataAdd != null && spotDepthDataAdd.Asks != null && spotDepthDataAdd.Asks.Count > 0) {
                                            spotAsk1SizeAdd = (int)spotDepthDataAdd.Asks[0].Size;
                                            spotAsk2SizeAdd = spotDepthDataAdd.Asks.Count > 1 ? (int)spotDepthDataAdd.Asks[1].Size : 0;
                                            spotAskPriceAdd = (decimal)spotDepthDataAdd.Asks[0].Price;
                                            if (spotAsk1SizeAdd > 0 || spotAsk2SizeAdd > 0) break;
                                        }
                                        if (depthTry < 3) System.Threading.Thread.Sleep(100);
                                    }
                                    spotTotalDepthAdd = spotAsk1SizeAdd + spotAsk2SizeAdd;
                                    
                                    if (spotTotalDepthAdd < multAdd || spotAskPriceAdd <= 0) {
                                        if (depthAttemptAdd < 3) {
                                            Log("⏳ REZERV BÜYÜTME: " + sym + " Spot derinlik bekleniyor (deneme " + depthAttemptAdd + "/3)");
                                            System.Threading.Thread.Sleep(300);
                                            continue;
                                        }
                                        Log("❌ REZERV BÜYÜTME: " + sym + " Spot derinlik/fiyat yok");
                                        break;
                                    }
                                    
                                    // 3. Gerçek işlem miktarını belirle
                                    var spotFromNearAdd = nearTotalDepthAdd * multAdd;
                                    var maxSpotFromDepthAdd = Math.Min(spotTotalDepthAdd, spotFromNearAdd);
                                    
                                    if (maxSpotFromDepthAdd < multAdd) {
                                        if (depthAttemptAdd < 3) {
                                            Log("⏳ REZERV BÜYÜTME: " + sym + " derinlik düşük, bekleniyor (deneme " + depthAttemptAdd + "/3)");
                                            System.Threading.Thread.Sleep(300);
                                            continue;
                                        }
                                        Log("❌ REZERV BÜYÜTME: " + sym + " derinlik çok düşük (Near:" + nearTotalDepthAdd + " Spot:" + spotTotalDepthAdd + ")");
                                        break;
                                    }
                                    
                                    // İstenen miktarla kıyasla
                                    actualSQtyAdd = Math.Min(snSQty, maxSpotFromDepthAdd);
                                    actualNQtyAdd = (int)Math.Ceiling((decimal)actualSQtyAdd / multAdd);
                                    actualNQtyAdd = Math.Min(actualNQtyAdd, nearTotalDepthAdd);
                                    actualSQtyAdd = actualNQtyAdd * multAdd;
                                    
                                    if (actualNQtyAdd < 1 || actualSQtyAdd < multAdd) {
                                        if (depthAttemptAdd < 3) {
                                            System.Threading.Thread.Sleep(300);
                                            continue;
                                        }
                                        Log("❌ REZERV BÜYÜTME: " + sym + " miktar yetersiz (N:" + actualNQtyAdd + " S:" + actualSQtyAdd + ")");
                                        break;
                                    }
                                    
                                    reserveDepthOKAdd = true;
                                    break;
                                }
                                
                                if (!reserveDepthOKAdd) continue;
                                
                                // Miktar değiştiyse logla
                                if (actualNQtyAdd != qty || actualSQtyAdd != snSQty) {
                                    Log("📊 REZERV BÜYÜTME: " + sym + " miktar ayarlandı - Orijinal S:" + snSQty + " N:" + qty + " → Yeni S:" + actualSQtyAdd + " N:" + actualNQtyAdd);
                                }
                                
                                Log("📊 REZERV BÜYÜTME: " + sym + " S:" + actualSQtyAdd + " N:" + actualNQtyAdd + " (Derinlik N:" + nearTotalDepthAdd + " S:" + spotTotalDepthAdd + ")");
                                
                                // Miktar değiştiyse logla
                                if (actualNQtyAdd != qty || actualSQtyAdd != snSQty) {
                                    Log("📊 REZERV BÜYÜTME: " + sym + " miktar ayarlandı - Orijinal S:" + snSQty + " N:" + qty + " → Yeni S:" + actualSQtyAdd + " N:" + actualNQtyAdd);
                                }
                                
                                Log("📊 REZERV BÜYÜTME: " + sym + " S:" + actualSQtyAdd + " N:" + actualNQtyAdd + " (Derinlik N:" + nearTotalDepthAdd + " S:" + spotTotalDepthAdd + ")");
                                
                                // Near bacağını GİE ile aç
                                var giePriceAdd = nearBidPriceAdd;  // Yüzeysel veya derinlikten alınan fiyat
                                var gieResult = SendGIE(nearC, "SELL", actualNQtyAdd, giePriceAdd);
                                if (!gieResult) {
                                    Log("❌ REZERV BÜYÜTME: " + sym + " Near GİE başarısız");
                                    continue;
                                }
                                
                                // Near doldu mu kontrol et
                                System.Threading.Thread.Sleep(500);
                                var nearFilledQtyAdd = CheckFilledQty(nearC, "SELL", actualNQtyAdd);
                                if (nearFilledQtyAdd < actualNQtyAdd) {
                                    Log("❌ REZERV BÜYÜTME: " + sym + " Near dolmadı (" + nearFilledQtyAdd + "/" + actualNQtyAdd + ")");
                                    // Near kısmen dolmuşsa geri al
                                    if (nearFilledQtyAdd > 0) {
                                        ExecGuar(nearC, "BUY", nearFilledQtyAdd);
                                    }
                                    continue;
                                }
                                
                                // Near doldu - Spot al (miktarı Near'a göre ayarla)
                                // === YENİ v17.5: Derinlik yoksa 3 deneme ===
                                var finalSQtyAdd = nearFilledQtyAdd * multAdd;
                                var spotResultAdd = new System.Tuple<int, decimal>(0, 0m);
                                
                                for (int spotAttemptAdd = 1; spotAttemptAdd <= 3; spotAttemptAdd++) {
                                    // Önce derinlik var mı kontrol et
                                    var spotCheckSymAdd = SPOT_PREFIX + sym;
                                    var spotCheckDepthAdd = Sistem.DerinlikVerisiOku(spotCheckSymAdd);
                                    var hasDepthAdd = spotCheckDepthAdd != null && spotCheckDepthAdd.Asks != null && spotCheckDepthAdd.Asks.Count > 0;
                                    
                                    if (!hasDepthAdd) {
                                        if (spotAttemptAdd < 3) {
                                            Log("⚠️ REZERV BÜYÜTME: " + sym + " Spot derinlik yok, deneme " + spotAttemptAdd + "/3...");
                                            System.Threading.Thread.Sleep(500);
                                            continue;  // Tekrar dene
                                        } else {
                                            Log("❌ REZERV BÜYÜTME: " + sym + " Spot derinlik 3 denemede bulunamadı");
                                            break;  // Vazgeç
                                        }
                                    }
                                    
                                    // Derinlik var - emir gönder (KIE olduğu için tek seferde)
                                    spotResultAdd = ExecGuar(sym, "BUY", finalSQtyAdd);
                                    break;  // Emir gönderildi, döngüden çık (kısmi dolum olabilir)
                                }
                                
                                if (spotResultAdd.Item1 < finalSQtyAdd * 0.5m) {  // En az yarısı dolmalı
                                    Log("❌ REZERV BÜYÜTME: " + sym + " Spot alınamadı (" + spotResultAdd.Item1 + "/" + finalSQtyAdd + ") - Near geri alınıyor");
                                    ExecGuar(nearC, "BUY", nearFilledQtyAdd);
                                    continue;
                                }
                                
                                // Spot kısmi dolduysa, fazla Near'ı geri al
                                var actualSpotFilledAdd = spotResultAdd.Item1;
                                var neededNearAdd = (int)Math.Ceiling((decimal)actualSpotFilledAdd / multAdd);
                                var excessNearAdd = nearFilledQtyAdd - neededNearAdd;
                                
                                if (excessNearAdd > 0) {
                                    Log("⚠️ REZERV BÜYÜTME: " + sym + " Spot kısmi doldu (" + actualSpotFilledAdd + "/" + finalSQtyAdd + ") - Fazla Near geri alınıyor: " + excessNearAdd);
                                    ExecGuar(nearC, "BUY", excessNearAdd);
                                    nearFilledQtyAdd = neededNearAdd;
                                }
                                
                                // Büyütme yapıldı - pozisyonu güncelle
                                var nearPriceAdd = nearBidPriceAdd;  // Yüzeysel veya derinlikten alınan fiyat
                                var spotPriceAdd = spotResultAdd.Item2;
                                var p = snPos[sym];
                                var oldSQty = (int)p[0];
                                var oldNQty = (int)p[1];
                                var oldSpotEntry = p[2];
                                var oldNearEntry = p[3];
                                
                                // Ortalama fiyat hesapla
                                var newSQty = oldSQty + actualSpotFilledAdd;
                                var newNQty = oldNQty + nearFilledQtyAdd;
                                var avgSpotEntry = (oldSpotEntry * oldSQty + spotPriceAdd * actualSpotFilledAdd) / newSQty;
                                var avgNearEntry = (oldNearEntry * oldNQty + nearPriceAdd * nearFilledQtyAdd) / newNQty;
                                var newSpread = avgSpotEntry > 0 ? (avgNearEntry - avgSpotEntry) / avgSpotEntry : 0;
                                
                                // Yeni beklenen kar
                                var totalSpotComm = CalcSpotCommission(avgSpotEntry, newSQty);
                                var totalNearComm = CalcCommission(sym, avgNearEntry, newNQty);
                                var newExpPnl = newSpread * avgSpotEntry * newSQty - (totalSpotComm + totalNearComm) * 2;
                                
                                snPos[sym] = new decimal[] { newSQty, newNQty, avgSpotEntry, avgNearEntry, newSpread, newExpPnl, 0, p[7] };
                                spotUsed += spotPriceAdd * actualSpotFilledAdd;
                                viopUsed += teminat.ContainsKey(sym) ? teminat[sym] * nearFilledQtyAdd : 0;
                                
                                Log("✅ REZERV BÜYÜTME: " + sym + " S:" + oldSQty + "→" + newSQty + " N:" + oldNQty + "→" + newNQty + " Spread:" + (newSpread * 100).ToString("F3") + "%");
                                
                                // Şimdi rezerv kadar bütçe açmak için en kötü pozisyonları kapat
                                var reserveCloseNeededAdd = reserveNeededAddV;
                                var closedForReserveAdd = new System.Collections.Generic.List<string>();
                                
                                while (reserveCloseNeededAdd > 0) {
                                    var worstResult = FindWorstSNPosition(sym, new System.Collections.Generic.HashSet<string>(closedForReserveAdd));
                                    var worstSym = worstResult.Item1;
                                    
                                    if (worstSym == null) {
                                        Log("⚠️ BÜYÜTME REZERV KAPANIŞ: Kapatılacak pozisyon kalmadı, rezerv:" + reserveCloseNeededAdd.ToString("N0") + " TL açık");
                                        break;
                                    }
                                    
                                    var oldPos = snPos[worstSym];
                                    var oldPosSQty = (int)oldPos[0];
                                    var oldPosNQty = (int)oldPos[1];
                                    var oldViopValue = teminat.ContainsKey(worstSym) ? teminat[worstSym] * oldPosNQty : 0;
                                    
                                    // Threshold kontrolü
                                    var worstEntrySpread = worstResult.Item2;
                                    var closeSpotComm = CalcSpotCommission(oldPos[2], oldPosSQty);
                                    var closeNearComm = CalcCommission(worstSym, oldPos[3], oldPosNQty);
                                    var thisCloseCommAdd = closeSpotComm + closeNearComm;
                                    var closeCommRate = (oldPos[2] * oldPosSQty) > 0 ? thisCloseCommAdd / (oldPos[2] * oldPosSQty) : 0;
                                    var addSpreadNet = snSpPct - (addOpenComm / (spotAsk * snSQty)) - closeCommRate;
                                    var minRequiredSpread = worstEntrySpread * (1 + REPLACEMENT_THRESHOLD);
                                    
                                    if (addSpreadNet <= minRequiredSpread) {
                                        Log("⚠️ BÜYÜTME REZERV KAPANIŞ: " + worstSym + " threshold geçmedi, atlanıyor");
                                        closedForReserveAdd.Add(worstSym);
                                        continue;
                                    }
                                    
                                    // Anlık P&L kontrolü: Pozisyon zararda ise büyütmenin beklenen karı bu zararı karşılamalı
                                    var worstNearCAdd = GetContract(worstSym, 0);
                                    var worstSpotBidDepthAdd = ReadDepth(SPOT_PREFIX + worstSym, "BID", 0, 1, 50);
                                    var worstNearAskDepthAdd = ReadDepth(FUTURES_PREFIX + worstNearCAdd, "ASK", 0, 1, 50);
                                    var worstSpotBidAdd = worstSpotBidDepthAdd.Item1 ? worstSpotBidDepthAdd.Item4 : 0m;
                                    var worstNearAskAdd = worstNearAskDepthAdd.Item1 ? worstNearAskDepthAdd.Item4 : 0m;
                                    var worstMultAdd = GetMultiplier(worstSym);
                                    var worstCurrentPnlAdd = (worstSpotBidAdd - oldPos[2]) * oldPosSQty + (oldPos[3] - worstNearAskAdd) * oldPosNQty * worstMultAdd;
                                    worstCurrentPnlAdd -= thisCloseCommAdd;  // Kapatma komisyonu
                                    
                                    if (worstCurrentPnlAdd < 0) {
                                        // Pozisyon zararda - büyütme bu zararı + threshold kadar karşılamalı
                                        var minRequiredPnlAdd = Math.Abs(worstCurrentPnlAdd) * (1 + REPLACEMENT_THRESHOLD);
                                        if (addExpectedPnl < minRequiredPnlAdd) {
                                            Log("⏭️ BÜYÜTME REZERV: " + worstSym + " zararı çok yüksek: " + worstCurrentPnlAdd.ToString("F0") + " TL, beklenen: " + addExpectedPnl.ToString("F0") + " < gerekli: " + minRequiredPnlAdd.ToString("F0"));
                                            closedForReserveAdd.Add(worstSym);
                                            continue;
                                        }
                                    }
                                    
                                    // Kapat
                                    Log("🔄 BÜYÜTME REZERV KAPANIŞ: " + worstSym + " kapatılıyor (rezerv için)");
                                    CloseSN(worstSym, GetContract(worstSym, 0), oldPosSQty, oldPosNQty, "RESERVE_ADD");
                                    
                                    if (!snPos.ContainsKey(worstSym)) {
                                        closedForReserveAdd.Add(worstSym);
                                        reserveCloseNeededAdd -= oldViopValue;
                                        Log("✅ BÜYÜTME REZERV KAPANIŞ: " + worstSym + " kapatıldı, kalan rezerv:" + Math.Max(0, reserveCloseNeededAdd).ToString("N0") + " TL");
                                    } else {
                                        Log("❌ BÜYÜTME REZERV KAPANIŞ: " + worstSym + " kapanış başarısız");
                                        closedForReserveAdd.Add(worstSym);
                                    }
                                }
                                
                                UpdateBalances();
                                continue;  // Bu sembol için işlem tamamlandı
                            }
                            // ============ BÜYÜTME REZERV MODU SONU ============
                            
                            // v17.2: Rezerv modu başarısız olduysa pas geç
                            // Eski "önce kapat sonra aç" modu kaldırıldı - spread kaçırma riski yüksek
                            // Rezervler yetmiyorsa zaten sistem düzgün çalışmıyor demektir
                            // Log("⏭️ " + sym + " büyütme için rezerv yetersiz, atlanıyor");
                            continue;
                    }
                }
            }
        } catch { }
    }
    
    // ====================================
    // NEAR-FAR (NF) STRATEJİSİ DÖNGÜSÜ
    // ====================================
    if (NF_ENABLED && isMarketOpen && !isPaused && marginStatus < 2 && apiDataOk) {
        
        // NF saat kontrolü
        var nfNow = DateTime.Now;
        var nfTimeOk = (nfNow.Hour > NF_START_HOUR || (nfNow.Hour == NF_START_HOUR && nfNow.Minute >= NF_START_MIN)) &&
                       (nfNow.Hour < NF_END_HOUR || (nfNow.Hour == NF_END_HOUR && nfNow.Minute <= NF_END_MIN));
        
        // NF bütçe kontrolü
        var nfAvailableBudget = NF_BUDGET - nfViopUsed;
        
        foreach (var sym in symbols) {
            try {
                if (IsBlocked(sym)) continue;
                
                // SPOT DEVRE KESİCİ kontrolü
                var nfSpotCircuit = IsSpotCircuitBreaker(sym);
                
                // Çakışma kontrolü: Spot-Near'da bu sembol varsa NF işlem yapma
                if (snPos.ContainsKey(sym)) continue;
                
                var nearC = GetContract(sym, 0);
                var farC = GetContract(sym, 1);
                
                // Mevcut NF pozisyonu varsa, kayıtlı kontrat kodlarını kullan
                if (nfPos.ContainsKey(sym) && nfContracts.ContainsKey(sym)) {
                    nearC = nfContracts[sym][0];
                    farC = nfContracts[sym][1];
                }
                
                if (string.IsNullOrEmpty(nearC) || string.IsNullOrEmpty(farC)) continue;
                
                var nearS = FUTURES_PREFIX + nearC;
                var farS = FUTURES_PREFIX + farC;
                
                var daysN = GetDays(nearC);
                var daysF = GetDays(farC);
                
                // Near vadesi dolmak üzere ise NF açma
                if (daysN <= 1) continue;
                
                // Derinlik oku
                var nearBidDepth = ReadDepth(nearS, "BID", 0, 1, 50);
                var nearAskDepth = ReadDepth(nearS, "ASK", 0, 1, 50);
                var farBidDepth = ReadDepth(farS, "BID", 0, 1, 50);
                var farAskDepth = ReadDepth(farS, "ASK", 0, 1, 50);
                
                var nearBid = nearBidDepth.Item1 ? nearBidDepth.Item4 : 0m;
                var nearAsk = nearAskDepth.Item1 ? nearAskDepth.Item4 : 0m;
                var farBid = farBidDepth.Item1 ? farBidDepth.Item4 : 0m;
                var farAsk = farAskDepth.Item1 ? farAskDepth.Item4 : 0m;
                
                if (nearAsk <= 0 || farBid <= 0) continue;
                
                // NF spread BB pozisyonu (SN BB'yi kullanıyoruz)
                var nfBBPos = snBBPos.ContainsKey(sym) ? snBBPos[sym] : 50m;
                
                // === NF KAPANIŞ KONTROLÜ ===
                // Devre kesicide bile kar alma yapılabilir (spread daralabilir)
                if (nfPos.ContainsKey(sym)) {
                    var closeReason = CheckNFClose(sym, nearC, farC, nearBid, farAsk, daysN);
                    if (closeReason != null) {
                        var nfP = nfPos[sym];
                        CloseNF(sym, nearC, farC, (int)nfP[0], (int)nfP[1], closeReason);
                        UpdateBalances();
                    }
                    continue;  // Pozisyon varsa yeni açma
                }
                
                // === NF AÇILIŞ KONTROLÜ ===
                // Endeks veya spot devre kesici aktifse yeni pozisyon açma
                if (indexCircuitBreaker || nfSpotCircuit) continue;
                if (!nfTimeOk) continue;  // Saat uygun değil
                if (nfPos.Count >= NF_MAX_POSITIONS) continue;  // Max pozisyon
                
                // AÇILIŞ VOLATİLİTESİ KORUMASI: 10:05'e kadar yeni giriş yapma
                if (!IsAfterOpeningVolatility()) continue;
                
                // TEMETTÜ GÜNÜ KORUMASI: BB verisi henüz düzeltilmemiş olabilir
                if (IsDividendDay(sym)) {
                    Log("⚠️ NF: " + sym + " temettü günü - giriş atlandı (BB verisi güvenilmez)");
                    continue;
                }
                
                // SERMAYE ARTIRIMI KORUMASI: Bugün veya 7 gün içinde sermaye artırımı varsa atla
                if (IsSermayeArtirimiBlocked(sym)) {
                    Log("⛔ NF: " + sym + " sermaye artırımı - giriş atlandı");
                    continue;
                }
                
                // BB >= 99 kontrolü
                if (nfBBPos < NF_ENTRY_BB) continue;
                
                // Bütçe kontrolü
                var tem = teminat.ContainsKey(sym) ? teminat[sym] : 5000m;
                var reqNF = tem * 2;  // Near + Far teminat
                if (reqNF > nfAvailableBudget) continue;
                
                // NF spread hesapla (açılış için: Near AL @ nearAsk, Far SAT @ farBid)
                var nfSpread = CalcNFSpread(nearC, farC, nearAsk, farBid);
                
                // Spread pozitif olmalı (Far > Near)
                if (nfSpread <= 0) continue;
                
                // Derinlik kontrolü
                var nearAskQty = nearAskDepth.Item2;
                var farBidQty = farBidDepth.Item2;
                if (nearAskQty < 1 || farBidQty < 1) continue;
                
                var qty = 1;  // NF için 1 lot
                
                Log("🔷 NF Fırsat: " + sym + " BB:" + nfBBPos.ToString("F0") + " Spread:" + (nfSpread * 100).ToString("F3") + "%");
                
                if (OpenNF(sym, nearC, farC, qty)) {
                    nfAvailableBudget -= reqNF;
                    UpdateBalances();
                }
            } catch { }
        }
    }
    
    // ====================================
    // PAIR TRADING STRATEJİSİ DÖNGÜSÜ
    // ====================================
    if (PAIR_ENABLED && isMarketOpen && !isPaused && marginStatus < 2 && apiDataOk) {
        try {
            // Önce bekleyen emirleri kontrol et
            CheckPairPending();
            // Sonra yeni sinyalleri kontrol et
            CheckPairSignals();
        } catch (Exception ex) {
            Log("❌ PAIR hata: " + ex.Message);
        }
    }
    
    // Stats kaydet
    try {
        var sb = new System.Text.StringBuilder();
        var totalComm = dailySpotCommission + totalTransferredComm + dailyViopCommission;
        
        // Dönemsel istatistikler
        var weekStats = CalcPeriodStats(7);
        var monthStats = CalcPeriodStats(30);
        var allStats = CalcAllTimeStats();
        
        sb.Append("{\"ts\":\"" + DateTime.Now.ToString("HH:mm:ss") + "\",");
        sb.Append("\"test\":" + (IS_TEST ? "true" : "false") + ",");
        sb.Append("\"running\":" + (isRunning ? "true" : "false") + ",");
        sb.Append("\"market\":" + (isMarketOpen ? "true" : "false") + ",");
        sb.Append("\"paused\":" + (isPaused ? "true" : "false") + ",");
        sb.Append("\"data\":" + (dataConnected ? "true" : "false") + ",");
        sb.Append("\"broker\":" + (brokerConnected ? "true" : "false") + ",");
        sb.Append("\"viop_bal\":" + viopBalance.ToString("F0", ic) + ",\"spot_bal\":" + spotBudgetTotal.ToString("F0", ic) + ",");
        sb.Append("\"viop_used\":" + viopUsed.ToString(ic) + ",\"spot_used\":" + spotUsed.ToString(ic) + ",");
        sb.Append("\"daily_pnl\":" + dailyRealizedPnl.ToString("F0", ic) + ",\"trades\":" + dailyTrades + ",");
        sb.Append("\"total_comm\":" + totalComm.ToString("F2", ic) + ",");
        sb.Append("\"risk_free\":" + RISK_FREE.ToString("F4", ic) + ",");
        
        sb.Append("\"week\":{\"pnl\":" + weekStats[0].ToString("F0", ic) + 
            ",\"comm\":" + (weekStats[1] + weekStats[2]).ToString("F0", ic) + 
            ",\"trades\":" + ((int)weekStats[3]).ToString() + 
            ",\"days\":" + ((int)weekStats[4]).ToString() + "},");
        sb.Append("\"month\":{\"pnl\":" + monthStats[0].ToString("F0", ic) + 
            ",\"comm\":" + (monthStats[1] + monthStats[2]).ToString("F0", ic) + 
            ",\"trades\":" + ((int)monthStats[3]).ToString() + 
            ",\"days\":" + ((int)monthStats[4]).ToString() + "},");
        sb.Append("\"all\":{\"pnl\":" + allStats[0].ToString("F0", ic) + 
            ",\"comm\":" + (allStats[1] + allStats[2]).ToString("F0", ic) + 
            ",\"trades\":" + ((int)allStats[3]).ToString() + 
            ",\"days\":" + ((int)allStats[4]).ToString() + "},");
        
        sb.Append("\"positions\":{" + snStats.ToString() + "},");
        
        // NF pozisyonları
        sb.Append("\"nf_positions\":{");
        var nfFirst = true;
        decimal totalNfPnl = 0;
        foreach (var kv in nfPos) {
            if (!nfFirst) sb.Append(",");
            nfFirst = false;
            var nfSym = kv.Key;
            var nfP = kv.Value;
            var nearC = nfContracts.ContainsKey(nfSym) ? nfContracts[nfSym][0] : GetContract(nfSym, 0);
            var farC = nfContracts.ContainsKey(nfSym) ? nfContracts[nfSym][1] : GetContract(nfSym, 1);
            var nearS = FUTURES_PREFIX + nearC;
            var farS = FUTURES_PREFIX + farC;
            
            // P&L hesapla
            var nearBidD = ReadDepth(nearS, "BID", 0, 1, 50);
            var farAskD = ReadDepth(farS, "ASK", 0, 1, 50);
            var nearBidP = nearBidD.Item1 ? nearBidD.Item4 : nfP[2];
            var farAskP = farAskD.Item1 ? farAskD.Item4 : nfP[3];
            var nfMult = GetMultiplier(nfSym);
            var nfPnl = (nearBidP - nfP[2]) * nfP[0] * nfMult + (nfP[3] - farAskP) * nfP[1] * nfMult;
            totalNfPnl += nfPnl;
            
            sb.Append("\"" + nfSym + "\":{");
            sb.Append("\"nq\":" + ((int)nfP[0]).ToString() + ",\"fq\":" + ((int)nfP[1]).ToString() + ",");
            sb.Append("\"pnl\":" + nfPnl.ToString("F0", ic) + ",\"exp\":" + nfP[5].ToString("F0", ic) + ",");
            sb.Append("\"d\":" + GetDays(nearC).ToString() + "}");
        }
        sb.Append("},");
        sb.Append("\"nf_count\":" + nfPos.Count + ",");
        
        // Bekleyen emirler
        sb.Append("\"pending\":{");
        var pendFirst = true;
        foreach (var pk in pendingOrders) {
            if (!pendFirst) sb.Append(",");
            pendFirst = false;
            var pd = pk.Value;
            var waitMin = (DateTime.Now - (DateTime)pd[3]).TotalMinutes;
            sb.Append("\"" + pk.Key + "\":{");
            sb.Append("\"side\":\"" + pd[0] + "\",");
            sb.Append("\"qty\":" + ((int)pd[1]).ToString() + ",");
            sb.Append("\"price\":" + ((decimal)pd[2]).ToString("F2", ic) + ",");
            sb.Append("\"wait\":" + waitMin.ToString("F0", ic) + ",");
            sb.Append("\"processed\":" + (pd.Length > 11 ? ((int)pd[11]).ToString() : "0") + "}");
        }
        sb.Append("},");
        sb.Append("\"pending_count\":" + pendingOrders.Count + ",");
        
        // Yetim bacaklar
        sb.Append("\"orphans\":{");
        var orphFirst2 = true;
        foreach (var kv in orphanLegs) {
            if (!orphFirst2) sb.Append(",");
            orphFirst2 = false;
            var o = kv.Value;
            sb.Append("\"" + kv.Key + "\":{");
            sb.Append("\"fl\":\"" + o[0] + "\",");              // filledLeg
            sb.Append("\"fs\":\"" + o[2] + "\",");              // filledSide
            sb.Append("\"fq\":" + ((int)o[3]).ToString() + ","); // filledQty
            sb.Append("\"fp\":" + ((decimal)o[4]).ToString("F2", ic) + ","); // filledPrice
            sb.Append("\"tl\":\"" + o[5] + "\"}");              // targetLeg
        }
        sb.Append("},");
        sb.Append("\"orphan_count\":" + orphanLegs.Count + ",");
        
        // Pair Trading stats
        sb.Append("\"pair_enabled\":" + (PAIR_ENABLED ? "true" : "false") + ",");
        sb.Append("\"pair_budget\":" + PAIR_BUDGET.ToString("F0", ic) + ",");
        sb.Append("\"pair_used\":" + pairUsed.ToString("F0", ic) + ",");
        sb.Append("\"pair_count\":" + pairPos.Count + ",");
        
        // Pair Z-Scores
        sb.Append("\"pair_z\":{");
        var zFirst = true;
        foreach (var kv in pairZScores) {
            if (!zFirst) sb.Append(",");
            zFirst = false;
            sb.Append("\"" + kv.Key + "\":" + kv.Value.ToString("F2", ic));
        }
        sb.Append("},");
        
        // Pair pozisyonları (detaylı: anlık ve beklenen kar)
        sb.Append("\"pair_pos\":{");
        var ppFirst = true;
        decimal totalPairPnl = 0;
        foreach (var kv in pairPos) {
            if (!ppFirst) sb.Append(",");
            ppFirst = false;
            var p = kv.Value;
            var parts = kv.Key.Split('-');
            if (parts.Length == 2) {
                var symA = parts[0];
                var symB = parts[1];
                var currentZ = pairZScores.ContainsKey(kv.Key) ? pairZScores[kv.Key] : 0m;
                var unrealizedPnl = CalcPairUnrealizedPnl(kv.Key, p);
                var expectedPnl = p.Length > 7 ? p[7] : 0m;
                totalPairPnl += unrealizedPnl;
                
                // Vade gün sayısı
                var nearA = GetContract(symA, 0);
                var daysToExp = string.IsNullOrEmpty(nearA) ? 0 : GetDays(nearA);
                
                sb.Append("\"" + kv.Key + "\":{");
                sb.Append("\"a\":" + ((int)p[0]).ToString() + ",");
                sb.Append("\"b\":" + ((int)p[1]).ToString() + ",");
                sb.Append("\"avgA\":" + p[2].ToString("F2", ic) + ",");
                sb.Append("\"avgB\":" + p[3].ToString("F2", ic) + ",");
                sb.Append("\"oz\":" + p[4].ToString("F2", ic) + ",");
                sb.Append("\"cz\":" + currentZ.ToString("F2", ic) + ",");
                sb.Append("\"t\":" + ((int)p[5]).ToString() + ",");
                sb.Append("\"exp\":" + expectedPnl.ToString("F0", ic) + ",");
                sb.Append("\"pnl\":" + unrealizedPnl.ToString("F0", ic) + ",");
                sb.Append("\"d\":" + daysToExp.ToString() + "}");
            }
        }
        sb.Append("},");
        sb.Append("\"pair_pnl\":" + totalPairPnl.ToString("F0", ic) + ",");
        
        sb.Append("\"total_pnl\":" + (totalSnPnl + totalNfPnl + totalPairPnl).ToString("F0", ic) + ",\"count\":" + (snPos.Count + nfPos.Count + pairPos.Count) + "}");
        SafeWrite(STATS_FILE, sb.ToString());
        
        // Dashboard güncelle (dakikada bir)
        if ((DateTime.Now - lastGistUpload).TotalMinutes >= GIST_INTERVAL_MIN) {
            UpdateDashboard(false, true);  // resetCommand=false, includeLogs=true
        }
        
        // BB verisi güncelle (5 dakikalık bar tamamlandıktan sonra)
        // Bar kapanış zamanları: XX:00, XX:05, XX:10, XX:15, XX:20, XX:25, XX:30, XX:35, XX:40, XX:45, XX:50, XX:55
        var bbNow = DateTime.Now;
        var currentMinute = bbNow.Minute;
        var isBarCloseTime = (currentMinute % 5 == 0) && bbNow.Second <= 30;  // Bar kapanışından sonraki 30 sn içinde
        var lastRefreshMinute = lastBBRefresh.Minute;
        var minutesSinceRefresh = (bbNow - lastBBRefresh).TotalMinutes;
        
        // Koşul: Bar kapanış zamanındayız VE (son güncelleme 4+ dk önce VEYA farklı bar'dayız)
        if (isBarCloseTime && (minutesSinceRefresh >= 4 || (currentMinute / 5) != (lastRefreshMinute / 5))) {
            try { LoadSpreadBBFromChart(); } catch { }
        }
    } catch { }
};

// ====================================
// FORM
// ====================================
System.Windows.Forms.Form posForm = null;
System.Windows.Forms.DataGridView gridSn = null;
System.Windows.Forms.Label lblPosUpdate = null;
System.Windows.Forms.Label lblSnTotal = null;
System.Windows.Forms.Timer posTimer = null;

// JSON'dan sayı çıkaran yardımcı fonksiyon
Func<string, int, string> ExtractNumber = (s, start) => {
    var sb = new System.Text.StringBuilder();
    for (int i = start; i < s.Length; i++) {
        var c = s[i];
        if (char.IsDigit(c) || c == '.' || c == '-') sb.Append(c);
        else if (sb.Length > 0) break;
    }
    return sb.ToString();
};

Action UpdatePositionsGrid = null;
UpdatePositionsGrid = () => {
    if (posForm == null || posForm.IsDisposed || gridSn == null) return;
    try {
        posForm.BeginInvoke(new Action(() => {
            try {
                if (!System.IO.File.Exists(STATS_FILE)) return;
                var json = System.IO.File.ReadAllText(STATS_FILE);
                var ic = System.Globalization.CultureInfo.InvariantCulture;
                
                decimal totalPnl = 0;
                decimal totalExp = 0;
                gridSn.Rows.Clear();
                
                // positions bölümünü bul
                var posIdx = json.IndexOf("\"positions\":{");
                if (posIdx == -1) { gridSn.Rows.Add("Pozisyon yok", "-", "-", "-", "-", "-"); return; }
                
                var posStart = json.IndexOf("{", posIdx + 12);
                var posEnd = json.IndexOf("}}", posStart);
                if (posStart == -1 || posEnd == -1) return;
                
                var posContent = json.Substring(posStart, posEnd - posStart + 1);
                if (posContent == "{}") { gridSn.Rows.Add("Pozisyon yok", "-", "-", "-", "-", "-"); return; }
                
                // Her pozisyonu parse et
                int pos = 0;
                while (pos < posContent.Length) {
                    var q1 = posContent.IndexOf("\"", pos);
                    if (q1 == -1) break;
                    var q2 = posContent.IndexOf("\"", q1 + 1);
                    if (q2 == -1) break;
                    var sym = posContent.Substring(q1 + 1, q2 - q1 - 1);
                    
                    var objStart = posContent.IndexOf("{", q2);
                    var objEnd = posContent.IndexOf("}", objStart);
                    if (objStart == -1 || objEnd == -1) break;
                    
                    var objStr = posContent.Substring(objStart, objEnd - objStart + 1);
                    
                    // sq, nq, pnl, exp, d parse et
                    int sq = 0, nq = 0, d = 0;
                    decimal pnl = 0, exp = 0;
                    
                    var sqIdx = objStr.IndexOf("\"sq\":");
                    if (sqIdx >= 0) int.TryParse(ExtractNumber(objStr, sqIdx + 5), out sq);
                    
                    var nqIdx = objStr.IndexOf("\"nq\":");
                    if (nqIdx >= 0) int.TryParse(ExtractNumber(objStr, nqIdx + 5), out nq);
                    
                    var pnlIdx = objStr.IndexOf("\"pnl\":");
                    if (pnlIdx >= 0) decimal.TryParse(ExtractNumber(objStr, pnlIdx + 6), System.Globalization.NumberStyles.Any, ic, out pnl);
                    
                    var expIdx = objStr.IndexOf("\"exp\":");
                    if (expIdx >= 0) decimal.TryParse(ExtractNumber(objStr, expIdx + 6), System.Globalization.NumberStyles.Any, ic, out exp);
                    
                    var dIdx = objStr.IndexOf("\"d\":");
                    if (dIdx >= 0) int.TryParse(ExtractNumber(objStr, dIdx + 4), out d);
                    
                    totalPnl += pnl;
                    totalExp += exp;
                    
                    var row = gridSn.Rows.Add(sym, sq, nq, exp.ToString("N0"), pnl.ToString("N0"), d);
                    gridSn.Rows[row].Cells[3].Style.ForeColor = exp >= 0 ? System.Drawing.Color.Green : System.Drawing.Color.Red;
                    gridSn.Rows[row].Cells[4].Style.ForeColor = pnl >= 0 ? System.Drawing.Color.Green : System.Drawing.Color.Red;
                    
                    pos = objEnd + 1;
                }
                
                if (gridSn.Rows.Count == 0) gridSn.Rows.Add("Pozisyon yok", "-", "-", "-", "-", "-");
                lblSnTotal.Text = "Beklenen: " + totalExp.ToString("N0") + " | P&L: " + totalPnl.ToString("N0") + " TL";
                lblSnTotal.ForeColor = totalPnl >= 0 ? System.Drawing.Color.Green : System.Drawing.Color.Red;
                lblPosUpdate.Text = "Güncelleme: " + DateTime.Now.ToString("HH:mm:ss");
            } catch { }
        }));
    } catch { }
};

Action ShowPositionsForm = () => {
    if (posForm != null && !posForm.IsDisposed) { posForm.BringToFront(); return; }
    if (mainForm != null) mainForm.TopMost = false;
    
    posForm = new System.Windows.Forms.Form();
    posForm.Text = "Spot-Near Pozisyonlar";
    posForm.Size = new System.Drawing.Size(600, 300);
    posForm.TopMost = true;
    
    gridSn = new System.Windows.Forms.DataGridView();
    gridSn.Location = new System.Drawing.Point(10, 10);
    gridSn.Size = new System.Drawing.Size(565, 180);
    gridSn.AllowUserToAddRows = false;
    gridSn.ReadOnly = true;
    gridSn.AutoSizeColumnsMode = System.Windows.Forms.DataGridViewAutoSizeColumnsMode.Fill;
    gridSn.Columns.Add("Sym", "Sembol");
    gridSn.Columns.Add("Spot", "Spot Adet");
    gridSn.Columns.Add("Near", "Near Adet");
    gridSn.Columns.Add("Exp", "Beklenen");
    gridSn.Columns.Add("PnL", "P&L");
    gridSn.Columns.Add("Days", "Gün");
    
    lblSnTotal = new System.Windows.Forms.Label();
    lblSnTotal.Location = new System.Drawing.Point(280, 200);
    lblSnTotal.Size = new System.Drawing.Size(290, 25);
    lblSnTotal.Font = new System.Drawing.Font("Segoe UI", 11, System.Drawing.FontStyle.Bold);
    
    lblPosUpdate = new System.Windows.Forms.Label();
    lblPosUpdate.Location = new System.Drawing.Point(10, 200);
    lblPosUpdate.Size = new System.Drawing.Size(200, 20);
    lblPosUpdate.ForeColor = System.Drawing.Color.Gray;
    
    var btnClose = new System.Windows.Forms.Button();
    btnClose.Text = "Kapat";
    btnClose.Location = new System.Drawing.Point(250, 225);
    btnClose.Click += (s, e) => posForm.Close();
    
    posForm.Controls.AddRange(new System.Windows.Forms.Control[] { gridSn, lblSnTotal, lblPosUpdate, btnClose });
    
    posTimer = new System.Windows.Forms.Timer();
    posTimer.Interval = IS_TEST ? 10000 : 5000;  // Test: 10sn, Live: 5sn
    posTimer.Tick += (s, e) => UpdatePositionsGrid();
    posTimer.Start();
    
    posForm.FormClosing += (s, e) => { if (posTimer != null) posTimer.Stop(); if (mainForm != null) mainForm.TopMost = true; };
    UpdatePositionsGrid();
    posForm.Show();
};

Action ShowSettingsForm = () => {
    var sf = new System.Windows.Forms.Form();
    sf.Text = "Ayarlar";
    sf.Size = new System.Drawing.Size(760, 720);  // Butonlar için yükseklik artırıldı
    sf.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
    sf.StartPosition = System.Windows.Forms.FormStartPosition.CenterParent;
    sf.MaximizeBox = false;
    
    var ic = System.Globalization.CultureInfo.InvariantCulture;
    
    // ==================== SOL SÜTUN (x=15) ====================
    var leftX = 15;
    var leftLabelW = 95;
    var leftInputX = 115;
    var leftInputW = 100;
    var y = 15;
    
    // Gist ayarları
    var lblGistToken = new System.Windows.Forms.Label { Text = "Gist Token:", Location = new System.Drawing.Point(leftX, y), Size = new System.Drawing.Size(80, 20) };
    var txtGistToken = new System.Windows.Forms.TextBox { Location = new System.Drawing.Point(leftInputX - 15, y), Size = new System.Drawing.Size(250, 22), Text = GIST_TOKEN, PasswordChar = '*' };
    y += 26;
    var lblGistId = new System.Windows.Forms.Label { Text = "Gist ID:", Location = new System.Drawing.Point(leftX, y), Size = new System.Drawing.Size(80, 20) };
    var txtGistId = new System.Windows.Forms.TextBox { Location = new System.Drawing.Point(leftInputX - 15, y), Size = new System.Drawing.Size(250, 22), Text = GIST_ID };
    y += 32;
    
    // Ayraç - Bütçe
    var sep1 = new System.Windows.Forms.Label { BorderStyle = System.Windows.Forms.BorderStyle.Fixed3D, Location = new System.Drawing.Point(leftX, y), Size = new System.Drawing.Size(340, 2) };
    y += 8;
    var lblBudgetTitle = new System.Windows.Forms.Label { Text = "💰 BÜTÇE", Location = new System.Drawing.Point(leftX, y), Size = new System.Drawing.Size(100, 18), Font = new System.Drawing.Font("Segoe UI", 9, System.Drawing.FontStyle.Bold), ForeColor = System.Drawing.Color.DarkBlue };
    y += 22;
    
    var lblViop = new System.Windows.Forms.Label { Text = "VIOP Bütçe:", Location = new System.Drawing.Point(leftX, y), Size = new System.Drawing.Size(leftLabelW, 20) };
    var txtViop = new System.Windows.Forms.TextBox { Location = new System.Drawing.Point(leftInputX, y), Size = new System.Drawing.Size(leftInputW, 22), Text = VIOP_BUDGET.ToString("F0") };
    y += 26;
    var lblSpot = new System.Windows.Forms.Label { Text = "Spot Bütçe:", Location = new System.Drawing.Point(leftX, y), Size = new System.Drawing.Size(leftLabelW, 20) };
    var txtSpot = new System.Windows.Forms.TextBox { Location = new System.Drawing.Point(leftInputX, y), Size = new System.Drawing.Size(leftInputW, 22), Text = SPOT_BUDGET.ToString("F0") };
    y += 32;
    
    // Ayraç - SN Strateji
    var sep2 = new System.Windows.Forms.Label { BorderStyle = System.Windows.Forms.BorderStyle.Fixed3D, Location = new System.Drawing.Point(leftX, y), Size = new System.Drawing.Size(340, 2) };
    y += 8;
    var lblSNTitle = new System.Windows.Forms.Label { Text = "📊 SN STRATEJİ", Location = new System.Drawing.Point(leftX, y), Size = new System.Drawing.Size(120, 18), Font = new System.Drawing.Font("Segoe UI", 9, System.Drawing.FontStyle.Bold), ForeColor = System.Drawing.Color.DarkBlue };
    y += 22;
    
    var lblMargin = new System.Windows.Forms.Label { Text = "Min Marj %:", Location = new System.Drawing.Point(leftX, y), Size = new System.Drawing.Size(leftLabelW, 20) };
    var txtMargin = new System.Windows.Forms.TextBox { Location = new System.Drawing.Point(leftInputX, y), Size = new System.Drawing.Size(leftInputW, 22), Text = (SN_MIN_MARGIN * 100).ToString("F2", ic) };
    y += 26;
    var lblRollMargin = new System.Windows.Forms.Label { Text = "Roll Min %:", Location = new System.Drawing.Point(leftX, y), Size = new System.Drawing.Size(leftLabelW, 20) };
    var txtRollMargin = new System.Windows.Forms.TextBox { Location = new System.Drawing.Point(leftInputX, y), Size = new System.Drawing.Size(leftInputW, 22), Text = (ROLL_MIN_MARGIN * 100).ToString("F2", ic) };
    y += 26;
    var lblReplaceThresh = new System.Windows.Forms.Label { Text = "Replace %:", Location = new System.Drawing.Point(leftX, y), Size = new System.Drawing.Size(leftLabelW, 20) };
    var txtReplaceThresh = new System.Windows.Forms.TextBox { Location = new System.Drawing.Point(leftInputX, y), Size = new System.Drawing.Size(leftInputW, 22), Text = (REPLACEMENT_THRESHOLD * 100).ToString("F0", ic) };
    y += 26;
    var lblGieDepth = new System.Windows.Forms.Label { Text = "GIE Kademe:", Location = new System.Drawing.Point(leftX, y), Size = new System.Drawing.Size(leftLabelW, 20) };
    var txtGieDepth = new System.Windows.Forms.TextBox { Location = new System.Drawing.Point(leftInputX, y), Size = new System.Drawing.Size(leftInputW, 22), Text = GIE_DEPTH_LEVELS.ToString() };
    y += 32;
    
    // Ayraç - Risk
    var sep3 = new System.Windows.Forms.Label { BorderStyle = System.Windows.Forms.BorderStyle.Fixed3D, Location = new System.Drawing.Point(leftX, y), Size = new System.Drawing.Size(340, 2) };
    y += 8;
    var lblRiskTitle = new System.Windows.Forms.Label { Text = "⚠️ RİSK", Location = new System.Drawing.Point(leftX, y), Size = new System.Drawing.Size(100, 18), Font = new System.Drawing.Font("Segoe UI", 9, System.Drawing.FontStyle.Bold), ForeColor = System.Drawing.Color.DarkRed };
    y += 22;
    
    var lblLoss = new System.Windows.Forms.Label { Text = "Max Zarar:", Location = new System.Drawing.Point(leftX, y), Size = new System.Drawing.Size(leftLabelW, 20) };
    var txtLoss = new System.Windows.Forms.TextBox { Location = new System.Drawing.Point(leftInputX, y), Size = new System.Drawing.Size(leftInputW, 22), Text = MAX_DAILY_LOSS.ToString("F0") };
    y += 26;
    var lblEarlyK = new System.Windows.Forms.Label { Text = "Erken Çıkış K:", Location = new System.Drawing.Point(leftX, y), Size = new System.Drawing.Size(leftLabelW, 20) };
    var txtEarlyK = new System.Windows.Forms.TextBox { Location = new System.Drawing.Point(leftInputX, y), Size = new System.Drawing.Size(60, 22), Text = EARLY_EXIT_K.ToString("F2", ic) };
    var lblEarlyKHint = new System.Windows.Forms.Label { Text = "(dinamik)", Location = new System.Drawing.Point(leftInputX + 65, y), Size = new System.Drawing.Size(60, 20), ForeColor = System.Drawing.Color.Gray };
    y += 26;
    var lblBBExit = new System.Windows.Forms.Label { Text = "BB Çıkış Ref:", Location = new System.Drawing.Point(leftX, y), Size = new System.Drawing.Size(leftLabelW, 20) };
    var txtBBExit = new System.Windows.Forms.TextBox { Location = new System.Drawing.Point(leftInputX, y), Size = new System.Drawing.Size(60, 22), Text = BB_EXIT_HELPER.ToString("F0", ic) };
    var lblBBExitHint = new System.Windows.Forms.Label { Text = "(BB5 altı)", Location = new System.Drawing.Point(leftInputX + 65, y), Size = new System.Drawing.Size(60, 20), ForeColor = System.Drawing.Color.Gray };
    y += 26;
    var lblIntraday = new System.Windows.Forms.Label { Text = "Gün İçi Min‰:", Location = new System.Drawing.Point(leftX, y), Size = new System.Drawing.Size(leftLabelW, 20) };
    var txtIntraday = new System.Windows.Forms.TextBox { Location = new System.Drawing.Point(leftInputX, y), Size = new System.Drawing.Size(60, 22), Text = (INTRADAY_MIN_PROFIT * 1000).ToString("F1", ic) };
    var lblIntradayHint = new System.Windows.Forms.Label { Text = "(binde)", Location = new System.Drawing.Point(leftInputX + 65, y), Size = new System.Drawing.Size(50, 20), ForeColor = System.Drawing.Color.Gray };
    y += 32;
    
    // Ayraç - Margin
    var sep4 = new System.Windows.Forms.Label { BorderStyle = System.Windows.Forms.BorderStyle.Fixed3D, Location = new System.Drawing.Point(leftX, y), Size = new System.Drawing.Size(340, 2) };
    y += 8;
    var lblMarginTitle = new System.Windows.Forms.Label { Text = "🛡️ MARJİN", Location = new System.Drawing.Point(leftX, y), Size = new System.Drawing.Size(100, 18), Font = new System.Drawing.Font("Segoe UI", 9, System.Drawing.FontStyle.Bold), ForeColor = System.Drawing.Color.DarkOrange };
    y += 22;
    
    var lblMarginWarn = new System.Windows.Forms.Label { Text = "Sarı %:", Location = new System.Drawing.Point(leftX, y), Size = new System.Drawing.Size(50, 20) };
    var txtMarginWarn = new System.Windows.Forms.TextBox { Location = new System.Drawing.Point(leftX + 55, y), Size = new System.Drawing.Size(40, 22), Text = (MARGIN_WARNING_PCT * 100).ToString("F0", ic) };
    var lblMarginDanger = new System.Windows.Forms.Label { Text = "Turuncu:", Location = new System.Drawing.Point(leftX + 105, y), Size = new System.Drawing.Size(55, 20) };
    var txtMarginDanger = new System.Windows.Forms.TextBox { Location = new System.Drawing.Point(leftX + 165, y), Size = new System.Drawing.Size(40, 22), Text = (MARGIN_DANGER_PCT * 100).ToString("F0", ic) };
    var lblMarginCrit = new System.Windows.Forms.Label { Text = "Kırmızı:", Location = new System.Drawing.Point(leftX + 215, y), Size = new System.Drawing.Size(50, 20) };
    var txtMarginCrit = new System.Windows.Forms.TextBox { Location = new System.Drawing.Point(leftX + 270, y), Size = new System.Drawing.Size(40, 22), Text = (MARGIN_CRITICAL_PCT * 100).ToString("F0", ic) };
    y += 32;
    
    // Ayraç - BB93
    var sep5 = new System.Windows.Forms.Label { BorderStyle = System.Windows.Forms.BorderStyle.Fixed3D, Location = new System.Drawing.Point(leftX, y), Size = new System.Drawing.Size(340, 2) };
    y += 8;
    var lblBB93Title = new System.Windows.Forms.Label { Text = "🎯 BB93 STRATEJİSİ", Location = new System.Drawing.Point(leftX, y), Size = new System.Drawing.Size(140, 18), Font = new System.Drawing.Font("Segoe UI", 9, System.Drawing.FontStyle.Bold), ForeColor = System.Drawing.Color.Purple };
    y += 22;
    
    var chkBB93 = new System.Windows.Forms.CheckBox { Text = "Aktif", Location = new System.Drawing.Point(leftX, y), Checked = BB93_ENTRY_ENABLED, Size = new System.Drawing.Size(55, 20) };
    var txtBB93StartHour = new System.Windows.Forms.TextBox { Location = new System.Drawing.Point(leftX + 60, y), Size = new System.Drawing.Size(35, 22), Text = BB93_START_HOUR.ToString() };
    var lblBB93Sep1 = new System.Windows.Forms.Label { Text = ":", Location = new System.Drawing.Point(leftX + 97, y), Size = new System.Drawing.Size(10, 20) };
    var txtBB93StartMin = new System.Windows.Forms.TextBox { Location = new System.Drawing.Point(leftX + 107, y), Size = new System.Drawing.Size(35, 22), Text = BB93_START_MIN.ToString("D2") };
    var lblBB93Dash = new System.Windows.Forms.Label { Text = "-", Location = new System.Drawing.Point(leftX + 147, y), Size = new System.Drawing.Size(15, 20) };
    var txtBB93EndHour = new System.Windows.Forms.TextBox { Location = new System.Drawing.Point(leftX + 162, y), Size = new System.Drawing.Size(35, 22), Text = BB93_END_HOUR.ToString() };
    var lblBB93Sep2 = new System.Windows.Forms.Label { Text = ":", Location = new System.Drawing.Point(leftX + 199, y), Size = new System.Drawing.Size(10, 20) };
    var txtBB93EndMin = new System.Windows.Forms.TextBox { Location = new System.Drawing.Point(leftX + 209, y), Size = new System.Drawing.Size(35, 22), Text = BB93_END_MIN.ToString("D2") };
    y += 32;
    
    // Ayraç - Cache
    var sep6 = new System.Windows.Forms.Label { BorderStyle = System.Windows.Forms.BorderStyle.Fixed3D, Location = new System.Drawing.Point(leftX, y), Size = new System.Drawing.Size(340, 2) };
    y += 8;
    var lblCachePath = new System.Windows.Forms.Label { Text = "Cache Yolu:", Location = new System.Drawing.Point(leftX, y), Size = new System.Drawing.Size(leftLabelW, 20) };
    var txtCachePath = new System.Windows.Forms.TextBox { Location = new System.Drawing.Point(leftInputX, y), Size = new System.Drawing.Size(230, 22), Text = CACHE_PATH != BASE_PATH ? CACHE_PATH : "" };
    y += 20;
    var lblCacheHint = new System.Windows.Forms.Label { Text = "(Boş=D:\\arbit\\, RAMDisk için Z:\\ gibi)", Location = new System.Drawing.Point(leftInputX, y), Size = new System.Drawing.Size(220, 16), ForeColor = System.Drawing.Color.Gray, Font = new System.Drawing.Font("Segoe UI", 7.5f) };
    y += 26;
    
    var chkTest = new System.Windows.Forms.CheckBox { Text = "🧪 Test Modu", Location = new System.Drawing.Point(leftX, y), Checked = IS_TEST, Size = new System.Drawing.Size(120, 20), Font = new System.Drawing.Font("Segoe UI", 9, System.Drawing.FontStyle.Bold) };
    
    // ==================== SAĞ SÜTUN (x=390) ====================
    var rightX = 390;
    var rightLabelW = 95;
    var rightInputX = 490;
    var rightInputW = 100;
    var yR = 68;  // Gist satırlarının altından başla
    
    // Ayraç - NF
    var sepR1 = new System.Windows.Forms.Label { BorderStyle = System.Windows.Forms.BorderStyle.Fixed3D, Location = new System.Drawing.Point(rightX, yR), Size = new System.Drawing.Size(340, 2) };
    yR += 8;
    var lblNFTitle = new System.Windows.Forms.Label { Text = "🔄 NEAR-FAR STRATEJİSİ", Location = new System.Drawing.Point(rightX, yR), Size = new System.Drawing.Size(180, 18), Font = new System.Drawing.Font("Segoe UI", 9, System.Drawing.FontStyle.Bold), ForeColor = System.Drawing.Color.DarkGreen };
    yR += 22;
    
    var chkNF = new System.Windows.Forms.CheckBox { Text = "Aktif", Location = new System.Drawing.Point(rightX, yR), Checked = NF_ENABLED, Size = new System.Drawing.Size(55, 20) };
    var lblNFMax = new System.Windows.Forms.Label { Text = "Max Poz:", Location = new System.Drawing.Point(rightX + 70, yR), Size = new System.Drawing.Size(60, 20) };
    var txtNFMax = new System.Windows.Forms.TextBox { Location = new System.Drawing.Point(rightX + 135, yR), Size = new System.Drawing.Size(40, 22), Text = NF_MAX_POSITIONS.ToString() };
    yR += 26;
    
    var lblNFEntryBB = new System.Windows.Forms.Label { Text = "Giriş BB ≥", Location = new System.Drawing.Point(rightX, yR), Size = new System.Drawing.Size(70, 20) };
    var txtNFEntryBB = new System.Windows.Forms.TextBox { Location = new System.Drawing.Point(rightX + 75, yR), Size = new System.Drawing.Size(40, 22), Text = NF_ENTRY_BB.ToString() };
    var lblNFExitBB = new System.Windows.Forms.Label { Text = "Çıkış BB ≤", Location = new System.Drawing.Point(rightX + 130, yR), Size = new System.Drawing.Size(70, 20) };
    var txtNFExitBB = new System.Windows.Forms.TextBox { Location = new System.Drawing.Point(rightX + 205, yR), Size = new System.Drawing.Size(40, 22), Text = NF_EXIT_BB.ToString() };
    yR += 26;
    
    var lblNFProfit = new System.Windows.Forms.Label { Text = "Kâr Çıkış ‰:", Location = new System.Drawing.Point(rightX, yR), Size = new System.Drawing.Size(80, 20) };
    var txtNFProfit = new System.Windows.Forms.TextBox { Location = new System.Drawing.Point(rightX + 85, yR), Size = new System.Drawing.Size(40, 22), Text = (NF_EXIT_PROFIT * 1000).ToString("F1") };
    var lblNFProfitHint = new System.Windows.Forms.Label { Text = "(binde)", Location = new System.Drawing.Point(rightX + 130, yR), Size = new System.Drawing.Size(50, 20), ForeColor = System.Drawing.Color.Gray };
    yR += 38;
    
    // Ayraç - PAIR
    var sepR2 = new System.Windows.Forms.Label { BorderStyle = System.Windows.Forms.BorderStyle.Fixed3D, Location = new System.Drawing.Point(rightX, yR), Size = new System.Drawing.Size(340, 2) };
    yR += 8;
    var lblPairTitle = new System.Windows.Forms.Label { Text = "📊 PAIR TRADING", Location = new System.Drawing.Point(rightX, yR), Size = new System.Drawing.Size(140, 18), Font = new System.Drawing.Font("Segoe UI", 9, System.Drawing.FontStyle.Bold), ForeColor = System.Drawing.Color.Teal };
    yR += 22;
    
    var chkPair = new System.Windows.Forms.CheckBox { Text = "Aktif", Location = new System.Drawing.Point(rightX, yR), Checked = PAIR_ENABLED, Size = new System.Drawing.Size(55, 20) };
    var lblPairBudget = new System.Windows.Forms.Label { Text = "Bütçe:", Location = new System.Drawing.Point(rightX + 70, yR), Size = new System.Drawing.Size(50, 20) };
    var txtPairBudget = new System.Windows.Forms.TextBox { Location = new System.Drawing.Point(rightX + 120, yR), Size = new System.Drawing.Size(80, 22), Text = PAIR_BUDGET.ToString("F0") };
    yR += 28;
    
    var lblPairAlloc = new System.Windows.Forms.Label { Text = "Dağılım %:", Location = new System.Drawing.Point(rightX, yR), Size = new System.Drawing.Size(70, 20) };
    var txtPairAlloc1 = new System.Windows.Forms.TextBox { Location = new System.Drawing.Point(rightX + 75, yR), Size = new System.Drawing.Size(35, 22), Text = PAIR_ALLOC_1.ToString() };
    var txtPairAlloc2 = new System.Windows.Forms.TextBox { Location = new System.Drawing.Point(rightX + 115, yR), Size = new System.Drawing.Size(35, 22), Text = PAIR_ALLOC_2.ToString() };
    var txtPairAlloc3 = new System.Windows.Forms.TextBox { Location = new System.Drawing.Point(rightX + 155, yR), Size = new System.Drawing.Size(35, 22), Text = PAIR_ALLOC_3.ToString() };
    var lblPairAllocHint = new System.Windows.Forms.Label { Text = "(K1/K2/K3)", Location = new System.Drawing.Point(rightX + 195, yR), Size = new System.Drawing.Size(70, 20), ForeColor = System.Drawing.Color.Gray };
    yR += 28;
    
    var lblPairZ1 = new System.Windows.Forms.Label { Text = "Z Giriş:", Location = new System.Drawing.Point(rightX, yR), Size = new System.Drawing.Size(55, 20) };
    var txtPairZ1 = new System.Windows.Forms.TextBox { Location = new System.Drawing.Point(rightX + 55, yR), Size = new System.Drawing.Size(35, 22), Text = PAIR_Z_ENTRY_1.ToString("F1", ic) };
    var txtPairZ2 = new System.Windows.Forms.TextBox { Location = new System.Drawing.Point(rightX + 95, yR), Size = new System.Drawing.Size(35, 22), Text = PAIR_Z_ENTRY_2.ToString("F1", ic) };
    var txtPairZ3 = new System.Windows.Forms.TextBox { Location = new System.Drawing.Point(rightX + 135, yR), Size = new System.Drawing.Size(35, 22), Text = PAIR_Z_ENTRY_3.ToString("F1", ic) };
    var lblPairZExit = new System.Windows.Forms.Label { Text = "Çıkış:", Location = new System.Drawing.Point(rightX + 180, yR), Size = new System.Drawing.Size(40, 20) };
    var txtPairZExit = new System.Windows.Forms.TextBox { Location = new System.Drawing.Point(rightX + 220, yR), Size = new System.Drawing.Size(35, 22), Text = PAIR_Z_EXIT.ToString("F1", ic) };
    yR += 32;
    
    // Ayraç - Çift Tanımları
    var sepR3 = new System.Windows.Forms.Label { BorderStyle = System.Windows.Forms.BorderStyle.Fixed3D, Location = new System.Drawing.Point(rightX, yR), Size = new System.Drawing.Size(340, 2) };
    yR += 8;
    var lblPairDefsTitle = new System.Windows.Forms.Label { Text = "📝 ÇİFT TANIMLARI", Location = new System.Drawing.Point(rightX, yR), Size = new System.Drawing.Size(140, 18), Font = new System.Drawing.Font("Segoe UI", 9, System.Drawing.FontStyle.Bold), ForeColor = System.Drawing.Color.DarkSlateGray };
    yR += 22;
    
    var txtPairDefs = new System.Windows.Forms.TextBox { Location = new System.Drawing.Point(rightX, yR), Size = new System.Drawing.Size(340, 22), Text = PAIR_DEFINITIONS };
    yR += 22;
    var lblPairDefsHint = new System.Windows.Forms.Label { Text = "(SYM1-SYM2:beta, ... örn: TCELL-TTKOM:1.80)", Location = new System.Drawing.Point(rightX, yR), Size = new System.Drawing.Size(340, 16), ForeColor = System.Drawing.Color.Gray, Font = new System.Drawing.Font("Segoe UI", 7.5f) };
    yR += 30;
    
    // Butonlar (ortalanmış)
    var btnY = Math.Max(y + 30, yR + 30);
    var btnSave = new System.Windows.Forms.Button();
    btnSave.Text = "Kaydet";
    btnSave.Location = new System.Drawing.Point(280, btnY);
    btnSave.Size = new System.Drawing.Size(90, 32);
    btnSave.BackColor = System.Drawing.Color.FromArgb(46, 125, 50);
    btnSave.ForeColor = System.Drawing.Color.White;
    btnSave.FlatStyle = System.Windows.Forms.FlatStyle.Flat;
    btnSave.Click += (s, e) => {
        try {
            // Kademe dağılımı validasyonu
            var allocTotal = int.Parse(txtPairAlloc1.Text) + int.Parse(txtPairAlloc2.Text) + int.Parse(txtPairAlloc3.Text);
            if (allocTotal != 100) {
                System.Windows.Forms.MessageBox.Show("Kademe dağılımı toplamı %100 olmalı! Şu an: %" + allocTotal, "Uyarı");
                return;
            }
            
            // Gist credentials ayrı dosyaya (Gist'e yüklenmiyor)
            var credSb = new System.Text.StringBuilder();
            credSb.Append("{\"gist_token\":\"" + txtGistToken.Text + "\"");
            credSb.Append(",\"gist_id\":\"" + txtGistId.Text + "\"}");
            System.IO.File.WriteAllText(GIST_CREDENTIALS_FILE, credSb.ToString());
            
            // Diğer ayarlar (Gist'e yükleniyor)
            var sb = new System.Text.StringBuilder();
            sb.Append("{\"test_mode\":" + (chkTest.Checked ? "1" : "0"));
            sb.Append(",\"viop_budget\":" + txtViop.Text);
            sb.Append(",\"spot_budget\":" + txtSpot.Text);
            sb.Append(",\"sn_min_margin\":" + (decimal.Parse(txtMargin.Text, ic) / 100).ToString(ic));
            sb.Append(",\"roll_min_margin\":" + (decimal.Parse(txtRollMargin.Text, ic) / 100).ToString(ic));
            sb.Append(",\"replacement_threshold\":" + (decimal.Parse(txtReplaceThresh.Text, ic) / 100).ToString(ic));
            sb.Append(",\"gie_depth_levels\":" + txtGieDepth.Text);
            sb.Append(",\"max_daily_loss\":" + txtLoss.Text);
            sb.Append(",\"early_exit_k\":" + decimal.Parse(txtEarlyK.Text.Replace(",", "."), ic).ToString(ic));
            sb.Append(",\"bb_exit_helper\":" + decimal.Parse(txtBBExit.Text, ic).ToString(ic));
            sb.Append(",\"intraday_min_profit\":" + (decimal.Parse(txtIntraday.Text.Replace(",", "."), ic) / 1000).ToString(ic));
            sb.Append(",\"margin_warning_pct\":" + (decimal.Parse(txtMarginWarn.Text, ic) / 100).ToString(ic));
            sb.Append(",\"margin_danger_pct\":" + (decimal.Parse(txtMarginDanger.Text, ic) / 100).ToString(ic));
            sb.Append(",\"margin_critical_pct\":" + (decimal.Parse(txtMarginCrit.Text, ic) / 100).ToString(ic));
            // Cache path (RAMDisk) - normalize et
            if (!string.IsNullOrEmpty(txtCachePath.Text.Trim())) {
                var cp = txtCachePath.Text.Trim().TrimEnd('\\');
                cp += "\\";
                sb.Append(",\"cache_path\":\"" + cp.Replace("\\", "\\\\") + "\"");
            }
            // BB93 ayarları
            sb.Append(",\"bb93_enabled\":" + (chkBB93.Checked ? "1" : "0"));
            sb.Append(",\"bb93_start_hour\":" + int.Parse(txtBB93StartHour.Text));
            sb.Append(",\"bb93_start_min\":" + int.Parse(txtBB93StartMin.Text));
            sb.Append(",\"bb93_end_hour\":" + int.Parse(txtBB93EndHour.Text));
            sb.Append(",\"bb93_end_min\":" + int.Parse(txtBB93EndMin.Text));
            // NF ayarları
            sb.Append(",\"nf_enabled\":" + (chkNF.Checked ? "1" : "0"));
            sb.Append(",\"nf_max_positions\":" + int.Parse(txtNFMax.Text));
            sb.Append(",\"nf_entry_bb\":" + int.Parse(txtNFEntryBB.Text));
            sb.Append(",\"nf_exit_bb\":" + int.Parse(txtNFExitBB.Text));
            sb.Append(",\"nf_exit_profit\":" + (decimal.Parse(txtNFProfit.Text.Replace(",", "."), ic) / 1000).ToString(ic));
            // PAIR ayarları
            sb.Append(",\"pair_enabled\":" + (chkPair.Checked ? "1" : "0"));
            sb.Append(",\"pair_budget\":" + decimal.Parse(txtPairBudget.Text, ic).ToString("F0", ic));
            sb.Append(",\"pair_alloc_1\":" + txtPairAlloc1.Text);
            sb.Append(",\"pair_alloc_2\":" + txtPairAlloc2.Text);
            sb.Append(",\"pair_alloc_3\":" + txtPairAlloc3.Text);
            sb.Append(",\"pair_z_entry_1\":" + decimal.Parse(txtPairZ1.Text.Replace(",", "."), ic).ToString(ic));
            sb.Append(",\"pair_z_entry_2\":" + decimal.Parse(txtPairZ2.Text.Replace(",", "."), ic).ToString(ic));
            sb.Append(",\"pair_z_entry_3\":" + decimal.Parse(txtPairZ3.Text.Replace(",", "."), ic).ToString(ic));
            sb.Append(",\"pair_z_exit\":" + decimal.Parse(txtPairZExit.Text.Replace(",", "."), ic).ToString(ic));
            sb.Append(",\"pair_definitions\":\"" + txtPairDefs.Text.Trim() + "\"");
            sb.Append(",\"bb_period\":" + BB_PERIOD);
            sb.Append(",\"loop_ms\":" + LOOP_MS);
            sb.Append("}");
            System.IO.File.WriteAllText(SETTINGS_FILE, sb.ToString());
            
            settingsNeedReload = true;
            sf.Close();
        } catch (Exception ex) {
            System.Windows.Forms.MessageBox.Show("Hata: " + ex.Message);
        }
    };
    
    var btnCancel = new System.Windows.Forms.Button { Text = "İptal", Location = new System.Drawing.Point(390, btnY), Size = new System.Drawing.Size(90, 32) };
    btnCancel.FlatStyle = System.Windows.Forms.FlatStyle.Flat;
    btnCancel.Click += (s, e) => sf.Close();
    
    sf.Controls.AddRange(new System.Windows.Forms.Control[] { 
        // Sol sütun
        lblGistToken, txtGistToken, lblGistId, txtGistId, sep1, lblBudgetTitle,
        lblViop, txtViop, lblSpot, txtSpot,
        sep2, lblSNTitle, lblMargin, txtMargin, lblRollMargin, txtRollMargin, 
        lblReplaceThresh, txtReplaceThresh, lblGieDepth, txtGieDepth,
        sep3, lblRiskTitle, lblLoss, txtLoss, lblEarlyK, txtEarlyK, lblEarlyKHint, 
        lblBBExit, txtBBExit, lblBBExitHint, lblIntraday, txtIntraday, lblIntradayHint,
        sep4, lblMarginTitle, lblMarginWarn, txtMarginWarn, lblMarginDanger, txtMarginDanger, 
        lblMarginCrit, txtMarginCrit,
        sep5, lblBB93Title, chkBB93, txtBB93StartHour, lblBB93Sep1, txtBB93StartMin, 
        lblBB93Dash, txtBB93EndHour, lblBB93Sep2, txtBB93EndMin,
        sep6, lblCachePath, txtCachePath, lblCacheHint, chkTest,
        // Sağ sütun
        sepR1, lblNFTitle, chkNF, lblNFMax, txtNFMax, 
        lblNFEntryBB, txtNFEntryBB, lblNFExitBB, txtNFExitBB, 
        lblNFProfit, txtNFProfit, lblNFProfitHint,
        sepR2, lblPairTitle, chkPair, lblPairBudget, txtPairBudget,
        lblPairAlloc, txtPairAlloc1, txtPairAlloc2, txtPairAlloc3, lblPairAllocHint,
        lblPairZ1, txtPairZ1, txtPairZ2, txtPairZ3, lblPairZExit, txtPairZExit,
        sepR3, lblPairDefsTitle, txtPairDefs, lblPairDefsHint,
        // Butonlar
        btnSave, btnCancel 
    });
    
    // mainForm varsa parent olarak kullan, yoksa bağımsız aç
    if (mainForm != null && !mainForm.IsDisposed) {
        sf.ShowDialog(mainForm);
    } else {
        sf.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen;
        sf.ShowDialog();
    }
};

Action CreateControlForm = () => {
    mainForm = new System.Windows.Forms.Form();
    mainForm.Text = "SN-NF-PAIR Robot v19.4";
    mainForm.Size = new System.Drawing.Size(760, 295);  // 8 satır log için
    mainForm.TopMost = true;
    mainForm.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
    
    var btnExit = new System.Windows.Forms.Button { Text = "Çıkış", Location = new System.Drawing.Point(20, 20), Size = new System.Drawing.Size(80, 35), BackColor = System.Drawing.Color.FromArgb(220, 53, 69), ForeColor = System.Drawing.Color.White };
    btnExit.Click += (s, e) => { 
        stopRequested = true; 
        mainForm.Close(); 
    };
    
    btnPause = new System.Windows.Forms.Button { Text = "Duraklat", Location = new System.Drawing.Point(110, 20), Size = new System.Drawing.Size(80, 35), BackColor = System.Drawing.Color.FromArgb(255, 193, 7) };
    btnPause.Click += (s, e) => {
        isPaused = !isPaused;
        btnPause.Text = isPaused ? "Başlat" : "Duraklat";
        btnPause.BackColor = isPaused ? System.Drawing.Color.FromArgb(40, 167, 69) : System.Drawing.Color.FromArgb(255, 193, 7);
        lblStatus.Text = isPaused ? "⏸️ DURAKLADI" : "▶️ ÇALIŞIYOR";
        lblStatus.ForeColor = isPaused ? System.Drawing.Color.Orange : System.Drawing.Color.Green;
        if (!isPaused) {
            if (settingsNeedReload) { LoadSettings(); settingsNeedReload = false; }
            // Gist komutunu sıfırla (dashboard senkronizasyonu için)
            System.Threading.ThreadPool.QueueUserWorkItem(_ => ResetGistToNone());
        }
    };
    
    var btnSettings = new System.Windows.Forms.Button { Text = "Ayarlar", Location = new System.Drawing.Point(200, 20), Size = new System.Drawing.Size(80, 35), BackColor = System.Drawing.Color.FromArgb(0, 123, 255), ForeColor = System.Drawing.Color.White };
    btnSettings.Click += (s, e) => { if (isPaused) ShowSettingsForm(); };
    
    var btnPos = new System.Windows.Forms.Button { Text = "Pozisyonlar", Location = new System.Drawing.Point(290, 20), Size = new System.Drawing.Size(90, 35), BackColor = System.Drawing.Color.FromArgb(108, 117, 125), ForeColor = System.Drawing.Color.White };
    btnPos.Click += (s, e) => ShowPositionsForm();
    
    lblStatus = new System.Windows.Forms.Label { Text = "▶️ ÇALIŞIYOR", Location = new System.Drawing.Point(20, 65), Size = new System.Drawing.Size(700, 25), Font = new System.Drawing.Font("Segoe UI", 12, System.Drawing.FontStyle.Bold), ForeColor = System.Drawing.Color.Green };
    lblInfo = new System.Windows.Forms.Label { Text = "Başlatılıyor...", Location = new System.Drawing.Point(20, 95), Size = new System.Drawing.Size(700, 20), Font = new System.Drawing.Font("Consolas", 9) };
    
    // Log paneli - 100 karakter + %5 margin, 8 satır (Consolas 8pt ~7px/char, ~14px/satır)
    lblLog = new System.Windows.Forms.Label { 
        Text = "", 
        Location = new System.Drawing.Point(20, 120), 
        Size = new System.Drawing.Size(705, 125), 
        Font = new System.Drawing.Font("Consolas", 8), 
        ForeColor = System.Drawing.Color.DarkSlateGray,
        BackColor = System.Drawing.Color.FromArgb(245, 245, 245),
        BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle,
        Padding = new System.Windows.Forms.Padding(3)
    };
    
    mainForm.Controls.AddRange(new System.Windows.Forms.Control[] { btnExit, btnPause, btnSettings, btnPos, lblStatus, lblInfo, lblLog });
    mainForm.FormClosing += (s, e) => stopRequested = true;
    System.Windows.Forms.Application.Run(mainForm);
};

Action UpdateFormInfo = () => {
    if (mainForm == null || lblInfo == null) return;
    try {
        mainForm.BeginInvoke(new Action(() => {
            lblInfo.Text = "Poz: " + snPos.Count + " | P&L: " + dailyRealizedPnl.ToString("N0") + " TL | Piyasa: " + (isMarketOpen ? "AÇIK" : "KAPALI");
        }));
    } catch { }
};

// ====================================
// BAŞLATMA
// ====================================

// Settings'i önce yükle (LOG_PATH için)
try { LoadSettings(); } catch { }

// Başlangıç formu - Başlat/Ayarlar/Çıkış seçimi + özet bilgiler
var userChoice = 0;  // 0=bekle, 1=başlat, 2=çıkış
var startupForm = new System.Windows.Forms.Form();
startupForm.Text = "SN-NF-PAIR Robot v19.4";
startupForm.Size = new System.Drawing.Size(420, 340);
startupForm.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen;
startupForm.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
startupForm.MaximizeBox = false;
startupForm.MinimizeBox = false;
startupForm.BackColor = System.Drawing.Color.FromArgb(250, 250, 252);

// Başlık
var lblStartup = new System.Windows.Forms.Label {
    Text = "🤖 SN-NF-PAIR Arbitraj Robot",
    Location = new System.Drawing.Point(20, 15),
    Size = new System.Drawing.Size(380, 28),
    Font = new System.Drawing.Font("Segoe UI", 14, System.Drawing.FontStyle.Bold),
    ForeColor = System.Drawing.Color.FromArgb(30, 60, 114),
    TextAlign = System.Drawing.ContentAlignment.MiddleCenter
};

// Ayarlar özeti paneli
var pnlSummary = new System.Windows.Forms.Panel {
    Location = new System.Drawing.Point(20, 50),
    Size = new System.Drawing.Size(375, 180),
    BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle,
    BackColor = System.Drawing.Color.White
};

// Özet bilgiler - sol sütun
var summaryFont = new System.Drawing.Font("Consolas", 9);
var labelColor = System.Drawing.Color.FromArgb(100, 100, 100);
var valueColor = System.Drawing.Color.FromArgb(30, 30, 30);

var lblMode = new System.Windows.Forms.Label { Text = "Mod:", Location = new System.Drawing.Point(10, 10), Size = new System.Drawing.Size(70, 18), Font = summaryFont, ForeColor = labelColor };
var lblModeVal = new System.Windows.Forms.Label { 
    Text = IS_TEST ? "🧪 TEST" : "🔴 CANLI", 
    Location = new System.Drawing.Point(85, 10), Size = new System.Drawing.Size(90, 18), 
    Font = new System.Drawing.Font("Consolas", 9, System.Drawing.FontStyle.Bold), 
    ForeColor = IS_TEST ? System.Drawing.Color.Orange : System.Drawing.Color.Red 
};

var suLblViop = new System.Windows.Forms.Label { Text = "VIOP Bütçe:", Location = new System.Drawing.Point(10, 32), Size = new System.Drawing.Size(75, 18), Font = summaryFont, ForeColor = labelColor };
var suLblViopVal = new System.Windows.Forms.Label { Text = VIOP_BUDGET.ToString("N0") + " ₺", Location = new System.Drawing.Point(85, 32), Size = new System.Drawing.Size(90, 18), Font = summaryFont, ForeColor = valueColor };

var suLblSpot = new System.Windows.Forms.Label { Text = "SPOT Bütçe:", Location = new System.Drawing.Point(10, 54), Size = new System.Drawing.Size(75, 18), Font = summaryFont, ForeColor = labelColor };
var suLblSpotVal = new System.Windows.Forms.Label { Text = SPOT_BUDGET.ToString("N0") + " ₺", Location = new System.Drawing.Point(85, 54), Size = new System.Drawing.Size(90, 18), Font = summaryFont, ForeColor = valueColor };

var lblMinMarj = new System.Windows.Forms.Label { Text = "Min Marj:", Location = new System.Drawing.Point(10, 76), Size = new System.Drawing.Size(75, 18), Font = summaryFont, ForeColor = labelColor };
var lblMinMarjVal = new System.Windows.Forms.Label { Text = (SN_MIN_MARGIN * 100).ToString("F2") + "%", Location = new System.Drawing.Point(85, 76), Size = new System.Drawing.Size(90, 18), Font = summaryFont, ForeColor = valueColor };

// Özet bilgiler - sağ sütun (stratejiler)
var lblSep = new System.Windows.Forms.Label { BorderStyle = System.Windows.Forms.BorderStyle.Fixed3D, Location = new System.Drawing.Point(185, 8), Size = new System.Drawing.Size(1, 160), BackColor = System.Drawing.Color.LightGray };

var lblStrTitle = new System.Windows.Forms.Label { Text = "📊 STRATEJİLER", Location = new System.Drawing.Point(195, 10), Size = new System.Drawing.Size(120, 18), Font = new System.Drawing.Font("Segoe UI", 8, System.Drawing.FontStyle.Bold), ForeColor = System.Drawing.Color.FromArgb(30, 60, 114) };

var lblBB93 = new System.Windows.Forms.Label { Text = "BB93 Giriş:", Location = new System.Drawing.Point(195, 32), Size = new System.Drawing.Size(70, 18), Font = summaryFont, ForeColor = labelColor };
var lblBB93Val = new System.Windows.Forms.Label { 
    Text = BB93_ENTRY_ENABLED ? "✓ AKTİF" : "✗ KAPALI", 
    Location = new System.Drawing.Point(270, 32), Size = new System.Drawing.Size(90, 18), 
    Font = summaryFont, 
    ForeColor = BB93_ENTRY_ENABLED ? System.Drawing.Color.Green : System.Drawing.Color.Gray 
};

var lblNF = new System.Windows.Forms.Label { Text = "Near-Far:", Location = new System.Drawing.Point(195, 54), Size = new System.Drawing.Size(70, 18), Font = summaryFont, ForeColor = labelColor };
var lblNFVal = new System.Windows.Forms.Label { 
    Text = NF_ENABLED ? "✓ AKTİF" : "✗ KAPALI", 
    Location = new System.Drawing.Point(270, 54), Size = new System.Drawing.Size(90, 18), 
    Font = summaryFont, 
    ForeColor = NF_ENABLED ? System.Drawing.Color.Green : System.Drawing.Color.Gray 
};

var lblPair = new System.Windows.Forms.Label { Text = "Pair Trade:", Location = new System.Drawing.Point(195, 76), Size = new System.Drawing.Size(70, 18), Font = summaryFont, ForeColor = labelColor };
var lblPairVal = new System.Windows.Forms.Label { 
    Text = PAIR_ENABLED ? "✓ AKTİF" : "✗ KAPALI", 
    Location = new System.Drawing.Point(270, 76), Size = new System.Drawing.Size(90, 18), 
    Font = summaryFont, 
    ForeColor = PAIR_ENABLED ? System.Drawing.Color.Green : System.Drawing.Color.Gray 
};

var suLblPairBudget = new System.Windows.Forms.Label { Text = "Pair Bütçe:", Location = new System.Drawing.Point(195, 98), Size = new System.Drawing.Size(70, 18), Font = summaryFont, ForeColor = labelColor };
var suLblPairBudgetVal = new System.Windows.Forms.Label { Text = PAIR_BUDGET.ToString("N0") + " ₺", Location = new System.Drawing.Point(270, 98), Size = new System.Drawing.Size(90, 18), Font = summaryFont, ForeColor = valueColor };

// Pozisyon özeti (positions.json'dan)
var lblPosTitle = new System.Windows.Forms.Label { Text = "📈 POZİSYONLAR", Location = new System.Drawing.Point(10, 105), Size = new System.Drawing.Size(120, 18), Font = new System.Drawing.Font("Segoe UI", 8, System.Drawing.FontStyle.Bold), ForeColor = System.Drawing.Color.FromArgb(30, 60, 114) };

var snPosCount = snPos.Count;
var nfPosCount = nfPos.Count;
var pairPosCount = pairPos.Count;

var lblPosSN = new System.Windows.Forms.Label { Text = "SN: " + snPosCount, Location = new System.Drawing.Point(10, 125), Size = new System.Drawing.Size(50, 18), Font = summaryFont, ForeColor = snPosCount > 0 ? System.Drawing.Color.Blue : labelColor };
var lblPosNF = new System.Windows.Forms.Label { Text = "NF: " + nfPosCount, Location = new System.Drawing.Point(65, 125), Size = new System.Drawing.Size(50, 18), Font = summaryFont, ForeColor = nfPosCount > 0 ? System.Drawing.Color.Purple : labelColor };
var lblPosPair = new System.Windows.Forms.Label { Text = "Pair: " + pairPosCount, Location = new System.Drawing.Point(120, 125), Size = new System.Drawing.Size(55, 18), Font = summaryFont, ForeColor = pairPosCount > 0 ? System.Drawing.Color.Teal : labelColor };

// Gist bağlantı durumu
var gistOk = !string.IsNullOrEmpty(GIST_TOKEN) && !string.IsNullOrEmpty(GIST_ID);
var lblGist = new System.Windows.Forms.Label { Text = "Dashboard:", Location = new System.Drawing.Point(195, 125), Size = new System.Drawing.Size(70, 18), Font = summaryFont, ForeColor = labelColor };
var lblGistVal = new System.Windows.Forms.Label { 
    Text = gistOk ? "✓ BAĞLI" : "✗ YOK", 
    Location = new System.Drawing.Point(270, 125), Size = new System.Drawing.Size(90, 18), 
    Font = summaryFont, 
    ForeColor = gistOk ? System.Drawing.Color.Green : System.Drawing.Color.Orange 
};

// Son güncelleme
var lblUpdate = new System.Windows.Forms.Label { 
    Text = "settings.json: " + (System.IO.File.Exists(SETTINGS_FILE) ? System.IO.File.GetLastWriteTime(SETTINGS_FILE).ToString("dd.MM HH:mm") : "yok"), 
    Location = new System.Drawing.Point(10, 150), Size = new System.Drawing.Size(355, 18), 
    Font = new System.Drawing.Font("Segoe UI", 8), 
    ForeColor = System.Drawing.Color.Gray,
    TextAlign = System.Drawing.ContentAlignment.MiddleRight
};

pnlSummary.Controls.AddRange(new System.Windows.Forms.Control[] { 
    lblMode, lblModeVal, suLblViop, suLblViopVal, suLblSpot, suLblSpotVal, lblMinMarj, lblMinMarjVal,
    lblSep, lblStrTitle, lblBB93, lblBB93Val, lblNF, lblNFVal, lblPair, lblPairVal, suLblPairBudget, suLblPairBudgetVal,
    lblPosTitle, lblPosSN, lblPosNF, lblPosPair,
    lblGist, lblGistVal, lblUpdate
});

// Butonlar
var btnStart = new System.Windows.Forms.Button {
    Text = "▶ Başlat",
    Location = new System.Drawing.Point(20, 245),
    Size = new System.Drawing.Size(115, 40),
    BackColor = System.Drawing.Color.FromArgb(40, 167, 69),
    ForeColor = System.Drawing.Color.White,
    Font = new System.Drawing.Font("Segoe UI", 11, System.Drawing.FontStyle.Bold),
    FlatStyle = System.Windows.Forms.FlatStyle.Flat,
    Cursor = System.Windows.Forms.Cursors.Hand
};
btnStart.FlatAppearance.BorderSize = 0;
btnStart.Click += (s, e) => { userChoice = 1; startupForm.Close(); };

var suBtnSettings = new System.Windows.Forms.Button {
    Text = "⚙ Ayarlar",
    Location = new System.Drawing.Point(150, 245),
    Size = new System.Drawing.Size(115, 40),
    BackColor = System.Drawing.Color.FromArgb(0, 123, 255),
    ForeColor = System.Drawing.Color.White,
    Font = new System.Drawing.Font("Segoe UI", 11, System.Drawing.FontStyle.Bold),
    FlatStyle = System.Windows.Forms.FlatStyle.Flat,
    Cursor = System.Windows.Forms.Cursors.Hand
};
suBtnSettings.FlatAppearance.BorderSize = 0;
suBtnSettings.Click += (s, e) => { 
    ShowSettingsForm();
    // Ayarlar kapatıldıktan sonra özeti güncelle
    try { LoadSettings(); } catch { }
    lblModeVal.Text = IS_TEST ? "🧪 TEST" : "🔴 CANLI";
    lblModeVal.ForeColor = IS_TEST ? System.Drawing.Color.Orange : System.Drawing.Color.Red;
    suLblViopVal.Text = VIOP_BUDGET.ToString("N0") + " ₺";
    suLblSpotVal.Text = SPOT_BUDGET.ToString("N0") + " ₺";
    lblMinMarjVal.Text = (SN_MIN_MARGIN * 100).ToString("F2") + "%";
    lblBB93Val.Text = BB93_ENTRY_ENABLED ? "✓ AKTİF" : "✗ KAPALI";
    lblBB93Val.ForeColor = BB93_ENTRY_ENABLED ? System.Drawing.Color.Green : System.Drawing.Color.Gray;
    lblNFVal.Text = NF_ENABLED ? "✓ AKTİF" : "✗ KAPALI";
    lblNFVal.ForeColor = NF_ENABLED ? System.Drawing.Color.Green : System.Drawing.Color.Gray;
    lblPairVal.Text = PAIR_ENABLED ? "✓ AKTİF" : "✗ KAPALI";
    lblPairVal.ForeColor = PAIR_ENABLED ? System.Drawing.Color.Green : System.Drawing.Color.Gray;
    suLblPairBudgetVal.Text = PAIR_BUDGET.ToString("N0") + " ₺";
    var gistOkNew = !string.IsNullOrEmpty(GIST_TOKEN) && !string.IsNullOrEmpty(GIST_ID);
    lblGistVal.Text = gistOkNew ? "✓ BAĞLI" : "✗ YOK";
    lblGistVal.ForeColor = gistOkNew ? System.Drawing.Color.Green : System.Drawing.Color.Orange;
    lblUpdate.Text = "settings.json: " + (System.IO.File.Exists(SETTINGS_FILE) ? System.IO.File.GetLastWriteTime(SETTINGS_FILE).ToString("dd.MM HH:mm") : "yok");
};

var btnQuit = new System.Windows.Forms.Button {
    Text = "✕ Çıkış",
    Location = new System.Drawing.Point(280, 245),
    Size = new System.Drawing.Size(115, 40),
    BackColor = System.Drawing.Color.FromArgb(220, 53, 69),
    ForeColor = System.Drawing.Color.White,
    Font = new System.Drawing.Font("Segoe UI", 11, System.Drawing.FontStyle.Bold),
    FlatStyle = System.Windows.Forms.FlatStyle.Flat,
    Cursor = System.Windows.Forms.Cursors.Hand
};
btnQuit.FlatAppearance.BorderSize = 0;
btnQuit.Click += (s, e) => { userChoice = 2; startupForm.Close(); };

startupForm.Controls.AddRange(new System.Windows.Forms.Control[] { lblStartup, pnlSummary, btnStart, suBtnSettings, btnQuit });

// Form'u göster (modal - kullanıcı seçene kadar bekle)
System.Windows.Forms.Application.Run(startupForm);

// Kullanıcı çıkış seçtiyse - script tamamen bitsin
if (userChoice != 1) {
    Sistem.RobotStop();
}

// Başlat seçildiyse devam et
if (userChoice == 1) {

// Eski log dosyasını sil (temiz başlangıç)
try {
    var oldLogPath = LOG_PATH + "arb.log";
    if (System.IO.File.Exists(oldLogPath)) {
        System.IO.File.Delete(oldLogPath);
    }
    // logLines listesini de temizle (LoadSettings içinde Log çağrıldıysa dolu olabilir)
    logLines.Clear();
    logPath = "";  // Path'i sıfırla ki Log tekrar okumasın
} catch { }

Log("=== SN-NF-PAIR ROBOT v19.4 BAŞLADI ===");

var formThread = new System.Threading.Thread(() => CreateControlForm());
formThread.SetApartmentState(System.Threading.ApartmentState.STA);
formThread.IsBackground = true;
formThread.Start();

// Form oluşmasını bekle (max 5 saniye)
var formWaitStart = DateTime.Now;
while (mainForm == null && (DateTime.Now - formWaitStart).TotalSeconds < 5) {
    System.Threading.Thread.Sleep(100);
}
if (mainForm == null) {
    Log("⚠️ Form oluşturulamadı - devam ediliyor");
}

isMarketOpen = CheckMarketOpen();
Log("Piyasa: " + (isMarketOpen ? "AÇIK" : "KAPALI") + " (10:01-18:09)");

try { LoadTeminatFromFile(); } catch { }
Log("Spread BB grafik verisinden yükleniyor...");
try { LoadSpreadBBFromChart(); } catch { }
try { UpdateRiskFree(); } catch { }
try { UpdateTeminatFromVIOP(); } catch { }
try { LoadPositions(); } catch { }
try { LoadStatsHistory(); } catch { }
try { UpdateBalances(); } catch { }
try { UpdateDividends(); } catch { }  // Temettü verilerini güncelle/yükle
try { UpdateSermayeArtirimi(); } catch { }  // Sermaye artırımı verilerini güncelle/yükle

// Pair Trading: Başlangıçta Z-Score hesapla (piyasa kapalı olsa bile)
if (PAIR_ENABLED && PAIR_DEFS.Count > 0) {
    try { 
        LoadPairData(); 
        Log("📊 PAIR: " + PAIR_DEFS.Count + " çift tanımlı, Z-Score yüklendi");
    } catch (Exception ex) { 
        Log("⚠️ PAIR: Veri yükleme hatası - " + ex.Message); 
    }
}

Log("Hazır: " + symbols.Count + " sembol, " + snPos.Count + " pozisyon");
if (IS_TEST) {
    Log("Bakiye: VIOP=" + viopBalance.ToString("N0") + " SPOT=" + spotBudgetTotal.ToString("N0") + " (kalan:" + spotBalance.ToString("N0") + ") [TEST]");
} else {
    Log("Bakiye: VIOP=" + viopBalance.ToString("N0") + " SPOT=" + spotBudgetTotal.ToString("N0") + " (T+2:" + t2Balance.ToString("N0") + ") [GERÇEK]");
}

// Robot çalışıyor olarak işaretle
isRunning = true;

// Tavan/taban fiyatlarını yükle (gün içi başlatma için gerekli)
LoadTavanTaban();

// Başlangıç recovery'si (sadece normal mod)
if (!IS_TEST) {
    Log("🔄 Başlangıç pozisyon senkronizasyonu...");
    SyncAndRecoverPositions();  // RefreshHesaplar içinde bekleme var
    recoveryTriggered = true;
    
    // İlk bakiye güncellemesi (T+2 hesaplanacak)
    UpdateBalances();
    Log("📊 Bütçe: VIOP=" + viopBalance.ToString("N0") + " SPOT=" + spotBudgetTotal.ToString("N0") + " (T+2:" + t2Balance.ToString("N0") + ")");
    
    // İlk Gist güncellemesi + komut sıfırlama
    Log("📤 İlk Gist güncellemesi gönderiliyor...");
    UpdateDashboard(true, true);  // resetCommand=true, includeLogs=true
    Log("✅ İlk Gist güncellemesi tamamlandı");
    
    // Başlangıçta veri bağlantısı durumunu kontrol et
    dataConnected = Sistem.BaglantiVar;
    if (!dataConnected) {
        Log("⚠️ Başlangıçta veri bağlantısı yok");
    }
}

var lastRiskFreeUpdate = DateTime.Now;
var lastFormUpdate = DateTime.Now;

while (true) {
    try {
        // STOP kontrolü - döngü başında hemen kontrol et
        if (stopRequested || (mainForm != null && mainForm.IsDisposed)) {
            Log("=== SN-NF-PAIR ROBOT v19.4 DURDU ===");
            // NOT: STOP.txt silinmiyor - yeniden başlamayı engellemek için kalacak
            isRunning = false;
            UpdateDashboard(false, true);
            Log("📤 Dashboard'a durma bildirimi gönderildi");
            Sistem.RobotStop();
            break;
        }
        
        // IdealData veri bağlantısı kontrolü
        var wasDataConnected = dataConnected;
        dataConnected = Sistem.BaglantiVar;
        if (!dataConnected) {
            if (wasDataConnected) {
                // İlk kopma anı - hemen full Gist gönder
                Log("⚠️ Veri bağlantısı koptu!");
                UpdateDashboard(false, true);  // Tam güncelleme (log dahil)
                lastGistUpload = DateTime.Now;  // Zamanı kaydet
            } else {
                // Kopuk kaldı - 1 dk sonra bir kere, sonra saatte bir dene
                var minutesSinceLastUpload = (DateTime.Now - lastGistUpload).TotalMinutes;
                if ((minutesSinceLastUpload >= 1 && minutesSinceLastUpload < 2) || minutesSinceLastUpload >= 60) {
                    var statsJson = BuildStatsJson();
                    SafeWrite(STATS_FILE, statsJson);
                    UpdateDashboard(false, true);
                }
            }
            
            // Veri bağlantısı kopukken de broker kontrolü yap
            CheckBrokerConnection();
            
            System.Threading.Thread.Sleep(5000);
            continue;
        } else if (!wasDataConnected) {
            Log("✅ Veri bağlantısı yeniden sağlandı");
            UpdateDashboard(false, true);  // Tam güncelleme (log dahil)
        }
        
        // STOP.txt dosyası kontrolü (uzaktan durdurma için)
        if (System.IO.File.Exists(BASE_PATH + "STOP.txt")) {
            stopRequested = true;
            continue;  // Döngü başına git, orada çıkış yapılacak
        }
        
        isMarketOpen = CheckMarketOpen();
        
        if ((DateTime.Now - lastFormUpdate).TotalSeconds >= 2) {
            UpdateFormInfo();
            lastFormUpdate = DateTime.Now;
        }
        
        // Piyasa kapalıyken de Gist'i güncelle (dakikada bir)
        if (!isMarketOpen) {
            if ((DateTime.Now - lastGistUpload).TotalMinutes >= 1) {
                // Lokal dosyaya yaz ve Gist'e yükle
                var statsJson = BuildStatsJson();
                SafeWrite(STATS_FILE, statsJson);
                UpdateDashboard(false, true);  // resetCommand=false, includeLogs=true
            }
            
            // Piyasa kapalıyken 30sn yerine 5sn bekle (stopRequested daha hızlı kontrol edilsin)
            System.Threading.Thread.Sleep(5000);
            continue;
        }
        
        // Duraklama döngüsü - dakikada bir Gist kontrolü (STOP ve RESUME için)
        if (isPaused) {
            var timeSinceLastCheck = (DateTime.Now - lastGistUpload).TotalMinutes;
            if (timeSinceLastCheck >= 1) {
                CheckGistCommand();
                lastGistUpload = DateTime.Now;  // Kontrol zamanını güncelle
                if (stopRequested) continue;  // STOP geldi, hemen döngü başına git
            }
            System.Threading.Thread.Sleep(LOOP_MS);
            continue;
        }
        
        // Periyodik recovery kontrolü (11:50, 17:35) - sadece normal mod
        CheckScheduledRecovery();
        
        // Recovery retry kontrolü (teyit alınamadıysa 30sn sonra tekrar)
        if (recoveryRetryNeeded && DateTime.Now >= recoveryRetryTime) {
            Log("🔄 RECOVERY RETRY: Teyit alınamayan işlem için tekrar kontrol...");
            recoveryRetryNeeded = false;
            SyncAndRecoverPositions();
        }
        
        // Teminat güncelleme kontrolü (09:20'de)
        CheckTeminatUpdate();
        
        // Derinlik cache warmup (09:56'da - piyasa açılışından önce)
        WarmupDepthCache();
        
        if ((DateTime.Now - lastRiskFreeUpdate).TotalMinutes >= 5) {
            UpdateRiskFree();
            lastRiskFreeUpdate = DateTime.Now;
        }
        
        if (DateTime.Today > lastBlockReset) {
            // Önce dünün stats'ını kaydet (eğer veri varsa)
            if (dailySNPnl != 0 || totalClosedSN > 0 || dailyViopCommission > 0 || dailySpotCommission > 0) {
                var yesterday = lastBlockReset.ToString("yyyy-MM-dd");
                statsHistory[yesterday] = new decimal[] { dailySNPnl, dailyViopCommission, dailySpotCommission, totalClosedSN };
                SaveStatsHistory();
                Log("📊 Dün stats kaydedildi: " + yesterday);
            }
            
            // Günlük değişkenleri sıfırla
            blockedSymbols.Clear();
            dailyRealizedPnl = 0;
            dailyTrades = 0;
            dailySpotCommission = 0;
            dailyViopCommission = 0;
            dailySNPnl = 0;
            totalClosedSN = 0;
            dailyPairPnl = 0;       // Pair günlük P&L sıfırla
            totalClosedPair = 0;    // Pair kapatılan pozisyon sayısı sıfırla
            totalTransferredComm = 0;  // Yeni gün, transfer sıfırla
            lastBlockReset = DateTime.Today;
            lastStatsSaveDate = "";
            Log("📅 Yeni gün");
            
            // Temettü verilerini güncelle
            try { UpdateDividends(); } catch { }
        }
        
        // 09:25'te temettü verilerini kontrol et (gün içinde henüz güncellenmemişse)
        var nowMinutes = DateTime.Now.Hour * 60 + DateTime.Now.Minute;
        if (nowMinutes >= 9 * 60 + 25 && nowMinutes <= 9 * 60 + 27 && lastTemettuCheck.Date < DateTime.Today) {
            try { UpdateDividends(); } catch { }
        }
        
        // 09:25'te sermaye artırımı verilerini kontrol et (gün içinde henüz güncellenmemişse)
        if (nowMinutes >= 9 * 60 + 25 && nowMinutes <= 9 * 60 + 27 && lastSrmCheck.Date < DateTime.Today) {
            try { UpdateSermayeArtirimi(); } catch { }
        }
        
        // 10:10'da sermaye artırımı olan pozisyonları otomatik kapat
        if (nowMinutes >= 10 * 60 + 10 && nowMinutes <= 10 * 60 + 12 && lastSrmCloseCheck.Date < DateTime.Today) {
            lastSrmCloseCheck = DateTime.Now;
            
            try {
                var closedCount = 0;
                
                // SN pozisyonlarını kontrol et ve kapat
                var snToClose = new System.Collections.Generic.List<string>();
                foreach (var kv in snPos) {
                    if (CheckSermayeArtirimi(kv.Key) > 0) {
                        snToClose.Add(kv.Key);
                    }
                }
                foreach (var sym in snToClose) {
                    try {
                        if (!snPos.ContainsKey(sym)) continue;
                        var pos = snPos[sym];
                        var sQty = (int)pos[0];
                        var nQty = (int)pos[1];
                        var nearC = GetContract(sym, 0);
                        if (nQty > 0 && !string.IsNullOrEmpty(nearC)) {
                            Log("🚨 SERMAYE ARTIRIMI KAPATMA (SN): " + sym + " Spot:" + sQty + " Near:" + nQty);
                            CloseSN(sym, nearC, sQty, nQty, "SERMAYE_ARTIRIMI");
                            closedCount++;
                        }
                    } catch (Exception ex) { Log("❌ SN kapatma hatası (" + sym + "): " + ex.Message); }
                }
                
                // NF pozisyonlarını kontrol et ve kapat
                var nfToClose = new System.Collections.Generic.List<string>();
                foreach (var kv in nfPos) {
                    if (CheckSermayeArtirimi(kv.Key) > 0) {
                        nfToClose.Add(kv.Key);
                    }
                }
                foreach (var sym in nfToClose) {
                    try {
                        if (!nfPos.ContainsKey(sym)) continue;
                        var pos = nfPos[sym];
                        var nearQty = (int)pos[0];
                        var farQty = (int)pos[1];
                        var nearC = nfContracts.ContainsKey(sym) ? nfContracts[sym][0] : GetContract(sym, 0);
                        var farC = nfContracts.ContainsKey(sym) ? nfContracts[sym][1] : GetContract(sym, 1);
                        if (nearQty > 0 && farQty > 0 && !string.IsNullOrEmpty(nearC) && !string.IsNullOrEmpty(farC)) {
                            Log("🚨 SERMAYE ARTIRIMI KAPATMA (NF): " + sym + " Near:" + nearQty + " Far:" + farQty);
                            CloseNF(sym, nearC, farC, nearQty, farQty, "SERMAYE_ARTIRIMI");
                            closedCount++;
                        }
                    } catch (Exception ex) { Log("❌ NF kapatma hatası (" + sym + "): " + ex.Message); }
                }
                
                // Pair pozisyonlarını kontrol et ve kapat
                var pairToClose = new System.Collections.Generic.List<int>();
                for (int pi = 0; pi < PAIR_DEFS.Count; pi++) {
                    var def = PAIR_DEFS[pi];
                    var symA = (string)def[0];
                    var symB = (string)def[1];
                    var pairKey = GetPairKey(symA, symB);
                    if (pairPos.ContainsKey(pairKey) && (CheckSermayeArtirimi(symA) > 0 || CheckSermayeArtirimi(symB) > 0)) {
                        pairToClose.Add(pi);
                    }
                }
                foreach (var pairIdx in pairToClose) {
                    try {
                        var def = PAIR_DEFS[pairIdx];
                        var symA = (string)def[0];
                        var symB = (string)def[1];
                        var pairKey = GetPairKey(symA, symB);
                        Log("🚨 SERMAYE ARTIRIMI KAPATMA (PAIR): " + pairKey);
                        ClosePair(pairIdx);
                        closedCount++;
                    } catch (Exception ex) { Log("❌ Pair kapatma hatası: " + ex.Message); }
                }
                
                if (closedCount > 0) {
                    Log("✅ Sermaye artırımı kapatma tamamlandı: " + closedCount + " pozisyon kapatıldı");
                    SavePositions();
                }
            } catch (Exception ex) {
                Log("❌ Sermaye artırımı kapatma genel hatası: " + ex.Message);
            }
        }
        
        // VİOP komisyonlarını 15 dakikada bir SPOT'a transfer et
        if ((DateTime.Now - lastCommissionTransfer).TotalMinutes >= 15) {
            TransferViopCommission();
        }
        
        // Bakiyeleri güncelle (her döngüde) - cache'i doldurur
        UpdateBalances();
        
        // Aracı kurum bağlantı kontrolü (UpdateBalances sonrası, cache dolu)
        CheckBrokerConnection();
        
        // Endeks devre kesici kontrolü (her döngüde)
        CheckIndexCircuitBreaker();
        
        // Not: CheckMarginStatus artık RefreshHesaplar içinden tetikleniyor
        
        MainLoop();
        System.Threading.Thread.Sleep(LOOP_MS);
    } catch (Exception ex) {
        Log("HATA: " + ex.Message);
        System.Threading.Thread.Sleep(5000);
    }
}

Log("=== ROBOT DURDURULDU ===");
// Log artık List<string> ile tutuluyor, StreamWriter yok

} // userChoice == 1 kapanışı
